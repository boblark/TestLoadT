
/tmp/arduino_build_934392/TL_TestOutput_float.ino.elf:     file format elf32-littlearm


Disassembly of section .text.progmem:

60000000 <FlexSPI_NOR_Config>:
60000000:	46 43 46 42 00 00 01 56 00 00 00 00 01 01 02 00     FCFB...V........
	...
60000044:	01 04 03 00 00 00 00 00 00 00 00 00 00 00 20 00     .............. .
	...
60000080:	eb 04 18 0a 06 32 04 26 00 00 00 00 00 00 00 00     .....2.&........
60000090:	05 04 04 24 00 00 00 00 00 00 00 00 00 00 00 00     ...$............
	...
600000b0:	06 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
600000d0:	20 04 18 08 00 00 00 00 00 00 00 00 00 00 00 00      ...............
	...
60000100:	d8 04 18 08 00 00 00 00 00 00 00 00 00 00 00 00     ................
60000110:	02 04 18 08 04 20 00 00 00 00 00 00 00 00 00 00     ..... ..........
	...
60000130:	60 04 00 00 00 00 00 00 00 00 00 00 00 00 00 00     `...............
	...
600001c0:	00 01 00 00 00 10 00 00 01 00 00 00 00 00 00 00     ................
600001d0:	00 00 01 00 00 00 00 00 00 00 00 00 00 00 00 00     ................
	...
60000200:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000210:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000220:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000230:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000240:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000250:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000260:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000270:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000280:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000290:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600002f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000300:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000310:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000320:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000330:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000340:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000350:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000360:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000370:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000380:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000390:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600003f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000400:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000410:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000420:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000430:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000440:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000450:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000460:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000470:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000480:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000490:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600004f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000500:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000510:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000520:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000530:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000540:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000550:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000560:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000570:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000580:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000590:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600005f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000600:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000610:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000620:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000630:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000640:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000650:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000660:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000670:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000680:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000690:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600006f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000700:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000710:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000720:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000730:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000740:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000750:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000760:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000770:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000780:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000790:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600007f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000800:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000810:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000820:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000830:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000840:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000850:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000860:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000870:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000880:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000890:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600008f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000900:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000910:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000920:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000930:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000940:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000950:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000960:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000970:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000980:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000990:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009a0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009b0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009c0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009d0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009e0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
600009f0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000a90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000aa0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ab0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ac0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ad0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ae0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000af0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000b90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ba0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000bb0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000bc0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000bd0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000be0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000bf0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000c90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ca0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000cb0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000cc0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000cd0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ce0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000cf0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000d90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000da0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000db0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000dc0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000dd0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000de0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000df0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000e90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ea0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000eb0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ec0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ed0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ee0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ef0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f00:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f10:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f20:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f30:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f40:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f50:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f60:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f70:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f80:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000f90:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000fa0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000fb0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000fc0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000fd0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000fe0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................
60000ff0:	ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff ff     ................

60001000 <ImageVectorTable>:
60001000:	d1 00 20 40 2c 10 00 60 00 00 00 00 00 00 00 00     .. @,..`........
60001010:	20 10 00 60 00 10 00 60 00 00 00 00 00 00 00 00      ..`...`........

60001020 <BootData>:
60001020:	00 00 00 60 f8 72 00 00 00 00 00 00                 ...`.r......

6000102c <vector_table>:
6000102c:	00 00 01 20 59 10 00 60                             ... Y..`

60001034 <memory_copy>:
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
60001034:	4288      	cmp	r0, r1
60001036:	d104      	bne.n	60001042 <memory_copy+0xe>
60001038:	4770      	bx	lr
	while (dest < dest_end) {
		*dest++ = *src++;
6000103a:	680b      	ldr	r3, [r1, #0]
6000103c:	6003      	str	r3, [r0, #0]
6000103e:	3104      	adds	r1, #4
60001040:	3004      	adds	r0, #4

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_copy(uint32_t *dest, const uint32_t *src, uint32_t *dest_end)
{
	if (dest == src) return;
	while (dest < dest_end) {
60001042:	4290      	cmp	r0, r2
60001044:	d3f9      	bcc.n	6000103a <memory_copy+0x6>
60001046:	4770      	bx	lr

60001048 <memory_clear>:
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001048:	e002      	b.n	60001050 <memory_clear+0x8>
		*dest++ = 0;
6000104a:	2300      	movs	r3, #0
6000104c:	6003      	str	r3, [r0, #0]
6000104e:	3004      	adds	r0, #4
}

__attribute__((section(".startup"), optimize("no-tree-loop-distribute-patterns")))
static void memory_clear(uint32_t *dest, uint32_t *dest_end)
{
	while (dest < dest_end) {
60001050:	4288      	cmp	r0, r1
60001052:	d3fa      	bcc.n	6000104a <memory_clear+0x2>
		*dest++ = 0;
	}
}
60001054:	4770      	bx	lr
60001056:	bf00      	nop

60001058 <ResetHandler>:
void ResetHandler(void)
{
	unsigned int i;

#if defined(__IMXRT1062__)
	IOMUXC_GPR_GPR17 = (uint32_t)&_flexram_bank_config;
60001058:	4b4b      	ldr	r3, [pc, #300]	; (60001188 <ResetHandler+0x130>)
6000105a:	4a4c      	ldr	r2, [pc, #304]	; (6000118c <ResetHandler+0x134>)
6000105c:	645a      	str	r2, [r3, #68]	; 0x44
	IOMUXC_GPR_GPR16 = 0x00200007;
6000105e:	4a4c      	ldr	r2, [pc, #304]	; (60001190 <ResetHandler+0x138>)
60001060:	641a      	str	r2, [r3, #64]	; 0x40
	IOMUXC_GPR_GPR14 = 0x00AA0000;
60001062:	f44f 022a 	mov.w	r2, #11141120	; 0xaa0000
60001066:	639a      	str	r2, [r3, #56]	; 0x38
	__asm__ volatile("mov sp, %0" : : "r" ((uint32_t)&_estack) : );
60001068:	4b4a      	ldr	r3, [pc, #296]	; (60001194 <ResetHandler+0x13c>)
6000106a:	469d      	mov	sp, r3
#endif
	PMU_MISC0_SET = 1<<3; //Use bandgap-based bias currents for best performance (Page 1175)
6000106c:	2208      	movs	r2, #8
6000106e:	4b4a      	ldr	r3, [pc, #296]	; (60001198 <ResetHandler+0x140>)
60001070:	f8c3 2154 	str.w	r2, [r3, #340]	; 0x154
	//IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
	//GPIO7_GDIR |= (1<<3);
	//GPIO7_DR_SET = (1<<3); // digitalWrite(13, HIGH);

	// Initialize memory
	memory_copy(&_stext, &_stextload, &_etext);
60001074:	4a49      	ldr	r2, [pc, #292]	; (6000119c <ResetHandler+0x144>)
60001076:	494a      	ldr	r1, [pc, #296]	; (600011a0 <ResetHandler+0x148>)
60001078:	484a      	ldr	r0, [pc, #296]	; (600011a4 <ResetHandler+0x14c>)
6000107a:	f7ff ffdb 	bl	60001034 <memory_copy>
	memory_copy(&_sdata, &_sdataload, &_edata);
6000107e:	4a4a      	ldr	r2, [pc, #296]	; (600011a8 <ResetHandler+0x150>)
60001080:	494a      	ldr	r1, [pc, #296]	; (600011ac <ResetHandler+0x154>)
60001082:	484b      	ldr	r0, [pc, #300]	; (600011b0 <ResetHandler+0x158>)
60001084:	f7ff ffd6 	bl	60001034 <memory_copy>
	memory_clear(&_sbss, &_ebss);
60001088:	494a      	ldr	r1, [pc, #296]	; (600011b4 <ResetHandler+0x15c>)
6000108a:	484b      	ldr	r0, [pc, #300]	; (600011b8 <ResetHandler+0x160>)
6000108c:	f7ff ffdc 	bl	60001048 <memory_clear>

	// enable FPU
	SCB_CPACR = 0x00F00000;
60001090:	f44f 0270 	mov.w	r2, #15728640	; 0xf00000
60001094:	4b49      	ldr	r3, [pc, #292]	; (600011bc <ResetHandler+0x164>)
60001096:	601a      	str	r2, [r3, #0]

	// set up blank interrupt & exception vector table
	for (i=0; i < NVIC_NUM_INTERRUPTS + 16; i++) _VectorsRam[i] = &unused_interrupt_vector;
60001098:	2300      	movs	r3, #0
6000109a:	e004      	b.n	600010a6 <ResetHandler+0x4e>
6000109c:	4948      	ldr	r1, [pc, #288]	; (600011c0 <ResetHandler+0x168>)
6000109e:	4a49      	ldr	r2, [pc, #292]	; (600011c4 <ResetHandler+0x16c>)
600010a0:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
600010a4:	3301      	adds	r3, #1
600010a6:	2baf      	cmp	r3, #175	; 0xaf
600010a8:	d9f8      	bls.n	6000109c <ResetHandler+0x44>
600010aa:	2300      	movs	r3, #0
600010ac:	e003      	b.n	600010b6 <ResetHandler+0x5e>
	for (i=0; i < NVIC_NUM_INTERRUPTS; i++) NVIC_SET_PRIORITY(i, 128);
600010ae:	2180      	movs	r1, #128	; 0x80
600010b0:	4a45      	ldr	r2, [pc, #276]	; (600011c8 <ResetHandler+0x170>)
600010b2:	5499      	strb	r1, [r3, r2]
600010b4:	3301      	adds	r3, #1
600010b6:	2b9f      	cmp	r3, #159	; 0x9f
600010b8:	d9f9      	bls.n	600010ae <ResetHandler+0x56>
	SCB_VTOR = (uint32_t)_VectorsRam;
600010ba:	4b44      	ldr	r3, [pc, #272]	; (600011cc <ResetHandler+0x174>)
600010bc:	4a41      	ldr	r2, [pc, #260]	; (600011c4 <ResetHandler+0x16c>)
600010be:	601a      	str	r2, [r3, #0]

	reset_PFD();
600010c0:	f000 f8c4 	bl	6000124c <reset_PFD>
	
	// Configure clocks
	// TODO: make sure all affected peripherals are turned off!
	// PIT & GPT timers to run from 24 MHz clock (independent of CPU speed)
	CCM_CSCMR1 = (CCM_CSCMR1 & ~CCM_CSCMR1_PERCLK_PODF(0x3F)) | CCM_CSCMR1_PERCLK_CLK_SEL;
600010c4:	4c42      	ldr	r4, [pc, #264]	; (600011d0 <ResetHandler+0x178>)
600010c6:	69e3      	ldr	r3, [r4, #28]
600010c8:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600010cc:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600010d0:	61e3      	str	r3, [r4, #28]
	// UARTs run from 24 MHz clock (works if PLL3 off or bypassed)
	CCM_CSCDR1 = (CCM_CSCDR1 & ~CCM_CSCDR1_UART_CLK_PODF(0x3F)) | CCM_CSCDR1_UART_CLK_SEL;
600010d2:	6a63      	ldr	r3, [r4, #36]	; 0x24
600010d4:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
600010d8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
600010dc:	6263      	str	r3, [r4, #36]	; 0x24

#if defined(__IMXRT1062__)
	// Use fast GPIO6, GPIO7, GPIO8, GPIO9
	IOMUXC_GPR_GPR26 = 0xFFFFFFFF;
600010de:	4b2a      	ldr	r3, [pc, #168]	; (60001188 <ResetHandler+0x130>)
600010e0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
600010e4:	669a      	str	r2, [r3, #104]	; 0x68
	IOMUXC_GPR_GPR27 = 0xFFFFFFFF;
600010e6:	66da      	str	r2, [r3, #108]	; 0x6c
	IOMUXC_GPR_GPR28 = 0xFFFFFFFF;
600010e8:	671a      	str	r2, [r3, #112]	; 0x70
	IOMUXC_GPR_GPR29 = 0xFFFFFFFF;
600010ea:	675a      	str	r2, [r3, #116]	; 0x74
	// must enable PRINT_DEBUG_STUFF in debug/print.h
	printf_debug_init();
	printf("\n***********IMXRT Startup**********\n");
	printf("test %d %d %d\n", 1, -1234567, 3);

	configure_cache();
600010ec:	f000 f8c2 	bl	60001274 <configure_cache>
	configure_systick();
600010f0:	f000 fbc2 	bl	60001878 <__configure_systick_veneer>
	usb_pll_start();	
600010f4:	f000 f936 	bl	60001364 <usb_pll_start>
	reset_PFD(); //TODO: is this really needed?
600010f8:	f000 f8a8 	bl	6000124c <reset_PFD>
#ifdef F_CPU
	set_arm_clock(F_CPU);
600010fc:	4835      	ldr	r0, [pc, #212]	; (600011d4 <ResetHandler+0x17c>)
600010fe:	f000 fbd3 	bl	600018a8 <__set_arm_clock_veneer>
#endif

	asm volatile("nop\n nop\n nop\n nop": : :"memory"); // why oh why?
60001102:	bf00      	nop
60001104:	bf00      	nop
60001106:	bf00      	nop
60001108:	bf00      	nop

	// Undo PIT timer usage by ROM startup
	CCM_CCGR1 |= CCM_CCGR1_PIT(CCM_CCGR_ON);
6000110a:	6ee3      	ldr	r3, [r4, #108]	; 0x6c
6000110c:	f443 5340 	orr.w	r3, r3, #12288	; 0x3000
60001110:	66e3      	str	r3, [r4, #108]	; 0x6c
	PIT_MCR = 0;
60001112:	4b31      	ldr	r3, [pc, #196]	; (600011d8 <ResetHandler+0x180>)
60001114:	2200      	movs	r2, #0
60001116:	601a      	str	r2, [r3, #0]
	PIT_TCTRL0 = 0;
60001118:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
	PIT_TCTRL1 = 0;
6000111c:	f8c3 2118 	str.w	r2, [r3, #280]	; 0x118
	PIT_TCTRL2 = 0;
60001120:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
	PIT_TCTRL3 = 0;
60001124:	f8c3 2138 	str.w	r2, [r3, #312]	; 0x138

	// initialize RTC
	if (!(SNVS_LPCR & SNVS_LPCR_SRTC_ENV)) {
60001128:	f503 23a0 	add.w	r3, r3, #327680	; 0x50000
6000112c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
6000112e:	f013 0f01 	tst.w	r3, #1
60001132:	d109      	bne.n	60001148 <ResetHandler+0xf0>
		// if SRTC isn't running, start it with default Jan 1, 2019
		SNVS_LPSRTCLR = 1546300800u << 15;
60001134:	4b29      	ldr	r3, [pc, #164]	; (600011dc <ResetHandler+0x184>)
60001136:	4a2a      	ldr	r2, [pc, #168]	; (600011e0 <ResetHandler+0x188>)
60001138:	655a      	str	r2, [r3, #84]	; 0x54
		SNVS_LPSRTCMR = 1546300800u >> 17;
6000113a:	f642 6215 	movw	r2, #11797	; 0x2e15
6000113e:	651a      	str	r2, [r3, #80]	; 0x50
		SNVS_LPCR |= SNVS_LPCR_SRTC_ENV;
60001140:	6b9a      	ldr	r2, [r3, #56]	; 0x38
60001142:	f042 0201 	orr.w	r2, r2, #1
60001146:	639a      	str	r2, [r3, #56]	; 0x38
	}
	SNVS_HPCR |= SNVS_HPCR_RTC_EN | SNVS_HPCR_HP_TS;
60001148:	4a24      	ldr	r2, [pc, #144]	; (600011dc <ResetHandler+0x184>)
6000114a:	6893      	ldr	r3, [r2, #8]
6000114c:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
60001150:	6093      	str	r3, [r2, #8]

#ifdef ARDUINO_TEENSY41
	configure_external_ram();
#endif
	startup_early_hook();
60001152:	f000 fb9d 	bl	60001890 <__startup_early_hook_veneer>
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
60001156:	4b23      	ldr	r3, [pc, #140]	; (600011e4 <ResetHandler+0x18c>)
60001158:	681b      	ldr	r3, [r3, #0]
	while (millis() < 20) ; // wait at least 20ms before starting USB
6000115a:	2b13      	cmp	r3, #19
6000115c:	d9fb      	bls.n	60001156 <ResetHandler+0xfe>
	usb_init();
6000115e:	f000 f9cb 	bl	600014f8 <usb_init>
	analog_init();
60001162:	f000 fa79 	bl	60001658 <analog_init>
	pwm_init();
60001166:	f000 fb97 	bl	60001898 <__pwm_init_veneer>
	tempmon_init();
6000116a:	f000 f92f 	bl	600013cc <tempmon_init>

	startup_late_hook();
6000116e:	f000 fb9f 	bl	600018b0 <__startup_late_hook_veneer>
60001172:	4b1c      	ldr	r3, [pc, #112]	; (600011e4 <ResetHandler+0x18c>)
60001174:	681b      	ldr	r3, [r3, #0]
	while (millis() < 300) ; // wait at least 300ms before calling user code
60001176:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
6000117a:	d3fa      	bcc.n	60001172 <ResetHandler+0x11a>
	//printf("before C++ constructors\n");
	__libc_init_array();
6000117c:	f000 fb90 	bl	600018a0 <____libc_init_array_veneer>
	//printf("after C++ constructors\n");
	//printf("before setup\n");
	main();
60001180:	f000 fb7e 	bl	60001880 <__main_veneer>
60001184:	e7fe      	b.n	60001184 <ResetHandler+0x12c>
60001186:	bf00      	nop
60001188:	400ac000 	.word	0x400ac000
6000118c:	aaaaaaab 	.word	0xaaaaaaab
60001190:	00200007 	.word	0x00200007
60001194:	20078000 	.word	0x20078000
60001198:	400d8000 	.word	0x400d8000
6000119c:	00004a18 	.word	0x00004a18
600011a0:	60001940 	.word	0x60001940
600011a4:	00000000 	.word	0x00000000
600011a8:	20000fa0 	.word	0x20000fa0
600011ac:	6000635c 	.word	0x6000635c
600011b0:	20000000 	.word	0x20000000
600011b4:	200032c0 	.word	0x200032c0
600011b8:	20000fa0 	.word	0x20000fa0
600011bc:	e000ed88 	.word	0xe000ed88
600011c0:	00002ae1 	.word	0x00002ae1
600011c4:	20001800 	.word	0x20001800
600011c8:	e000e400 	.word	0xe000e400
600011cc:	e000ed08 	.word	0xe000ed08
600011d0:	400fc000 	.word	0x400fc000
600011d4:	23c34600 	.word	0x23c34600
600011d8:	40084000 	.word	0x40084000
600011dc:	400d4000 	.word	0x400d4000
600011e0:	56c00000 	.word	0x56c00000
600011e4:	200013d4 	.word	0x200013d4

600011e8 <set_audioClock(int, long, unsigned long, bool)>:
#include "imxrt_hw.h"

FLASHMEM
void set_audioClock(int nfact, int32_t nmult, uint32_t ndiv, bool force) // sets PLL4
{
	if (!force && (CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_ENABLE)) return;
600011e8:	b933      	cbnz	r3, 600011f8 <set_audioClock(int, long, unsigned long, bool)+0x10>
600011ea:	4b16      	ldr	r3, [pc, #88]	; (60001244 <set_audioClock(int, long, unsigned long, bool)+0x5c>)
600011ec:	6f1b      	ldr	r3, [r3, #112]	; 0x70
600011ee:	f413 5f00 	tst.w	r3, #8192	; 0x2000
600011f2:	d103      	bne.n	600011fc <set_audioClock(int, long, unsigned long, bool)+0x14>
600011f4:	2300      	movs	r3, #0
600011f6:	e002      	b.n	600011fe <set_audioClock(int, long, unsigned long, bool)+0x16>
600011f8:	2300      	movs	r3, #0
600011fa:	e000      	b.n	600011fe <set_audioClock(int, long, unsigned long, bool)+0x16>
600011fc:	2301      	movs	r3, #1
600011fe:	bb03      	cbnz	r3, 60001242 <set_audioClock(int, long, unsigned long, bool)+0x5a>

	CCM_ANALOG_PLL_AUDIO = CCM_ANALOG_PLL_AUDIO_BYPASS | CCM_ANALOG_PLL_AUDIO_ENABLE
			     | CCM_ANALOG_PLL_AUDIO_POST_DIV_SELECT(2) // 2: 1/4; 1: 1/2; 0: 1/1
			     | CCM_ANALOG_PLL_AUDIO_DIV_SELECT(nfact);
60001200:	f000 003f 	and.w	r0, r0, #63	; 0x3f
60001204:	f440 1089 	orr.w	r0, r0, #1122304	; 0x112000
60001208:	4b0e      	ldr	r3, [pc, #56]	; (60001244 <set_audioClock(int, long, unsigned long, bool)+0x5c>)
6000120a:	6718      	str	r0, [r3, #112]	; 0x70

	CCM_ANALOG_PLL_AUDIO_NUM   = nmult & CCM_ANALOG_PLL_AUDIO_NUM_MASK;
6000120c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
60001210:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	CCM_ANALOG_PLL_AUDIO_DENOM = ndiv & CCM_ANALOG_PLL_AUDIO_DENOM_MASK;
60001214:	f022 4260 	bic.w	r2, r2, #3758096384	; 0xe0000000
60001218:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
	
	CCM_ANALOG_PLL_AUDIO &= ~CCM_ANALOG_PLL_AUDIO_POWERDOWN;//Switch on PLL
6000121c:	6f1a      	ldr	r2, [r3, #112]	; 0x70
6000121e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
60001222:	671a      	str	r2, [r3, #112]	; 0x70
	while (!(CCM_ANALOG_PLL_AUDIO & CCM_ANALOG_PLL_AUDIO_LOCK)) {}; //Wait for pll-lock
60001224:	4b07      	ldr	r3, [pc, #28]	; (60001244 <set_audioClock(int, long, unsigned long, bool)+0x5c>)
60001226:	6f1b      	ldr	r3, [r3, #112]	; 0x70
60001228:	2b00      	cmp	r3, #0
6000122a:	dafb      	bge.n	60001224 <set_audioClock(int, long, unsigned long, bool)+0x3c>
	
	const int div_post_pll = 1; // other values: 2,4
	CCM_ANALOG_MISC2 &= ~(CCM_ANALOG_MISC2_DIV_MSB | CCM_ANALOG_MISC2_DIV_LSB);
6000122c:	4b05      	ldr	r3, [pc, #20]	; (60001244 <set_audioClock(int, long, unsigned long, bool)+0x5c>)
6000122e:	f8d3 1170 	ldr.w	r1, [r3, #368]	; 0x170
60001232:	4a05      	ldr	r2, [pc, #20]	; (60001248 <set_audioClock(int, long, unsigned long, bool)+0x60>)
60001234:	400a      	ands	r2, r1
60001236:	f8c3 2170 	str.w	r2, [r3, #368]	; 0x170
	if(div_post_pll>1) CCM_ANALOG_MISC2 |= CCM_ANALOG_MISC2_DIV_LSB;
	if(div_post_pll>3) CCM_ANALOG_MISC2 |= CCM_ANALOG_MISC2_DIV_MSB;
	
	CCM_ANALOG_PLL_AUDIO &= ~CCM_ANALOG_PLL_AUDIO_BYPASS;//Disable Bypass
6000123a:	6f1a      	ldr	r2, [r3, #112]	; 0x70
6000123c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
60001240:	671a      	str	r2, [r3, #112]	; 0x70
60001242:	4770      	bx	lr
60001244:	400d8000 	.word	0x400d8000
60001248:	ff7f7fff 	.word	0xff7f7fff

6000124c <reset_PFD>:
}

FLASHMEM void reset_PFD()
{	
	//Reset PLL2 PFDs, set default frequencies:
	CCM_ANALOG_PFD_528_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);
6000124c:	4b06      	ldr	r3, [pc, #24]	; (60001268 <reset_PFD+0x1c>)
6000124e:	f04f 3280 	mov.w	r2, #2155905152	; 0x80808080
60001252:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	CCM_ANALOG_PFD_528 = 0x2018101B; // PFD0:352, PFD1:594, PFD2:396, PFD3:297 MHz 	
60001256:	4905      	ldr	r1, [pc, #20]	; (6000126c <reset_PFD+0x20>)
60001258:	f8c3 1100 	str.w	r1, [r3, #256]	; 0x100
	//PLL3:
	CCM_ANALOG_PFD_480_SET = (1 << 31) | (1 << 23) | (1 << 15) | (1 << 7);	
6000125c:	f8c3 20f4 	str.w	r2, [r3, #244]	; 0xf4
	CCM_ANALOG_PFD_480 = 0x13110D0C; // PFD0:720, PFD1:664, PFD2:508, PFD3:454 MHz
60001260:	4a03      	ldr	r2, [pc, #12]	; (60001270 <reset_PFD+0x24>)
60001262:	f8c3 20f0 	str.w	r2, [r3, #240]	; 0xf0
60001266:	4770      	bx	lr
60001268:	400d8000 	.word	0x400d8000
6000126c:	2018101b 	.word	0x2018101b
60001270:	13110d0c 	.word	0x13110d0c

60001274 <configure_cache>:
#define SIZE_2G		(SCB_MPU_RASR_SIZE(30) | SCB_MPU_RASR_ENABLE)
#define SIZE_4G		(SCB_MPU_RASR_SIZE(31) | SCB_MPU_RASR_ENABLE)
#define REGION(n)	(SCB_MPU_RBAR_REGION(n) | SCB_MPU_RBAR_VALID)

FLASHMEM void configure_cache(void)
{
60001274:	b410      	push	{r4}
	//printf("MPU_TYPE = %08lX\n", SCB_MPU_TYPE);
	//printf("CCR = %08lX\n", SCB_CCR);

	// TODO: check if caches already active - skip?

	SCB_MPU_CTRL = 0; // turn off MPU
60001276:	4c24      	ldr	r4, [pc, #144]	; (60001308 <configure_cache+0x94>)
60001278:	2000      	movs	r0, #0
6000127a:	6020      	str	r0, [r4, #0]

	uint32_t i = 0;
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); //https://developer.arm.com/docs/146793866/10/why-does-the-cortex-m7-initiate-axim-read-accesses-to-memory-addresses-that-do-not-fall-under-a-defined-mpu-region
6000127c:	4a23      	ldr	r2, [pc, #140]	; (6000130c <configure_cache+0x98>)
6000127e:	2310      	movs	r3, #16
60001280:	6013      	str	r3, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_4G;
60001282:	4b23      	ldr	r3, [pc, #140]	; (60001310 <configure_cache+0x9c>)
60001284:	4923      	ldr	r1, [pc, #140]	; (60001314 <configure_cache+0xa0>)
60001286:	6019      	str	r1, [r3, #0]
	
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // ITCM
60001288:	2111      	movs	r1, #17
6000128a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | SIZE_512K;
6000128c:	4922      	ldr	r1, [pc, #136]	; (60001318 <configure_cache+0xa4>)
6000128e:	6019      	str	r1, [r3, #0]

	// TODO: trap regions should be created last, because the hardware gives
	//  priority to the higher number ones.
	SCB_MPU_RBAR = 0x00000000 | REGION(i++); // trap NULL pointer deref
60001290:	2112      	movs	r1, #18
60001292:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR =  DEV_NOCACHE | NOACCESS | SIZE_32B;
60001294:	4921      	ldr	r1, [pc, #132]	; (6000131c <configure_cache+0xa8>)
60001296:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x00200000 | REGION(i++); // Boot ROM
60001298:	4921      	ldr	r1, [pc, #132]	; (60001320 <configure_cache+0xac>)
6000129a:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WT | READONLY | SIZE_128K;
6000129c:	4921      	ldr	r1, [pc, #132]	; (60001324 <configure_cache+0xb0>)
6000129e:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x20000000 | REGION(i++); // DTCM
600012a0:	4921      	ldr	r1, [pc, #132]	; (60001328 <configure_cache+0xb4>)
600012a2:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_NOCACHE | READWRITE | NOEXEC | SIZE_512K;
600012a4:	4921      	ldr	r1, [pc, #132]	; (6000132c <configure_cache+0xb8>)
600012a6:	6019      	str	r1, [r3, #0]
	
	SCB_MPU_RBAR = ((uint32_t)&_ebss) | REGION(i++); // trap stack overflow
600012a8:	4921      	ldr	r1, [pc, #132]	; (60001330 <configure_cache+0xbc>)
600012aa:	f041 0115 	orr.w	r1, r1, #21
600012ae:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = SCB_MPU_RASR_TEX(0) | NOACCESS | NOEXEC | SIZE_32B;
600012b0:	4920      	ldr	r1, [pc, #128]	; (60001334 <configure_cache+0xc0>)
600012b2:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x20200000 | REGION(i++); // RAM (AXI bus)
600012b4:	f101 5181 	add.w	r1, r1, #270532608	; 0x10200000
600012b8:	310d      	adds	r1, #13
600012ba:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_1M;
600012bc:	491e      	ldr	r1, [pc, #120]	; (60001338 <configure_cache+0xc4>)
600012be:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x40000000 | REGION(i++); // Peripherals
600012c0:	491e      	ldr	r1, [pc, #120]	; (6000133c <configure_cache+0xc8>)
600012c2:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = DEV_NOCACHE | READWRITE | NOEXEC | SIZE_64M;
600012c4:	491e      	ldr	r1, [pc, #120]	; (60001340 <configure_cache+0xcc>)
600012c6:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x60000000 | REGION(i++); // QSPI Flash
600012c8:	491e      	ldr	r1, [pc, #120]	; (60001344 <configure_cache+0xd0>)
600012ca:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | SIZE_16M;
600012cc:	491e      	ldr	r1, [pc, #120]	; (60001348 <configure_cache+0xd4>)
600012ce:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600012d0:	491e      	ldr	r1, [pc, #120]	; (6000134c <configure_cache+0xd8>)
600012d2:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READONLY | NOEXEC | SIZE_256M;
600012d4:	491e      	ldr	r1, [pc, #120]	; (60001350 <configure_cache+0xdc>)
600012d6:	6019      	str	r1, [r3, #0]

	SCB_MPU_RBAR = 0x70000000 | REGION(i++); // FlexSPI2
600012d8:	491e      	ldr	r1, [pc, #120]	; (60001354 <configure_cache+0xe0>)
600012da:	6011      	str	r1, [r2, #0]
	SCB_MPU_RASR = MEM_CACHE_WBWA | READWRITE | NOEXEC | SIZE_16M;
600012dc:	4a1e      	ldr	r2, [pc, #120]	; (60001358 <configure_cache+0xe4>)
600012de:	601a      	str	r2, [r3, #0]

	// TODO: protect access to power supply config

	SCB_MPU_CTRL = SCB_MPU_CTRL_ENABLE;
600012e0:	2301      	movs	r3, #1
600012e2:	6023      	str	r3, [r4, #0]

	// cache enable, ARM DDI0403E, pg 628
	asm("dsb");
600012e4:	f3bf 8f4f 	dsb	sy
	asm("isb");
600012e8:	f3bf 8f6f 	isb	sy
	SCB_CACHE_ICIALLU = 0;
600012ec:	4b1b      	ldr	r3, [pc, #108]	; (6000135c <configure_cache+0xe8>)
600012ee:	6018      	str	r0, [r3, #0]

	asm("dsb");
600012f0:	f3bf 8f4f 	dsb	sy
	asm("isb");
600012f4:	f3bf 8f6f 	isb	sy
	SCB_CCR |= (SCB_CCR_IC | SCB_CCR_DC);
600012f8:	4a19      	ldr	r2, [pc, #100]	; (60001360 <configure_cache+0xec>)
600012fa:	6813      	ldr	r3, [r2, #0]
600012fc:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
60001300:	6013      	str	r3, [r2, #0]
}
60001302:	f85d 4b04 	ldr.w	r4, [sp], #4
60001306:	4770      	bx	lr
60001308:	e000ed94 	.word	0xe000ed94
6000130c:	e000ed9c 	.word	0xe000ed9c
60001310:	e000eda0 	.word	0xe000eda0
60001314:	1000003f 	.word	0x1000003f
60001318:	03080025 	.word	0x03080025
6000131c:	00100009 	.word	0x00100009
60001320:	00200013 	.word	0x00200013
60001324:	07020021 	.word	0x07020021
60001328:	20000014 	.word	0x20000014
6000132c:	13080025 	.word	0x13080025
60001330:	200032c0 	.word	0x200032c0
60001334:	10000009 	.word	0x10000009
60001338:	130b0027 	.word	0x130b0027
6000133c:	40000017 	.word	0x40000017
60001340:	13100033 	.word	0x13100033
60001344:	60000018 	.word	0x60000018
60001348:	070b002f 	.word	0x070b002f
6000134c:	70000019 	.word	0x70000019
60001350:	170b0037 	.word	0x170b0037
60001354:	7000001a 	.word	0x7000001a
60001358:	130b002f 	.word	0x130b002f
6000135c:	e000ef50 	.word	0xe000ef50
60001360:	e000ed14 	.word	0xe000ed14

60001364 <usb_pll_start>:


FLASHMEM void usb_pll_start()
{
	while (1) {
		uint32_t n = CCM_ANALOG_PLL_USB1; // pg 759
60001364:	4b18      	ldr	r3, [pc, #96]	; (600013c8 <usb_pll_start+0x64>)
60001366:	691b      	ldr	r3, [r3, #16]
		printf("CCM_ANALOG_PLL_USB1=%08lX\n", n);
		if (n & CCM_ANALOG_PLL_USB1_DIV_SELECT) {
60001368:	f013 0f02 	tst.w	r3, #2
6000136c:	d00a      	beq.n	60001384 <usb_pll_start+0x20>
			printf("  ERROR, 528 MHz mode!\n"); // never supposed to use this mode!
			CCM_ANALOG_PLL_USB1_CLR = 0xC000;			// bypass 24 MHz
6000136e:	4b16      	ldr	r3, [pc, #88]	; (600013c8 <usb_pll_start+0x64>)
60001370:	f44f 4240 	mov.w	r2, #49152	; 0xc000
60001374:	619a      	str	r2, [r3, #24]
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_BYPASS;	// bypass
60001376:	f44f 3280 	mov.w	r2, #65536	; 0x10000
6000137a:	615a      	str	r2, [r3, #20]
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_POWER |	// power down
6000137c:	f243 0242 	movw	r2, #12354	; 0x3042
60001380:	619a      	str	r2, [r3, #24]
				CCM_ANALOG_PLL_USB1_DIV_SELECT |		// use 480 MHz
				CCM_ANALOG_PLL_USB1_ENABLE |			// disable
				CCM_ANALOG_PLL_USB1_EN_USB_CLKS;		// disable usb
			continue;
60001382:	e7ef      	b.n	60001364 <usb_pll_start>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_ENABLE)) {
60001384:	f413 5f00 	tst.w	r3, #8192	; 0x2000
60001388:	d104      	bne.n	60001394 <usb_pll_start+0x30>
			printf("  enable PLL\n");
			// TODO: should this be done so early, or later??
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_ENABLE;
6000138a:	f44f 5200 	mov.w	r2, #8192	; 0x2000
6000138e:	4b0e      	ldr	r3, [pc, #56]	; (600013c8 <usb_pll_start+0x64>)
60001390:	615a      	str	r2, [r3, #20]
			continue;
60001392:	e7e7      	b.n	60001364 <usb_pll_start>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_POWER)) {
60001394:	f413 5f80 	tst.w	r3, #4096	; 0x1000
60001398:	d104      	bne.n	600013a4 <usb_pll_start+0x40>
			printf("  power up PLL\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_POWER;
6000139a:	f44f 5280 	mov.w	r2, #4096	; 0x1000
6000139e:	4b0a      	ldr	r3, [pc, #40]	; (600013c8 <usb_pll_start+0x64>)
600013a0:	615a      	str	r2, [r3, #20]
			continue;
600013a2:	e7df      	b.n	60001364 <usb_pll_start>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_LOCK)) {
600013a4:	2b00      	cmp	r3, #0
600013a6:	dadd      	bge.n	60001364 <usb_pll_start>
			printf("  wait for lock\n");
			continue;
		}
		if (n & CCM_ANALOG_PLL_USB1_BYPASS) {
600013a8:	f413 3f80 	tst.w	r3, #65536	; 0x10000
600013ac:	d004      	beq.n	600013b8 <usb_pll_start+0x54>
			printf("  turn off bypass\n");
			CCM_ANALOG_PLL_USB1_CLR = CCM_ANALOG_PLL_USB1_BYPASS;
600013ae:	f44f 3280 	mov.w	r2, #65536	; 0x10000
600013b2:	4b05      	ldr	r3, [pc, #20]	; (600013c8 <usb_pll_start+0x64>)
600013b4:	619a      	str	r2, [r3, #24]
			continue;
600013b6:	e7d5      	b.n	60001364 <usb_pll_start>
		}
		if (!(n & CCM_ANALOG_PLL_USB1_EN_USB_CLKS)) {
600013b8:	f013 0f40 	tst.w	r3, #64	; 0x40
600013bc:	d103      	bne.n	600013c6 <usb_pll_start+0x62>
			printf("  enable USB clocks\n");
			CCM_ANALOG_PLL_USB1_SET = CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
600013be:	2240      	movs	r2, #64	; 0x40
600013c0:	4b01      	ldr	r3, [pc, #4]	; (600013c8 <usb_pll_start+0x64>)
600013c2:	615a      	str	r2, [r3, #20]
			continue;
600013c4:	e7ce      	b.n	60001364 <usb_pll_start>
600013c6:	4770      	bx	lr
600013c8:	400d8000 	.word	0x400d8000

600013cc <tempmon_init>:
  asm volatile ("dsb":::"memory");
  while (1) asm ("wfi");
}

FLASHMEM void tempmon_init(void)
{
600013cc:	b4f0      	push	{r4, r5, r6, r7}
  uint32_t calibrationData;
  uint32_t roomCount;
  uint32_t tempCodeVal;
      
  //first power on the temperature sensor - no register change
  TEMPMON_TEMPSENSE0 &= ~0x1U;
600013ce:	4a3f      	ldr	r2, [pc, #252]	; (600014cc <tempmon_init+0x100>)
600013d0:	6813      	ldr	r3, [r2, #0]
600013d2:	f023 0301 	bic.w	r3, r3, #1
600013d6:	6013      	str	r3, [r2, #0]

  //set monitoring frequency - no register change
  TEMPMON_TEMPSENSE1 = (((uint32_t)(((uint32_t)(frequency)) << 0U)) & 0xFFFFU);
600013d8:	2303      	movs	r3, #3
600013da:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90
  
  //read calibration data - this works
  calibrationData = HW_OCOTP_ANA1;
600013de:	4b3c      	ldr	r3, [pc, #240]	; (600014d0 <tempmon_init+0x104>)
600013e0:	f8d3 00e0 	ldr.w	r0, [r3, #224]	; 0xe0
    s_hotTemp = (uint32_t)(calibrationData & 0xFFU) >> 0x00U;
600013e4:	b2c1      	uxtb	r1, r0
600013e6:	4e3b      	ldr	r6, [pc, #236]	; (600014d4 <tempmon_init+0x108>)
600013e8:	6031      	str	r1, [r6, #0]
    s_hotCount = (uint32_t)(calibrationData & 0xFFF00U) >> 0X08U;
600013ea:	f3c0 230b 	ubfx	r3, r0, #8, #12
600013ee:	4f3a      	ldr	r7, [pc, #232]	; (600014d8 <tempmon_init+0x10c>)
600013f0:	603b      	str	r3, [r7, #0]
    roomCount = (uint32_t)(calibrationData & 0xFFF00000U) >> 0x14U;
    s_hot_ROOM = s_hotTemp - 25.0f;
600013f2:	ee07 1a90 	vmov	s15, r1
600013f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
600013fa:	eef3 6a09 	vmov.f32	s13, #57	; 0x41c80000  25.0
600013fe:	ee77 6ae6 	vsub.f32	s13, s15, s13
60001402:	4c36      	ldr	r4, [pc, #216]	; (600014dc <tempmon_init+0x110>)
60001404:	edc4 6a00 	vstr	s13, [r4]
    s_roomC_hotC = roomCount - s_hotCount;
60001408:	ebc3 5010 	rsb	r0, r3, r0, lsr #20
6000140c:	4d34      	ldr	r5, [pc, #208]	; (600014e0 <tempmon_init+0x114>)
6000140e:	6028      	str	r0, [r5, #0]

    //time to set alarm temperatures
  //Set High Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - highAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
60001410:	3955      	subs	r1, #85	; 0x55
60001412:	fb01 f100 	mul.w	r1, r1, r0
60001416:	ee07 1a90 	vmov	s15, r1
6000141a:	eeb8 7a67 	vcvt.f32.u32	s14, s15
6000141e:	ee87 6a26 	vdiv.f32	s12, s14, s13
60001422:	ee07 3a90 	vmov	s15, r3
60001426:	eef8 7a67 	vcvt.f32.u32	s15, s15
6000142a:	ee77 7a86 	vadd.f32	s15, s15, s12
6000142e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE0 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 20U)) & 0xFFF00000U);
60001432:	6813      	ldr	r3, [r2, #0]
60001434:	ee17 1a90 	vmov	r1, s15
60001438:	ea43 5301 	orr.w	r3, r3, r1, lsl #20
6000143c:	6013      	str	r3, [r2, #0]
  
  //Set Panic Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - panicAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000143e:	edd7 7a00 	vldr	s15, [r7]
60001442:	eef8 7a67 	vcvt.f32.u32	s15, s15
60001446:	6833      	ldr	r3, [r6, #0]
60001448:	f1a3 015a 	sub.w	r1, r3, #90	; 0x5a
6000144c:	682d      	ldr	r5, [r5, #0]
6000144e:	fb05 f101 	mul.w	r1, r5, r1
60001452:	ed94 6a00 	vldr	s12, [r4]
60001456:	ee07 1a10 	vmov	s14, r1
6000145a:	eef8 6a47 	vcvt.f32.u32	s13, s14
6000145e:	ee86 7a86 	vdiv.f32	s14, s13, s12
60001462:	ee37 7a87 	vadd.f32	s14, s15, s14
60001466:	eebc 7ac7 	vcvt.u32.f32	s14, s14
6000146a:	ee17 1a10 	vmov	r1, s14
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 16U)) & 0xFFF0000U);
6000146e:	f8d2 4110 	ldr.w	r4, [r2, #272]	; 0x110
60001472:	481c      	ldr	r0, [pc, #112]	; (600014e4 <tempmon_init+0x118>)
60001474:	ea00 4101 	and.w	r1, r0, r1, lsl #16
60001478:	4321      	orrs	r1, r4
6000147a:	f8c2 1110 	str.w	r1, [r2, #272]	; 0x110
  
  // Set Low Temp Alarm Temp
  tempCodeVal = (uint32_t)(s_hotCount + (s_hotTemp - lowAlarmTemp) * s_roomC_hotC / s_hot_ROOM);
6000147e:	3b19      	subs	r3, #25
60001480:	fb03 f305 	mul.w	r3, r3, r5
60001484:	ee07 3a10 	vmov	s14, r3
60001488:	eeb8 7a47 	vcvt.f32.u32	s14, s14
6000148c:	eec7 6a06 	vdiv.f32	s13, s14, s12
60001490:	ee77 7aa6 	vadd.f32	s15, s15, s13
60001494:	eefc 7ae7 	vcvt.u32.f32	s15, s15
    TEMPMON_TEMPSENSE2 |= (((uint32_t)(((uint32_t)(tempCodeVal)) << 0U)) & 0xFFFU);
60001498:	f8d2 1110 	ldr.w	r1, [r2, #272]	; 0x110
6000149c:	ee17 3a90 	vmov	r3, s15
600014a0:	f3c3 030b 	ubfx	r3, r3, #0, #12
600014a4:	430b      	orrs	r3, r1
600014a6:	f8c2 3110 	str.w	r3, [r2, #272]	; 0x110
  
  //Start temp monitoring
  TEMPMON_TEMPSENSE0 |= 0x2U;   //starts temp monitoring
600014aa:	6813      	ldr	r3, [r2, #0]
600014ac:	f043 0302 	orr.w	r3, r3, #2
600014b0:	6013      	str	r3, [r2, #0]

  //PANIC shutdown:
  NVIC_SET_PRIORITY(IRQ_TEMPERATURE_PANIC, 0);
600014b2:	2200      	movs	r2, #0
600014b4:	4b0c      	ldr	r3, [pc, #48]	; (600014e8 <tempmon_init+0x11c>)
600014b6:	701a      	strb	r2, [r3, #0]
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
#else
extern void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(enum IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
600014b8:	4a0c      	ldr	r2, [pc, #48]	; (600014ec <tempmon_init+0x120>)
600014ba:	4b0d      	ldr	r3, [pc, #52]	; (600014f0 <tempmon_init+0x124>)
600014bc:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
  attachInterruptVector(IRQ_TEMPERATURE_PANIC, &Panic_Temp_isr);
  NVIC_ENABLE_IRQ(IRQ_TEMPERATURE_PANIC);
600014c0:	2201      	movs	r2, #1
600014c2:	4b0c      	ldr	r3, [pc, #48]	; (600014f4 <tempmon_init+0x128>)
600014c4:	601a      	str	r2, [r3, #0]
}
600014c6:	bcf0      	pop	{r4, r5, r6, r7}
600014c8:	4770      	bx	lr
600014ca:	bf00      	nop
600014cc:	400d8180 	.word	0x400d8180
600014d0:	401f4400 	.word	0x401f4400
600014d4:	200013d8 	.word	0x200013d8
600014d8:	200013e4 	.word	0x200013e4
600014dc:	200013dc 	.word	0x200013dc
600014e0:	200013e0 	.word	0x200013e0
600014e4:	0fff0000 	.word	0x0fff0000
600014e8:	e000e440 	.word	0xe000e440
600014ec:	00002bc9 	.word	0x00002bc9
600014f0:	20001800 	.word	0x20001800
600014f4:	e000e108 	.word	0xe000e108

600014f8 <usb_init>:

static void run_callbacks(endpoint_t *ep);


FLASHMEM void usb_init(void)
{
600014f8:	b538      	push	{r3, r4, r5, lr}
	// TODO: only enable when VBUS detected
	// TODO: return to low power mode when VBUS removed
	// TODO: protect PMU access with MPU
	PMU_REG_3P0 = PMU_REG_3P0_OUTPUT_TRG(0x0F) | PMU_REG_3P0_BO_OFFSET(6)
600014fa:	f640 7261 	movw	r2, #3937	; 0xf61
600014fe:	4b30      	ldr	r3, [pc, #192]	; (600015c0 <usb_init+0xc8>)
60001500:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
		| PMU_REG_3P0_ENABLE_LINREG;

	usb_init_serialnumber();
60001504:	f000 f9dc 	bl	600018c0 <__usb_init_serialnumber_veneer>

	// assume PLL3 is already running - already done by usb_pll_start() in main.c

	CCM_CCGR6 |= CCM_CCGR6_USBOH3(CCM_CCGR_ON); // turn on clocks to USB peripheral
60001508:	4a2e      	ldr	r2, [pc, #184]	; (600015c4 <usb_init+0xcc>)
6000150a:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
6000150e:	f043 0303 	orr.w	r3, r3, #3
60001512:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	
	printf("BURSTSIZE=%08lX\n", USB1_BURSTSIZE);
	//USB1_BURSTSIZE = USB_BURSTSIZE_TXPBURST(4) | USB_BURSTSIZE_RXPBURST(4);
	USB1_BURSTSIZE = 0x0404;
60001516:	f240 4204 	movw	r2, #1028	; 0x404
6000151a:	4b2b      	ldr	r3, [pc, #172]	; (600015c8 <usb_init+0xd0>)
6000151c:	f8c3 2160 	str.w	r2, [r3, #352]	; 0x160
	//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);

	// turn on PLL3, wait for 480 MHz lock?
	// turn on CCM clock gates?  CCGR6[CG0]
#if 1
	if ((USBPHY1_PWD & (USBPHY_PWD_RXPWDRX | USBPHY_PWD_RXPWDDIFF | USBPHY_PWD_RXPWD1PT1
60001520:	4b2a      	ldr	r3, [pc, #168]	; (600015cc <usb_init+0xd4>)
60001522:	681a      	ldr	r2, [r3, #0]
60001524:	4b2a      	ldr	r3, [pc, #168]	; (600015d0 <usb_init+0xd8>)
60001526:	421a      	tst	r2, r3
60001528:	d105      	bne.n	60001536 <usb_init+0x3e>
	  | USBPHY_PWD_RXPWDENV | USBPHY_PWD_TXPWDV2I | USBPHY_PWD_TXPWDIBIAS
	  | USBPHY_PWD_TXPWDFS)) || (USB1_USBMODE & USB_USBMODE_CM_MASK)) {
6000152a:	4b27      	ldr	r3, [pc, #156]	; (600015c8 <usb_init+0xd0>)
6000152c:	f8d3 31a8 	ldr.w	r3, [r3, #424]	; 0x1a8
60001530:	f013 0f03 	tst.w	r3, #3
60001534:	d01b      	beq.n	6000156e <usb_init+0x76>
		// USB controller is turned on from previous use
		// reset needed to turn it off & start from clean slate
		USBPHY1_CTRL_SET = USBPHY_CTRL_SFTRST; // USBPHY1_CTRL page 3292
60001536:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
6000153a:	4b24      	ldr	r3, [pc, #144]	; (600015cc <usb_init+0xd4>)
6000153c:	635a      	str	r2, [r3, #52]	; 0x34
		USB1_USBCMD |= USB_USBCMD_RST; // reset controller
6000153e:	4a22      	ldr	r2, [pc, #136]	; (600015c8 <usb_init+0xd0>)
60001540:	f8d2 3140 	ldr.w	r3, [r2, #320]	; 0x140
60001544:	f043 0302 	orr.w	r3, r3, #2
60001548:	f8c2 3140 	str.w	r3, [r2, #320]	; 0x140
		int count=0;
		while (USB1_USBCMD & USB_USBCMD_RST) count++;
6000154c:	4b1e      	ldr	r3, [pc, #120]	; (600015c8 <usb_init+0xd0>)
6000154e:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
60001552:	f013 0f02 	tst.w	r3, #2
60001556:	d1f9      	bne.n	6000154c <usb_init+0x54>
		NVIC_CLEAR_PENDING(IRQ_USB1);
60001558:	f44f 3200 	mov.w	r2, #131072	; 0x20000
6000155c:	4b1d      	ldr	r3, [pc, #116]	; (600015d4 <usb_init+0xdc>)
6000155e:	601a      	str	r2, [r3, #0]
		USBPHY1_CTRL_CLR = USBPHY_CTRL_SFTRST; // reset PHY
60001560:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
60001564:	4b19      	ldr	r3, [pc, #100]	; (600015cc <usb_init+0xd4>)
60001566:	639a      	str	r2, [r3, #56]	; 0x38
		//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
		//printf("USBPHY1_TX=%08lX\n", USBPHY1_TX);
		//printf("USBPHY1_RX=%08lX\n", USBPHY1_RX);
		//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);
		//printf("USB1_USBMODE=%08lX\n", USB1_USBMODE);
		delay(25);
60001568:	2019      	movs	r0, #25
6000156a:	f000 f9a5 	bl	600018b8 <__delay_veneer>
	// ENDPTFLUSH	pg 3247
	// ENDPTSTAT	pg 3247
	// ENDPTCOMPLETE   3248
	// ENDPTCTRL0	pg 3249

	USBPHY1_CTRL_CLR = USBPHY_CTRL_CLKGATE;
6000156e:	4b17      	ldr	r3, [pc, #92]	; (600015cc <usb_init+0xd4>)
60001570:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
60001574:	639a      	str	r2, [r3, #56]	; 0x38
	USBPHY1_PWD = 0;
60001576:	2100      	movs	r1, #0
60001578:	6019      	str	r1, [r3, #0]
	//printf("USBPHY1_PWD=%08lX\n", USBPHY1_PWD);
	//printf("USBPHY1_CTRL=%08lX\n", USBPHY1_CTRL);

	USB1_USBMODE = USB_USBMODE_CM(2) | USB_USBMODE_SLOM;
6000157a:	4c13      	ldr	r4, [pc, #76]	; (600015c8 <usb_init+0xd0>)
6000157c:	230a      	movs	r3, #10
6000157e:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
	memset(endpoint_queue_head, 0, sizeof(endpoint_queue_head));
60001582:	4d15      	ldr	r5, [pc, #84]	; (600015d8 <usb_init+0xe0>)
60001584:	f44f 7220 	mov.w	r2, #640	; 0x280
60001588:	4628      	mov	r0, r5
6000158a:	f000 f97d 	bl	60001888 <__memset_veneer>
	endpoint_queue_head[0].config = (64 << 16) | (1 << 15);
6000158e:	f44f 0381 	mov.w	r3, #4227072	; 0x408000
60001592:	602b      	str	r3, [r5, #0]
	endpoint_queue_head[1].config = (64 << 16);
60001594:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
60001598:	642b      	str	r3, [r5, #64]	; 0x40
	USB1_ENDPOINTLISTADDR = (uint32_t)&endpoint_queue_head;
6000159a:	f8c4 5158 	str.w	r5, [r4, #344]	; 0x158
	//  Recommended: enable all device interrupts including: USBINT, USBERRINT,
	// Port Change Detect, USB Reset Received, DCSuspend.
	USB1_USBINTR = USB_USBINTR_UE | USB_USBINTR_UEE | /* USB_USBINTR_PCE | */
6000159e:	f240 1343 	movw	r3, #323	; 0x143
600015a2:	f8c4 3148 	str.w	r3, [r4, #328]	; 0x148
600015a6:	4a0d      	ldr	r2, [pc, #52]	; (600015dc <usb_init+0xe4>)
600015a8:	4b0d      	ldr	r3, [pc, #52]	; (600015e0 <usb_init+0xe8>)
600015aa:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
		USB_USBINTR_URE | USB_USBINTR_SLE;
	//_VectorsRam[IRQ_USB1+16] = &isr;
	attachInterruptVector(IRQ_USB1, &isr);
	NVIC_ENABLE_IRQ(IRQ_USB1);
600015ae:	f44f 3200 	mov.w	r2, #131072	; 0x20000
600015b2:	4b0c      	ldr	r3, [pc, #48]	; (600015e4 <usb_init+0xec>)
600015b4:	601a      	str	r2, [r3, #0]
	//printf("USB1_ENDPTCTRL0=%08lX\n", USB1_ENDPTCTRL0);
	//printf("USB1_ENDPTCTRL1=%08lX\n", USB1_ENDPTCTRL1);
	//printf("USB1_ENDPTCTRL2=%08lX\n", USB1_ENDPTCTRL2);
	//printf("USB1_ENDPTCTRL3=%08lX\n", USB1_ENDPTCTRL3);
	USB1_USBCMD = USB_USBCMD_RS;
600015b6:	2301      	movs	r3, #1
600015b8:	f8c4 3140 	str.w	r3, [r4, #320]	; 0x140
600015bc:	bd38      	pop	{r3, r4, r5, pc}
600015be:	bf00      	nop
600015c0:	400d8000 	.word	0x400d8000
600015c4:	400fc000 	.word	0x400fc000
600015c8:	402e0000 	.word	0x402e0000
600015cc:	400d9000 	.word	0x400d9000
600015d0:	001e1c00 	.word	0x001e1c00
600015d4:	e000e28c 	.word	0xe000e28c
600015d8:	20003000 	.word	0x20003000
600015dc:	00003191 	.word	0x00003191
600015e0:	20001800 	.word	0x20001800
600015e4:	e000e10c 	.word	0xe000e10c

600015e8 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)>:


// Set up the pool of audio data blocks
// placing them all onto the free list
FLASHMEM void AudioStream::initialize_memory(audio_block_t *data, unsigned int num)
{
600015e8:	b470      	push	{r4, r5, r6}
	unsigned int i;
	unsigned int maxnum = MAX_AUDIO_MEMORY / AUDIO_BLOCK_SAMPLES / 2;

	//Serial.println("AudioStream initialize_memory");
	//delay(10);
	if (num > maxnum) num = maxnum;
600015ea:	f5b1 7f60 	cmp.w	r1, #896	; 0x380
600015ee:	d901      	bls.n	600015f4 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0xc>
600015f0:	f44f 7160 	mov.w	r1, #896	; 0x380
	__disable_irq();
600015f4:	b672      	cpsid	i
	memory_pool = data;
600015f6:	4b15      	ldr	r3, [pc, #84]	; (6000164c <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x64>)
600015f8:	6018      	str	r0, [r3, #0]
	memory_pool_first_mask = 0;
600015fa:	2300      	movs	r3, #0
600015fc:	4a14      	ldr	r2, [pc, #80]	; (60001650 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x68>)
600015fe:	8013      	strh	r3, [r2, #0]
	for (i=0; i < NUM_MASKS; i++) {
60001600:	2b1b      	cmp	r3, #27
60001602:	d805      	bhi.n	60001610 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x28>
		memory_pool_available_mask[i] = 0;
60001604:	2400      	movs	r4, #0
60001606:	4a13      	ldr	r2, [pc, #76]	; (60001654 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x6c>)
60001608:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
	//delay(10);
	if (num > maxnum) num = maxnum;
	__disable_irq();
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
6000160c:	3301      	adds	r3, #1
6000160e:	e7f7      	b.n	60001600 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x18>
60001610:	2200      	movs	r2, #0
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
60001612:	4291      	cmp	r1, r2
60001614:	d90c      	bls.n	60001630 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x48>
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
60001616:	0955      	lsrs	r5, r2, #5
60001618:	f002 041f 	and.w	r4, r2, #31
6000161c:	2301      	movs	r3, #1
6000161e:	40a3      	lsls	r3, r4
60001620:	4c0c      	ldr	r4, [pc, #48]	; (60001654 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x6c>)
60001622:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
60001626:	4333      	orrs	r3, r6
60001628:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
	memory_pool = data;
	memory_pool_first_mask = 0;
	for (i=0; i < NUM_MASKS; i++) {
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
6000162c:	3201      	adds	r2, #1
6000162e:	e7f0      	b.n	60001612 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x2a>
60001630:	2300      	movs	r3, #0
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
60001632:	4299      	cmp	r1, r3
60001634:	d906      	bls.n	60001644 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x5c>
		data[i].memory_pool_index = i;
60001636:	eb03 1483 	add.w	r4, r3, r3, lsl #6
6000163a:	00a2      	lsls	r2, r4, #2
6000163c:	4402      	add	r2, r0
6000163e:	8053      	strh	r3, [r2, #2]
		memory_pool_available_mask[i] = 0;
	}
	for (i=0; i < num; i++) {
		memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
	}
	for (i=0; i < num; i++) {
60001640:	3301      	adds	r3, #1
60001642:	e7f6      	b.n	60001632 <AudioStream::initialize_memory(audio_block_struct*, unsigned int)+0x4a>
		data[i].memory_pool_index = i;
	}
	__enable_irq();
60001644:	b662      	cpsie	i

}
60001646:	bc70      	pop	{r4, r5, r6}
60001648:	4770      	bx	lr
6000164a:	bf00      	nop
6000164c:	20001670 	.word	0x20001670
60001650:	20001676 	.word	0x20001676
60001654:	20001600 	.word	0x20001600

60001658 <analog_init>:
{
	uint32_t mode, avg=0;

	printf("analogInit\n");

	CCM_CCGR1 |= CCM_CCGR1_ADC1(CCM_CCGR_ON);
60001658:	4b14      	ldr	r3, [pc, #80]	; (600016ac <analog_init+0x54>)
6000165a:	6eda      	ldr	r2, [r3, #108]	; 0x6c
6000165c:	f442 3240 	orr.w	r2, r2, #196608	; 0x30000
60001660:	66da      	str	r2, [r3, #108]	; 0x6c
	CCM_CCGR1 |= CCM_CCGR1_ADC2(CCM_CCGR_ON);
60001662:	6eda      	ldr	r2, [r3, #108]	; 0x6c
60001664:	f442 7240 	orr.w	r2, r2, #768	; 0x300
60001668:	66da      	str	r2, [r3, #108]	; 0x6c
	} else {
		mode |= ADC_CFG_ADIV(0) | ADC_CFG_ADICLK(0); // use IPG
	}
#endif
	//ADC1
	ADC1_CFG = mode | ADC_CFG_ADHSC;
6000166a:	f5a3 3360 	sub.w	r3, r3, #229376	; 0x38000
6000166e:	f240 6237 	movw	r2, #1591	; 0x637
60001672:	645a      	str	r2, [r3, #68]	; 0x44
	ADC1_GC = avg | ADC_GC_CAL;		// begin cal
60001674:	22a0      	movs	r2, #160	; 0xa0
60001676:	649a      	str	r2, [r3, #72]	; 0x48
	calibrating = 1;
60001678:	2201      	movs	r2, #1
6000167a:	4b0d      	ldr	r3, [pc, #52]	; (600016b0 <analog_init+0x58>)
6000167c:	701a      	strb	r2, [r3, #0]
	while (ADC1_GC & ADC_GC_CAL) ;
6000167e:	4b0d      	ldr	r3, [pc, #52]	; (600016b4 <analog_init+0x5c>)
60001680:	6c9b      	ldr	r3, [r3, #72]	; 0x48
60001682:	f013 0f80 	tst.w	r3, #128	; 0x80
60001686:	d1fa      	bne.n	6000167e <analog_init+0x26>
	calibrating = 0;
	//ADC2
	ADC2_CFG = mode | ADC_CFG_ADHSC;
60001688:	4b0b      	ldr	r3, [pc, #44]	; (600016b8 <analog_init+0x60>)
6000168a:	f240 6237 	movw	r2, #1591	; 0x637
6000168e:	645a      	str	r2, [r3, #68]	; 0x44
	ADC2_GC = avg | ADC_GC_CAL;		// begin cal
60001690:	22a0      	movs	r2, #160	; 0xa0
60001692:	649a      	str	r2, [r3, #72]	; 0x48
	calibrating = 1;
60001694:	2201      	movs	r2, #1
60001696:	4b06      	ldr	r3, [pc, #24]	; (600016b0 <analog_init+0x58>)
60001698:	701a      	strb	r2, [r3, #0]
	while (ADC2_GC & ADC_GC_CAL) ;
6000169a:	4b07      	ldr	r3, [pc, #28]	; (600016b8 <analog_init+0x60>)
6000169c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
6000169e:	f013 0f80 	tst.w	r3, #128	; 0x80
600016a2:	d1fa      	bne.n	6000169a <analog_init+0x42>
	calibrating = 0;
600016a4:	2200      	movs	r2, #0
600016a6:	4b02      	ldr	r3, [pc, #8]	; (600016b0 <analog_init+0x58>)
600016a8:	701a      	strb	r2, [r3, #0]
600016aa:	4770      	bx	lr
600016ac:	400fc000 	.word	0x400fc000
600016b0:	20001692 	.word	0x20001692
600016b4:	400c4000 	.word	0x400c4000
600016b8:	400c8000 	.word	0x400c8000

600016bc <TwoWire::i2c4_hardware>:
600016bc:	400fc080 03000000 00000019 00000010     ...@............
600016cc:	401f84e8 00000001 000000ff 000000ff     ...@............
	...
600016e4:	00000018 00000010 401f84e4 00000001     ...........@....
600016f4:	000000ff 000000ff 00000000 00000000     ................
60001704:	0000001f                                ....

60001708 <TwoWire::i2c3_hardware>:
60001708:	400fc070 00000c00 00000011 00000011     p..@............
60001718:	401f84e0 00000002 00000024 00000012     ...@....$.......
60001728:	401f84e0 00000001 00000010 00000011     ...@............
60001738:	401f84dc 00000002 00000025 00000012     ...@....%.......
60001748:	401f84dc 00000001 0000001e              ...@........

60001754 <TwoWire::i2c1_hardware>:
60001754:	400fc070 000000c0 00000012 00000013     p..@............
60001764:	401f84d0 00000001 000000ff 000000ff     ...@............
	...
6000177c:	00000013 00000013 401f84cc 00000001     ...........@....
6000178c:	000000ff 000000ff 00000000 00000000     ................
6000179c:	0000001c                                ....

600017a0 <usb_string_product_name_default>:
600017a0:	00550316 00420053 00530020 00720065     ..U.S.B. .S.e.r.
600017b0:	00610069 0000006c                       i.a.l...

600017b8 <usb_string_manufacturer_name_default>:
600017b8:	00540318 00650065 0073006e 00640079     ..T.e.e.n.s.y.d.
600017c8:	00690075 006f006e                       u.i.n.o.

600017d0 <string0>:
600017d0:	04090304                                ....

600017d4 <usb_config_descriptor_12>:
600017d4:	00430209 c0000102 00040932 02020100     ..C.....2.......
600017e4:	24050001 05011000 01010124 06022404     ...$....$....$..
600017f4:	00062405 82050701 10001003 00010409     .$..............
60001804:	00000a02 03050700 00004002 02840507     .........@......
60001814:	00000040                                @...

60001818 <usb_config_descriptor_480>:
60001818:	00430209 c0000102 00040932 02020100     ..C.....2.......
60001828:	24050001 05011000 01010124 06022404     ...$....$....$..
60001838:	00062405 82050701 05001003 00010409     .$..............
60001848:	00000a02 03050700 00020002 02840507     ................
60001858:	00000200                                ....

6000185c <qualifier_descriptor>:
6000185c:	0200060a 40000002 ff010001                       .......@..

60001866 <_serialEvent_default>:
60001866:	b5f8ff01                                         ..

60001868 <_init>:
60001868:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
6000186a:	bf00      	nop
6000186c:	bcf8      	pop	{r3, r4, r5, r6, r7}
6000186e:	bc08      	pop	{r3}
60001870:	469e      	mov	lr, r3
60001872:	4770      	bx	lr
60001874:	ffff ffff 			; <UNDEFINED> instruction: 0xffffffff

60001878 <__configure_systick_veneer>:
60001878:	f85f f000 	ldr.w	pc, [pc]	; 6000187c <__configure_systick_veneer+0x4>
6000187c:	00002a79 	.word	0x00002a79

60001880 <__main_veneer>:
60001880:	f85f f000 	ldr.w	pc, [pc]	; 60001884 <__main_veneer+0x4>
60001884:	00003e8d 	.word	0x00003e8d

60001888 <__memset_veneer>:
60001888:	f85f f000 	ldr.w	pc, [pc]	; 6000188c <__memset_veneer+0x4>
6000188c:	0000461d 	.word	0x0000461d

60001890 <__startup_early_hook_veneer>:
60001890:	f85f f000 	ldr.w	pc, [pc]	; 60001894 <__startup_early_hook_veneer+0x4>
60001894:	00002af9 	.word	0x00002af9

60001898 <__pwm_init_veneer>:
60001898:	f85f f000 	ldr.w	pc, [pc]	; 6000189c <__pwm_init_veneer+0x4>
6000189c:	00002a11 	.word	0x00002a11

600018a0 <____libc_init_array_veneer>:
600018a0:	f85f f000 	ldr.w	pc, [pc]	; 600018a4 <____libc_init_array_veneer+0x4>
600018a4:	0000404d 	.word	0x0000404d

600018a8 <__set_arm_clock_veneer>:
600018a8:	f85f f000 	ldr.w	pc, [pc]	; 600018ac <__set_arm_clock_veneer+0x4>
600018ac:	0000260d 	.word	0x0000260d

600018b0 <__startup_late_hook_veneer>:
600018b0:	f85f f000 	ldr.w	pc, [pc]	; 600018b4 <__startup_late_hook_veneer+0x4>
600018b4:	00002afd 	.word	0x00002afd

600018b8 <__delay_veneer>:
600018b8:	f85f f000 	ldr.w	pc, [pc]	; 600018bc <__delay_veneer+0x4>
600018bc:	000028ed 	.word	0x000028ed

600018c0 <__usb_init_serialnumber_veneer>:
600018c0:	f85f f000 	ldr.w	pc, [pc]	; 600018c4 <__usb_init_serialnumber_veneer+0x4>
600018c4:	00003439 	.word	0x00003439

600018c8 <__init_array_start>:
600018c8:	00000045 	.word	0x00000045
600018cc:	00000235 	.word	0x00000235
600018d0:	00000371 	.word	0x00000371
600018d4:	000005dd 	.word	0x000005dd
600018d8:	00000615 	.word	0x00000615
600018dc:	0000064d 	.word	0x0000064d
600018e0:	00000685 	.word	0x00000685
600018e4:	000006bd 	.word	0x000006bd
600018e8:	000006f5 	.word	0x000006f5
600018ec:	0000072d 	.word	0x0000072d
600018f0:	00000765 	.word	0x00000765
600018f4:	0000079d 	.word	0x0000079d
600018f8:	000007d5 	.word	0x000007d5
600018fc:	0000080d 	.word	0x0000080d
60001900:	00000845 	.word	0x00000845
60001904:	0000087d 	.word	0x0000087d
60001908:	000008b5 	.word	0x000008b5
6000190c:	000008ed 	.word	0x000008ed
60001910:	00000925 	.word	0x00000925
60001914:	0000095d 	.word	0x0000095d
60001918:	00000995 	.word	0x00000995
6000191c:	000009cd 	.word	0x000009cd
60001920:	00000a05 	.word	0x00000a05
60001924:	00000a3d 	.word	0x00000a3d
60001928:	00000a75 	.word	0x00000a75
6000192c:	00000bf1 	.word	0x00000bf1
60001930:	00001345 	.word	0x00001345
60001934:	00001d09 	.word	0x00001d09
60001938:	00001f81 	.word	0x00001f81

6000193c <__init_array_end>:
6000193c:	ffffffff 	.word	0xffffffff

Disassembly of section .text.itcm:

00000000 <_stext>:
	...

00000020 <__do_global_dtors_aux>:
void usb_config_tx_iso(uint32_t ep, uint32_t packet_size, int mult, void (*cb)(transfer_t *))
{
	if (mult < 1 || mult > 3) return;
	uint32_t config = (packet_size << 16) | (mult << 30);
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
      20:	4c05b510 	.word	0x4c05b510
      24:	7823      	ldrb	r3, [r4, #0]
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
      26:	b933      	.short	0xb933
      28:	4b04      	ldr	r3, [pc, #16]	; (3c <_teensy_model_identifier+0x18>)
      2a:	b113      	.short	0xb113
      2c:	4804      	ldr	r0, [pc, #16]	; (40 <_teensy_model_identifier+0x1c>)
      2e:	f3af      	.short	0xf3af
      30:	8000      	strh	r0, [r0, #0]
      32:	2301      	.short	0x2301
      34:	7023      	strb	r3, [r4, #0]
      36:	bd10      	.short	0xbd10
      38:	0fa0      	lsrs	r0, r4, #30
      3a:	2000      	.short	0x2000
      3c:	0000      	movs	r0, r0
      3e:	0000      	movs	r0, r0
      40:	4a14      	ldr	r2, [pc, #80]	; (94 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x18>)
	...

00000044 <frame_dummy>:
    nmeas = (TEMPMON_TEMPSENSE0 & 0xFFF00U) >> 8U;
    /* Calculate temperature */
    tmeas = s_hotTemp - (float)((nmeas - s_hotCount) * s_hot_ROOM / s_roomC_hotC);

    return tmeas;
}
      44:	4b08      	ldr	r3, [pc, #32]	; (68 <frame_dummy+0x24>)
      46:	b510      	.short	0xb510
      48:	b11b      	cbz	r3, 52 <frame_dummy+0xe>
      4a:	4908      	.short	0x4908
      4c:	4808      	ldr	r0, [pc, #32]	; (70 <frame_dummy+0x2c>)
      4e:	f3af      	.short	0xf3af
      50:	8000      	strh	r0, [r0, #0]
      52:	4808      	.short	0x4808
      54:	6803      	ldr	r3, [r0, #0]
      56:	b903      	.short	0xb903
      58:	bd10      	pop	{r4, pc}
      5a:	4b07      	ldr	r3, [pc, #28]	; (78 <frame_dummy+0x34>)

  ADC1_CFG = mode;
  ADC2_CFG = mode1;
  
  if(num >= 4){
      ADC1_GC |= ADC_GC_AVGE;// turns on averaging
      5c:	2b00      	cmp	r3, #0
      ADC2_GC |= ADC_GC_AVGE;// turns on averaging
      5e:	d0fb      	beq.n	58 <frame_dummy+0x14>
      60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      64:	bf004718 	.word	0xbf004718
      68:	0000      	movs	r0, r0
      6a:	0000      	movs	r0, r0
      6c:	0fa4      	lsrs	r4, r4, #30
      6e:	2000      	movs	r0, #0
      70:	4a14      	ldr	r2, [pc, #80]	; (c4 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x48>)
      72:	0000      	movs	r0, r0
	if (src.numConnections == 0) {
		src.active = false;
	}

	dst.numConnections--;
	if (dst.numConnections == 0) {
      74:	0fa0      	lsrs	r0, r4, #30
      76:	2000      	movs	r0, #0
      78:	0000      	movs	r0, r0
	...

0000007c <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)>:
};


class AudioStream_F32 : public AudioStream {
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
      7c:	b470      	push	{r4, r5, r6}
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
      7e:	4604      	mov	r4, r0
      80:	0324f100 	.word	0x0324f100

class AudioStream
{
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
      84:	4d17      	ldr	r5, [pc, #92]	; (e4 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x68>)
      86:	6005      	str	r5, [r0, #0]
      88:	72452501 	.word	0x72452501
      8c:	6103      	str	r3, [r0, #16]
			active = false;
      8e:	2300      	movs	r3, #0
      90:	60c37203 	.word	0x60c37203
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
      94:	7a65      	ldrb	r5, [r4, #9]
      96:	429d      	.short	0x429d
      98:	dd05      	ble.n	a6 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x2a>
				inputQueue[i] = NULL;
      9a:	6925      	.short	0x6925
      9c:	2600      	movs	r6, #0
      9e:	f845      	.short	0xf845
      a0:	6023      	str	r3, [r4, #0]
public:
	AudioStream(unsigned char ninput, audio_block_t **iqueue) :
		num_inputs(ninput), inputQueue(iqueue) {
			active = false;
			destination_list = NULL;
			for (int i=0; i < num_inputs; i++) {
      a2:	3301      	.short	0x3301
      a4:	e7f6      	b.n	94 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x18>
				inputQueue[i] = NULL;
			}
			// add to a simple list, for update_all
			// TODO: replace with a proper data flow analysis in update_all
			if (first_update == NULL) {
      a6:	4b10      	.short	0x4b10
      a8:	681c      	ldr	r4, [r3, #0]
      aa:	b914      	.short	0xb914
				first_update = this;
      ac:	6018      	str	r0, [r3, #0]
      ae:	e004      	.short	0xe004
			} else {
				AudioStream *p;
				for (p=first_update; p->next_update; p = p->next_update) ;
      b0:	461c      	mov	r4, r3
      b2:	6963      	.short	0x6963
      b4:	2b00      	cmp	r3, #0
      b6:	d1fb      	bne.n	b0 <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x34>
				p->next_update = this;
      b8:	23006160 	.word	0x23006160
			}
			next_update = NULL;
      bc:	6143      	str	r3, [r0, #20]
			cpu_cycles = 0;
      be:	8083      	strh	r3, [r0, #4]
			cpu_cycles_max = 0;
      c0:	728380c3 	.word	0x728380c3
      c4:	4c09      	ldr	r4, [pc, #36]	; (ec <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x70>)
      c6:	6004      	.short	0x6004
      c8:	7601      	strb	r1, [r0, #24]
      ca:	6202      	.short	0x6202
      //active_f32 = false;
      destination_list_f32 = NULL;
      cc:	61c3      	str	r3, [r0, #28]
      for (int i=0; i < n_input_f32; i++) {
      ce:	428b      	.short	0x428b
      d0:	da05      	bge.n	de <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x62>
        inputQueue_f32[i] = NULL;
      d2:	6a02      	.short	0x6a02
      d4:	2400      	movs	r4, #0
      d6:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
  public:
    AudioStream_F32(unsigned char n_input_f32, audio_block_f32_t **iqueue) : AudioStream(1, inputQueueArray_i16), 
        num_inputs_f32(n_input_f32), inputQueue_f32(iqueue) {
      //active_f32 = false;
      destination_list_f32 = NULL;
      for (int i=0; i < n_input_f32; i++) {
      da:	3301      	.short	0x3301
      dc:	e7f7      	b.n	ce <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)+0x52>
        inputQueue_f32[i] = NULL;
      }
    };
      de:	bc70      	.short	0xbc70
      e0:	4770      	bx	lr
      e2:	bf00      	.short	0xbf00
      e4:	0008      	movs	r0, r1
      e6:	2000      	.short	0x2000
      e8:	15fc      	asrs	r4, r7, #23
      ea:	2000      	.short	0x2000
      ec:	0014      	movs	r4, r2
      ee:	2000      	.short	0x2000

000000f0 <__static_initialization_and_destruction_0(int, int)>:
  sine1.frequency(300.0);  sine1.amplitude(0.005f);
  sine1.begin();
} 

void loop() {
}
      f0:	2801      	cmp	r0, #1
      f2:	d12e      	.short	0xd12e
      f4:	f64f 73ff 	movw	r3, #65535	; 0xffff
      f8:	4299      	cmp	r1, r3
      fa:	d12a      	.short	0xd12a
      fc:	b570      	push	{r4, r5, r6, lr}
class AudioSynthWaveformSine_F32 : public AudioStream_F32
{
//GUI: inputs:0, outputs:1 //this line used for automatic generation of GUI node
//GUI: shortName:sine  //this line used for automatic generation of GUI node
public:
	AudioSynthWaveformSine_F32() : AudioStream_F32(0, NULL), magnitude(16384) { } //uses default AUDIO_SAMPLE_RATE from AudioStream.h
      fe:	4c15      	.short	0x4c15
     100:	2200      	movs	r2, #0
     102:	4611      	mov	r1, r2
     104:	f7ff4620 	.word	0xf7ff4620
     108:	ffb9 4b13 			; <UNDEFINED> instruction: 0xffb94b13
     10c:	25006023 	.word	0x25006023
     110:	62a5      	str	r5, [r4, #40]	; 0x28
     112:	62e5      	.short	0x62e5
     114:	f44f 4380 	mov.w	r3, #16384	; 0x4000
     118:	4b106323 	.word	0x4b106323
     11c:	6363      	str	r3, [r4, #52]	; 0x34
     11e:	2301      	.short	0x2301
     120:	f884 3038 	strb.w	r3, [r4, #56]	; 0x38
class TL_AudioOutputI2S_OA_F32 : public AudioStream_F32
{
//GUI: inputs:2, outputs:0  //this line used for automatic generation of GUI node
public:
	// WAS AudioOutputI2S_OA_F32(void) : AudioStream_F32(2, inputQueueArray) {
	TL_AudioOutputI2S_OA_F32(int includeBegin) : AudioStream_F32(2, inputQueueArray) {
     124:	f1064e0e 	.word	0xf1064e0e
     128:	0228      	lsls	r0, r5, #8
     12a:	2102      	.short	0x2102
     12c:	4630      	mov	r0, r6
     12e:	f7ff ffa5 	bl	7c <AudioStream_F32::AudioStream_F32(unsigned char, audio_block_f32_t**)>
     132:	4b0c      	ldr	r3, [pc, #48]	; (164 <__static_initialization_and_destruction_0(int, int)+0x74>)
     134:	480c6033 	.word	0x480c6033
      { connect(); }
    AudioConnection_F32(AudioStream_F32 &source, unsigned char sourceOutput,
      AudioStream_F32 &destination, unsigned char destinationInput) :
      src(source), dst(destination),
      src_index(sourceOutput), dest_index(destinationInput),
      next_dest(NULL)
     138:	6004      	str	r4, [r0, #0]
     13a:	6046      	.short	0x6046
     13c:	7205      	strb	r5, [r0, #8]
     13e:	7245      	.short	0x7245
     140:	60c5      	str	r5, [r0, #12]
      { connect(); }
     142:	f001      	.short	0xf001
     144:	fef1 4b09 	cdp2	11, 15, cr4, cr1, cr9, {0}
#include "AudioControl.h"

class AudioControlSGTL5000 : public AudioControl
{
public:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
     148:	4a09      	ldr	r2, [pc, #36]	; (170 <__static_initialization_and_destruction_0(int, int)+0x80>)
     14a:	601a      	.short	0x601a
     14c:	220a      	movs	r2, #10
     14e:	721a      	.short	0x721a
     150:	bd70      	pop	{r4, r5, r6, pc}
     152:	4770      	bx	lr
     154:	0fc8      	lsrs	r0, r1, #31
     156:	2000      	movs	r0, #0
     158:	200002fc 	.word	0x200002fc
     15c:	4400      	add	r0, r0
     15e:	472c      	.short	0x472c
     160:	1004      	asrs	r4, r0, #32
     162:	2000      	movs	r0, #0
     164:	02f0      	lsls	r0, r6, #11
     166:	2000      	.short	0x2000
     168:	1034      	asrs	r4, r6, #32
     16a:	2000      	movs	r0, #0
     16c:	20000fbc 	.word	0x20000fbc
     170:	025c      	lsls	r4, r3, #9
     172:	2000      	.short	0x2000
		| (bestosr <= 8 ? LPUART_BAUD_BOTHEDGE : 0);
	port->PINCFG = 0;

	// Enable the transmitter, receiver and enable receiver interrupt
	attachInterruptVector(hardware->irq, hardware->irq_handler);
	NVIC_SET_PRIORITY(hardware->irq, hardware->irq_priority);	// maybe should put into hardware...
     174:	0000      	movs	r0, r0
	...

00000178 <setup>:
AudioSynthWaveformSine_F32  sine1;
TL_AudioOutputI2S_OA_F32    i2sOut(BEGIN_IN_CONSTRUCTOR);
AudioConnection_F32         patchCord1(sine1, 0, i2sOut, 0);
AudioControlSGTL5000        sgtl5000_1;

void setup(void) {
     178:	b510      	push	{r4, lr}
  Serial.begin(9600);   delay(1000);  // Any speed is OK
     17a:	f44f      	.short	0xf44f
     17c:	707a      	strb	r2, [r7, #1]
     17e:	f002      	.short	0xf002
     180:	fbb5 4c23 			; <UNDEFINED> instruction: 0xfbb54c23
class Print
{
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
     184:	685b6823 	.word	0x685b6823
     188:	221a      	movs	r2, #26
     18a:	4922      	.short	0x4922
     18c:	4620      	mov	r0, r4
     18e:	4798      	.short	0x4798
     190:	6823      	ldr	r3, [r4, #0]
     192:	685b      	ldr	r3, [r3, #4]
     194:	221b      	movs	r2, #27
     196:	4920      	ldr	r1, [pc, #128]	; (218 <setup+0xa0>)
     198:	4620      	mov	r0, r4
     19a:	4798      	blx	r3
	size_t print(double n, int digits = 2)		{ return printFloat(n, digits); }
	size_t print(const Printable &obj)		{ return obj.printTo(*this); }
	size_t println(void);
	size_t println(const String &s)			{ return print(s) + println(); }
	size_t println(char c)				{ return print(c) + println(); }
	size_t println(const char s[])			{ return print(s) + println(); }
     19c:	4620      	mov	r0, r4
     19e:	f003      	.short	0xf003
     1a0:	fe65 210a 	cdp2	1, 6, cr2, cr5, cr10, {0}
  Serial.print("Test load of F32 out with ");
  if (BEGIN_IN_CONSTRUCTOR)
     Serial.println("call to begin() in TL_AudioOutputI2S_OA_F32 constructor.");
  else
     Serial.println("call to begin() in setup().");
  AudioMemory(10);
     1a4:	481d      	ldr	r0, [pc, #116]	; (21c <setup+0xa4>)
     1a6:	f004      	.short	0xf004
     1a8:	fc27 200a 	stc2	0, cr2, [r7], #-40	; 0xffffffd8
  AudioMemory_F32(10);
     1ac:	f001 fe1a 	bl	1de4 <AudioMemory_F32(int)>

  // Next line, moved from constructor, allows Loader to operate without crash
  if(!BEGIN_IN_CONSTRUCTOR) i2sOut.begin();
     1b0:	481b      	ldr	r0, [pc, #108]	; (220 <setup+0xa8>)
     1b2:	f001 fd3d 	bl	1c30 <TL_AudioOutputI2S_OA_F32::begin()>
  
  sgtl5000_1.enable();
     1b6:	481b      	.short	0x481b
     1b8:	f000 f918 	bl	3ec <AudioControlSGTL5000::enable()>
	AudioSynthWaveformSine_F32(const AudioSettings_F32 &settings) : AudioStream_F32(0, NULL), magnitude(16384) {
		setSampleRate_Hz(settings.sample_rate_Hz);
	}
	void frequency(float freq) {
		if (freq < 0.0) freq = 0.0;
		else if (freq > sample_rate_Hz/2.f) freq = sample_rate_Hz/2.f;
     1bc:	ed934b1a 	.word	0xed934b1a
     1c0:	6a0d      	ldr	r5, [r1, #32]
     1c2:	eeb6 7a00 	vmov.f32	s14, #96	; 0x3f000000  0.5
     1c6:	ee26      	.short	0xee26
     1c8:	7a07      	ldrb	r7, [r0, #8]
     1ca:	eddf      	.short	0xeddf
     1cc:	7a18      	ldrb	r0, [r3, #8]
     1ce:	eeb4 7ae7 	vcmpe.f32	s14, s15
     1d2:	eef1      	.short	0xeef1
     1d4:	fa10 d401 			; <UNDEFINED> instruction: 0xfa10d401
     1d8:	7a67eeb0 	.word	0x7a67eeb0
		phase_increment = freq * (4294967296.0 / sample_rate_Hz);
     1dc:	eeb7 6ac6 	vcvt.f64.f32	d6, s12
     1e0:	4b09ed9f 	.word	0x4b09ed9f
     1e4:	ee84 5b06 	vdiv.f64	d5, d4, d6
     1e8:	7ac7eeb7 	.word	0x7ac7eeb7
     1ec:	ee27 7b05 	vmul.f64	d7, d7, d5
     1f0:	eebc4b0d 	.word	0xeebc4b0d
     1f4:	7bc7      	ldrb	r7, [r0, #15]
     1f6:	ed83 7a0b 	vstr	s14, [r3, #44]	; 0x2c
		phase_accumulator = angle * (4294967296.0f / 360.0f);
	}
	void amplitude(float n) {
		if (n < 0) n = 0;
		else if (n > 1.0f) n = 1.0f;
		magnitude = n * 65536.0f;
     1fa:	f240      	.short	0xf240
     1fc:	1247      	asrs	r7, r0, #9
     1fe:	631a      	.short	0x631a
	}
	void setSampleRate_Hz(const float &fs_Hz) {
		phase_increment *= sample_rate_Hz / fs_Hz; //change the phase increment for the new frequency
		sample_rate_Hz = fs_Hz;
	}
	void begin(void) { enabled = true; }
     200:	2201      	movs	r2, #1
     202:	f883      	.short	0xf883
     204:	2038      	movs	r0, #56	; 0x38
     206:	bd10      	.short	0xbd10
     208:	0000      	movs	r0, r0
     20a:	0000      	movs	r0, r0
     20c:	41f00000 	.word	0x41f00000
     210:	0744      	lsls	r4, r0, #29
     212:	2000      	.short	0x2000
     214:	0018      	movs	r0, r3
     216:	2000      	movs	r0, #0
     218:	20000034 	.word	0x20000034
     21c:	0000      	movs	r0, r0
     21e:	2020      	movs	r0, #32
     220:	1004      	asrs	r4, r0, #32
     222:	2000      	movs	r0, #0
     224:	0fbc      	lsrs	r4, r7, #30
     226:	2000      	movs	r0, #0
     228:	20000fc8 	.word	0x20000fc8
     22c:	0000      	movs	r0, r0
     22e:	4396      	bics	r6, r2

00000230 <loop>:
  
  sine1.frequency(300.0);  sine1.amplitude(0.005f);
  sine1.begin();
} 

void loop() {
     230:	bf004770 	.word	0xbf004770

00000234 <_GLOBAL__sub_I_sine1>:
}
     234:	b508      	push	{r3, lr}
     236:	f64f      	.short	0xf64f
     238:	71ff      	strb	r7, [r7, #7]
     23a:	2001      	.short	0x2001
     23c:	f7ff ff58 	bl	f0 <__static_initialization_and_destruction_0(int, int)>
     240:	bf00bd08 	.word	0xbf00bd08

00000244 <memcpy_tointerleaveLR>:
	@ r0: dst
	@ r1: srcL
	@ r2: srcR

#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11,r14}
     244:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	add r14,r0,#(AUDIO_BLOCK_SAMPLES*2)
     248:	7e80f500 	.word	0x7e80f500

0000024c <.loopLR>:
	.align 2
.loopLR:
	//Load 2*4 words
	ldmia r1!, {r5,r7,r9,r11}  //1+4
     24c:	e8b1 0aa0 	ldmia.w	r1!, {r5, r7, r9, fp}
	ldmia r2!, {r6,r8,r10,r12} //1+4	
     250:	1540e8b2 	.word	0x1540e8b2

	pkhbt r3,r5,r6,LSL #16	//1
     254:	eac5 4306 	pkhbt	r3, r5, r6, lsl #16
	pkhtb r4,r6,r5,ASR #16	//1
     258:	4425eac6 	.word	0x4425eac6

	pkhbt r5,r7,r8,LSL #16	//1
     25c:	eac7 4508 	pkhbt	r5, r7, r8, lsl #16
	pkhtb r6,r8,r7,ASR #16	//1
     260:	4627eac8 	.word	0x4627eac8

	pkhbt r7,r9,r10,LSL #16	//1
     264:	eac9 470a 	pkhbt	r7, r9, sl, lsl #16
	pkhtb r8,r10,r9,ASR #16	//1
     268:	4829eaca 	.word	0x4829eaca

	pkhbt r9,r11,r12,LSL #16	//1
     26c:	eacb 490c 	pkhbt	r9, fp, ip, lsl #16
	pkhtb r10,r12,r11,ASR #16	//1
     270:	4a2beacc 	.word	0x4a2beacc

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}	//1+8 -> 5+5+8+9 = 27 Cycles to interleave 32 bytes. 
     274:	e8a0 07f8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}
	
	cmp r14, r0
     278:	d1e74586 	.word	0xd1e74586
	bne .loopLR

	pop	{r4-r11,r14}	
     27c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	pkhtb r6,r8,r7,ASR #16

	stmia r0!, {r3,r4,r5,r6}
	pop	{r4-r8,r14}	
#endif
	BX lr
     280:	Address 0x0000000000000280 is out of bounds.


00000282 <memcpy_tointerleaveL>:
	memcpy_tointerleaveL:

	@ r0: dst
	@ r1: srcL
	
	mov r2, #0
     282:	f04f 0200 	mov.w	r2, #0
	
#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11}
     286:	e92d      	.short	0xe92d
     288:	0ff0      	lsrs	r0, r6, #31
	add r12,r0,#(AUDIO_BLOCK_SAMPLES*2)
     28a:	f500      	.short	0xf500
     28c:	7c80      	ldrb	r0, [r0, #18]
     28e:	bf00      	.short	0xbf00

00000290 <.loopL>:
	.align 2
.loopL:

	//Load 4 words
	ldmia r1!, {r5,r7,r9,r11}  //1+4
     290:	e8b1 0aa0 	ldmia.w	r1!, {r5, r7, r9, fp}

	pkhbt r3,r5,r2	//1
     294:	0302eac5 	.word	0x0302eac5
	pkhtb r4,r2,r5,ASR #16	//1
     298:	eac2 4425 	pkhtb	r4, r2, r5, asr #16

	pkhbt r5,r7,r2	//1
     29c:	0502eac7 	.word	0x0502eac7
	pkhtb r6,r2,r7,ASR #16	//1
     2a0:	eac2 4627 	pkhtb	r6, r2, r7, asr #16

	pkhbt r7,r9,r2	//1
     2a4:	0702eac9 	.word	0x0702eac9
	pkhtb r8,r2,r9,ASR #16	//1
     2a8:	eac2 4829 	pkhtb	r8, r2, r9, asr #16

	pkhbt r9,r11,r2	//1
     2ac:	eacb 0902 	pkhbt	r9, fp, r2
	pkhtb r10,r2,r11,ASR #16	//1
     2b0:	4a2beac2 	.word	0x4a2beac2

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}	//1+8
     2b4:	e8a0 07f8 	stmia.w	r0!, {r3, r4, r5, r6, r7, r8, r9, sl}

	cmp r12, r0
     2b8:	4584      	cmp	ip, r0
	bne .loopL
     2ba:	d1e9      	bne.n	290 <.loopL>

	pop	{r4-r11}
     2bc:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}

	stmia r0!, {r3,r4,r5,r6}
	
	pop	{r4-r7}
#endif	
	BX lr
     2c0:	Address 0x00000000000002c0 is out of bounds.


000002c2 <memcpy_tointerleaveR>:
	memcpy_tointerleaveR:

	@ r0: dst
	@ r1: srcR

	mov r2, #0
     2c2:	f04f 0200 	mov.w	r2, #0
#if AUDIO_BLOCK_SAMPLES > 8
	push	{r4-r11}
     2c6:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	add r12,r0,#(AUDIO_BLOCK_SAMPLES*2)
     2ca:	f500      	.short	0xf500
     2cc:	7c80      	ldrb	r0, [r0, #18]
     2ce:	bf00      	nop

000002d0 <.loopR>:
	.align 2
.loopR:

	//Load 4 words
	ldmia r1!, {r5,r7,r9,r11}
     2d0:	0aa0e8b1 	.word	0x0aa0e8b1

	pkhbt r3,r2,r5,LSL #16
     2d4:	eac2 4305 	pkhbt	r3, r2, r5, lsl #16
	pkhtb r4,r5,r2
     2d8:	eac2 0405 	pkhbt	r4, r2, r5

	pkhbt r5,r2,r7,LSL #16
     2dc:	4507eac2 	.word	0x4507eac2
	pkhtb r6,r7,r2
     2e0:	eac2 0607 	pkhbt	r6, r2, r7

	pkhbt r7,r2,r9,LSL #16
     2e4:	eac2 4709 	pkhbt	r7, r2, r9, lsl #16
	pkhtb r8,r9,r2
     2e8:	0809eac2 	.word	0x0809eac2

	pkhbt r9,r2,r11,LSL #16
     2ec:	eac2 490b 	pkhbt	r9, r2, fp, lsl #16
	pkhtb r10,r11,r2
     2f0:	eac2 0a0b 	pkhbt	sl, r2, fp

	//Write 8 Words
	stmia r0!, {r3,r4,r5,r6,r7,r8,r9,r10}
     2f4:	07f8e8a0 	.word	0x07f8e8a0

	cmp r12, r0
     2f8:	4584      	cmp	ip, r0
	bne .loopR
     2fa:	d1e9      	bne.n	2d0 <.loopR>

	pop	{r4-r11}
     2fc:	0ff0e8bd 	.word	0x0ff0e8bd
	stmia r0!, {r3,r4,r5,r6}

	pop	{r4-r7}

#endif	
	BX lr
     300:	4770      	bx	lr

00000302 <memcpy_tointerleaveQuad>:
	@ r1: src1
	@ r2: src2
	@ r3: src3
	@ r4: src4

	push	{r4-r11}
     302:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	ldr r4, [sp, #(0+32)] //5th parameter is saved on the stack
     306:	9c08      	.short	0x9c08
	add r11,r0,#(AUDIO_BLOCK_SAMPLES*4)
     308:	f500 7b00 	add.w	fp, r0, #512	; 0x200

0000030c <.loopQuad>:
	.align 2
.loopQuad:

	ldr r5, [r1],4
     30c:	f851 5b04 	ldr.w	r5, [r1], #4
	ldr r6, [r3],4
     310:	6b04f853 	.word	0x6b04f853
	pkhbt r7,r5,r6,LSL #16
     314:	eac5 4706 	pkhbt	r7, r5, r6, lsl #16
	pkhtb r9,r6,r5,ASR #16
     318:	eac6 4925 	pkhtb	r9, r6, r5, asr #16
	ldr r5, [r2],4
     31c:	5b04f852 	.word	0x5b04f852
	ldr r6, [r4],4
     320:	f854 6b04 	ldr.w	r6, [r4], #4
	pkhbt r8,r5,r6,LSL #16
     324:	eac5 4806 	pkhbt	r8, r5, r6, lsl #16
	pkhtb r10,r6,r5,ASR #16
     328:	4a25eac6 	.word	0x4a25eac6

	stmia r0!, {r7-r10}
     32c:	e8a0 0780 	stmia.w	r0!, {r7, r8, r9, sl}

	cmp r11, r0
     330:	4583      	cmp	fp, r0
	bne .loopQuad
     332:	d1eb      	.short	0xd1eb

	pop	{r4-r11}
     334:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
	BX lr
     338:	4770      	bx	lr
				div = d-2;
			} else {
				div =0;
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
     33a:	bf00      	.short	0xbf00

0000033c <__static_initialization_and_destruction_0(int, int)>:
	*coeffs++=(T)(b0 * a0Inv);
	*coeffs++=(T)(b1 * a0Inv);
	*coeffs++=(T)(b2 * a0Inv);
	*coeffs++=(T)(-a1 * a0Inv);
	*coeffs=(T)(-a2 * a0Inv);
}
     33c:	2801      	cmp	r0, #1
     33e:	d10a      	bne.n	356 <__static_initialization_and_destruction_0(int, int)+0x1a>
     340:	f64fb508 	.word	0xf64fb508
     344:	73ff      	strb	r7, [r7, #15]
     346:	4299      	cmp	r1, r3
     348:	4a03d104 	.word	0x4a03d104
     34c:	4903      	ldr	r1, [pc, #12]	; (35c <__static_initialization_and_destruction_0(int, int)+0x20>)
     34e:	4804      	ldr	r0, [pc, #16]	; (360 <__static_initialization_and_destruction_0(int, int)+0x24>)
volatile int32_t AsyncAudioInputSPDIF3::buffer_offset = 0;	// read by resample/ written in spdif input isr -> copied at the beginning of 'resmaple' protected by __disable_irq() in resample
int32_t AsyncAudioInputSPDIF3::resample_offset = 0; // read/written by resample/ read in spdif input isr -> no protection needed?

volatile bool AsyncAudioInputSPDIF3::lockChanged=false;
volatile bool AsyncAudioInputSPDIF3::locked=false;
DMAChannel AsyncAudioInputSPDIF3::dma(false);
     350:	fe6af003 	.word	0xfe6af003
     354:	bd08      	pop	{r3, pc}
     356:	4770      	bx	lr
     358:	20000640 	.word	0x20000640
     35c:	0365      	lsls	r5, r4, #13
     35e:	0000      	movs	r0, r0
     360:	20001044 	.word	0x20001044

00000364 <DMAChannel::~DMAChannel()>:
	}
	DMAChannel & operator = (const DMASetting &rhs) {
		copy_tcd(TCD, rhs.TCD);
		return *this;
	}
	~DMAChannel() {
     364:	b510      	push	{r4, lr}
     366:	4604      	mov	r4, r0
		release();
     368:	fd1cf003 	.word	0xfd1cf003
	}
     36c:	4620      	mov	r0, r4
     36e:	bd10      	pop	{r4, pc}

00000370 <_GLOBAL__sub_I__ZN21AsyncAudioInputSPDIF314resetResamplerE>:
	NVIC_ENABLE_IRQ(IRQ_SPDIF);

	SPDIF_SIC |= SPDIF_SIC_LOCK;	//clear SPDIF_SIC_LOCK interrupt
	SPDIF_SIC |= SPDIF_SIC_LOCKLOSS;//clear SPDIF_SIC_LOCKLOSS interrupt
	locked=(SPDIF_SRPC & SPDIF_SRPC_LOCK);
}
     370:	f64fb508 	.word	0xf64fb508
     374:	71ff      	strb	r7, [r7, #7]
     376:	2001      	movs	r0, #1
     378:	ffe0f7ff 	.word	0xffe0f7ff
     37c:	bd08      	pop	{r3, pc}
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
	uint32_t end_addr = (uint32_t)addr + size;
	asm volatile("": : :"memory");
	asm("dsb");
	do {
		SCB_CACHE_DCCIMVAC = location;
     37e:	bf00      	nop

00000380 <AudioControlSGTL5000::disable()>:
	void setAddress(uint8_t level);
	bool enable(void);
	bool disable(void) { return false; }
     380:	47702000 	.word	0x47702000

00000384 <AudioControlSGTL5000::inputLevel(float)>:
	bool volume(float n) { return volumeInteger(n * 129 + 0.499); }
	bool inputLevel(float n) {return false;}
     384:	2000      	movs	r0, #0
     386:	4770      	bx	lr

00000388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>:
	val |= Wire.read();
	return val;
}

bool AudioControlSGTL5000::write(unsigned int reg, unsigned int val)
{
     388:	460eb5f8 	.word	0x460eb5f8
     38c:	4617      	mov	r7, r2
	if (reg == CHIP_ANA_CTRL) ana_ctrl = val;
     38e:	2924      	.short	0x2924
     390:	d100      	bne.n	394 <AudioControlSGTL5000::write(unsigned int, unsigned int)+0xc>
     392:	80c2      	strh	r2, [r0, #6]
	Wire.beginTransmission(i2c_addr);
     394:	7a03      	ldrb	r3, [r0, #8]
	void end();
	void setClock(uint32_t frequency);
	void setSDA(uint8_t pin);
	void setSCL(uint8_t pin); 
	void beginTransmission(uint8_t address) {
		txBuffer[0] = (address << 1);
     396:	4c14      	.short	0x4c14
     398:	005b      	lsls	r3, r3, #1
     39a:	f884      	.short	0xf884
     39c:	303d      	adds	r0, #61	; 0x3d
		transmitting = 1;
     39e:	2501      	movs	r5, #1
     3a0:	f884 5060 	strb.w	r5, [r4, #96]	; 0x60
		txBufferLength = 1;
     3a4:	f884 505f 	strb.w	r5, [r4, #95]	; 0x5f
	}
	size_t write(long n) {
		return write((uint8_t)n);
	}
	size_t write(unsigned int n) {
		return write((uint8_t)n);
     3a8:	6823      	ldr	r3, [r4, #0]
     3aa:	681b      	ldr	r3, [r3, #0]
     3ac:	f3c6 2107 	ubfx	r1, r6, #8, #8
     3b0:	4620      	mov	r0, r4
     3b2:	4798      	blx	r3
     3b4:	6823      	ldr	r3, [r4, #0]
     3b6:	681b      	ldr	r3, [r3, #0]
     3b8:	b2f1      	uxtb	r1, r6
     3ba:	4620      	mov	r0, r4
     3bc:	4798      	blx	r3
     3be:	6823      	ldr	r3, [r4, #0]
     3c0:	681b      	ldr	r3, [r3, #0]
     3c2:	f3c7 2107 	ubfx	r1, r7, #8, #8
     3c6:	4620      	mov	r0, r4
     3c8:	4798      	blx	r3
     3ca:	6823      	ldr	r3, [r4, #0]
     3cc:	681b      	ldr	r3, [r3, #0]
     3ce:	b2f9      	uxtb	r1, r7
     3d0:	4620      	mov	r0, r4
     3d2:	4798      	blx	r3
	void beginTransmission(int address) {
		beginTransmission((uint8_t)address);
	}
	uint8_t endTransmission(uint8_t sendStop);
	uint8_t endTransmission(void) {
		return endTransmission(1);
     3d4:	4629      	mov	r1, r5
     3d6:	4620      	mov	r0, r4
     3d8:	f001 ff4a 	bl	2270 <TwoWire::endTransmission(unsigned char)>
	Wire.write(reg >> 8);
	Wire.write(reg);
	Wire.write(val >> 8);
	Wire.write(val);
	if (Wire.endTransmission() == 0) return true;
     3dc:	b908      	cbnz	r0, 3e2 <AudioControlSGTL5000::write(unsigned int, unsigned int)+0x5a>
     3de:	4628      	mov	r0, r5
     3e0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return false;
     3e2:	2000      	movs	r0, #0
}
     3e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
     3e6:	bf00      	nop
     3e8:	2000069c 	.word	0x2000069c

000003ec <AudioControlSGTL5000::enable()>:
		i2c_addr = SGTL5000_I2C_ADDR_CS_HIGH;
	}
}

bool AudioControlSGTL5000::enable(void)
{
     3ec:	b538      	push	{r3, r4, r5, lr}
     3ee:	4604      	mov	r4, r0
	muted = true;
     3f0:	2301      	movs	r3, #1
     3f2:	7103      	strb	r3, [r0, #4]
	Wire.begin();
     3f4:	4834      	ldr	r0, [pc, #208]	; (4c8 <AudioControlSGTL5000::enable()+0xdc>)
     3f6:	f002 f80f 	bl	2418 <TwoWire::begin()>
	delay(5);
     3fa:	2005      	movs	r0, #5
     3fc:	f002 fa76 	bl	28ec <delay>
	//Serial.print("chip ID = ");
	//delay(5);
	//unsigned int n = read(CHIP_ID);
	//Serial.println(n, HEX);

	int r = write(CHIP_ANA_POWER, 0x4060);  // VDDD is externally driven with 1.8V
     400:	f244 0260 	movw	r2, #16480	; 0x4060
     404:	2130      	movs	r1, #48	; 0x30
     406:	4620      	mov	r0, r4
     408:	f7ff ffbe 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	if (!r) return false;
     40c:	4605      	mov	r5, r0
     40e:	2800      	cmp	r0, #0
     410:	d058      	beq.n	4c4 <AudioControlSGTL5000::enable()+0xd8>
	write(CHIP_LINREG_CTRL, 0x006C);  // VDDA & VDDIO both over 3.1V
     412:	226c      	movs	r2, #108	; 0x6c
     414:	2126      	movs	r1, #38	; 0x26
     416:	4620      	mov	r0, r4
     418:	f7ff ffb6 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_REF_CTRL, 0x01F2); // VAG=1.575, normal ramp, +12.5% bias current
     41c:	f44f 72f9 	mov.w	r2, #498	; 0x1f2
     420:	2128      	movs	r1, #40	; 0x28
     422:	4620      	mov	r0, r4
     424:	f7ff ffb0 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_LINE_OUT_CTRL, 0x0F22); // LO_VAGCNTRL=1.65V, OUT_CURRENT=0.54mA
     428:	f640 7222 	movw	r2, #3874	; 0xf22
     42c:	212c      	movs	r1, #44	; 0x2c
     42e:	4620      	mov	r0, r4
     430:	f7ff ffaa 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_SHORT_CTRL, 0x4446);  // allow up to 125mA
     434:	f244 4246 	movw	r2, #17478	; 0x4446
     438:	213c      	movs	r1, #60	; 0x3c
     43a:	4620      	mov	r0, r4
     43c:	f7ff ffa4 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0137);  // enable zero cross detectors
     440:	f240 1237 	movw	r2, #311	; 0x137
     444:	2124      	movs	r1, #36	; 0x24
     446:	4620      	mov	r0, r4
     448:	f7ff ff9e 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_POWER, 0x40FF); // power up: lineout, hp, adc, dac
     44c:	f244 02ff 	movw	r2, #16639	; 0x40ff
     450:	2130      	movs	r1, #48	; 0x30
     452:	4620      	mov	r0, r4
     454:	f7ff ff98 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_DIG_POWER, 0x0073); // power up all digital stuff
     458:	2273      	movs	r2, #115	; 0x73
     45a:	2102      	movs	r1, #2
     45c:	4620      	mov	r0, r4
     45e:	f7ff ff93 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	delay(400);
     462:	f44f 70c8 	mov.w	r0, #400	; 0x190
     466:	f002 fa41 	bl	28ec <delay>
	write(CHIP_LINE_OUT_VOL, 0x1D1D); // default approx 1.3 volts peak-to-peak
     46a:	f641 521d 	movw	r2, #7453	; 0x1d1d
     46e:	212e      	movs	r1, #46	; 0x2e
     470:	4620      	mov	r0, r4
     472:	f7ff ff89 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_CLK_CTRL, 0x0004);  // 44.1 kHz, 256*Fs
     476:	2204      	movs	r2, #4
     478:	4611      	mov	r1, r2
     47a:	4620      	mov	r0, r4
     47c:	f7ff ff84 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_I2S_CTRL, 0x0030); // SCLK=64*Fs, 16bit, I2S format
     480:	2230      	movs	r2, #48	; 0x30
     482:	2106      	movs	r1, #6
     484:	4620      	mov	r0, r4
     486:	f7ff ff7f 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	// default signal routing is ok?
	write(CHIP_SSS_CTRL, 0x0010); // ADC->I2S, I2S->DAC
     48a:	2210      	movs	r2, #16
     48c:	210a      	movs	r1, #10
     48e:	4620      	mov	r0, r4
     490:	f7ff ff7a 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ADCDAC_CTRL, 0x0000); // disable dac mute
     494:	2200      	movs	r2, #0
     496:	210e      	movs	r1, #14
     498:	4620      	mov	r0, r4
     49a:	f7ff ff75 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_DAC_VOL, 0x3C3C); // digital gain, 0dB
     49e:	f643 423c 	movw	r2, #15420	; 0x3c3c
     4a2:	2110      	movs	r1, #16
     4a4:	4620      	mov	r0, r4
     4a6:	f7ff ff6f 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_HP_CTRL, 0x7F7F); // set volume (lowest level)
     4aa:	f647 727f 	movw	r2, #32639	; 0x7f7f
     4ae:	2122      	movs	r1, #34	; 0x22
     4b0:	4620      	mov	r0, r4
     4b2:	f7ff ff69 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	write(CHIP_ANA_CTRL, 0x0036);  // enable zero cross detectors
     4b6:	2236      	movs	r2, #54	; 0x36
     4b8:	2124      	movs	r1, #36	; 0x24
     4ba:	4620      	mov	r0, r4
     4bc:	f7ff ff64 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	//mute = false;
	semi_automated = true;
     4c0:	2301      	movs	r3, #1
     4c2:	7263      	strb	r3, [r4, #9]
	return true;
}
     4c4:	4628      	mov	r0, r5
     4c6:	bd38      	pop	{r3, r4, r5, pc}
     4c8:	2000069c 	.word	0x2000069c

000004cc <AudioControlSGTL5000::inputSelect(int)>:
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
	bool muteLineout(void) { return write(0x0024, ana_ctrl | (1<<8)); }
	bool unmuteLineout(void) { return write(0x0024, ana_ctrl & ~(1<<8)); }
	bool inputSelect(int n) {
     4cc:	b510      	push	{r4, lr}
     4ce:	4604      	mov	r4, r0
		if (n == AUDIO_INPUT_LINEIN) {
     4d0:	b971      	cbnz	r1, 4f0 <AudioControlSGTL5000::inputSelect(int)+0x24>
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
     4d2:	2255      	movs	r2, #85	; 0x55
     4d4:	2120      	movs	r1, #32
     4d6:	f7ff ff57 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
     4da:	4603      	mov	r3, r0
     4dc:	b310      	cbz	r0, 524 <AudioControlSGTL5000::inputSelect(int)+0x58>
     4de:	88e2      	ldrh	r2, [r4, #6]
     4e0:	f042 0204 	orr.w	r2, r2, #4
     4e4:	2124      	movs	r1, #36	; 0x24
     4e6:	4620      	mov	r0, r4
     4e8:	f7ff ff4e 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
     4ec:	4603      	mov	r3, r0
     4ee:	e019      	b.n	524 <AudioControlSGTL5000::inputSelect(int)+0x58>
		} else if (n == AUDIO_INPUT_MIC) {
     4f0:	2901      	cmp	r1, #1
     4f2:	d116      	bne.n	522 <AudioControlSGTL5000::inputSelect(int)+0x56>
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
     4f4:	f240 1273 	movw	r2, #371	; 0x173
     4f8:	212a      	movs	r1, #42	; 0x2a
     4fa:	f7ff ff45 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
     4fe:	4603      	mov	r3, r0
     500:	b180      	cbz	r0, 524 <AudioControlSGTL5000::inputSelect(int)+0x58>
		if (n == AUDIO_INPUT_LINEIN) {
			return write(0x0020, 0x055) // +7.5dB gain (1.3Vp-p full scale)
			 && write(0x0024, ana_ctrl | (1<<2)); // enable linein
		} else if (n == AUDIO_INPUT_MIC) {
			return write(0x002A, 0x0173) // mic preamp gain = +40dB
			 && write(0x0020, 0x088)     // input gain +12dB (is this enough?)
     502:	2288      	movs	r2, #136	; 0x88
     504:	2120      	movs	r1, #32
     506:	4620      	mov	r0, r4
     508:	f7ff ff3e 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
     50c:	4603      	mov	r3, r0
     50e:	b148      	cbz	r0, 524 <AudioControlSGTL5000::inputSelect(int)+0x58>
			 && write(0x0024, ana_ctrl & ~(1<<2)); // enable mic
     510:	88e2      	ldrh	r2, [r4, #6]
     512:	f022 0204 	bic.w	r2, r2, #4
     516:	2124      	movs	r1, #36	; 0x24
     518:	4620      	mov	r0, r4
     51a:	f7ff ff35 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
     51e:	4603      	mov	r3, r0
     520:	e000      	b.n	524 <AudioControlSGTL5000::inputSelect(int)+0x58>
		} else {
			return false;
     522:	2300      	movs	r3, #0
		}
	}
     524:	4618      	mov	r0, r3
     526:	bd10      	pop	{r4, pc}

00000528 <AudioControlSGTL5000::volumeInteger(unsigned int)>:
	if(!write(reg,val1)) return 0;
	return val1;
}

bool AudioControlSGTL5000::volumeInteger(unsigned int n)
{
     528:	b538      	push	{r3, r4, r5, lr}
     52a:	4605      	mov	r5, r0
	if (n == 0) {
     52c:	b971      	cbnz	r1, 54c <AudioControlSGTL5000::volumeInteger(unsigned int)+0x24>
		muted = true;
     52e:	2301      	movs	r3, #1
     530:	7103      	strb	r3, [r0, #4]
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
     532:	f647 727f 	movw	r2, #32639	; 0x7f7f
     536:	2122      	movs	r1, #34	; 0x22
     538:	f7ff ff26 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
	void setAddress(uint8_t level);
	bool enable(void);
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499); }
	bool inputLevel(float n) {return false;}
	bool muteHeadphone(void) { return write(0x0024, ana_ctrl | (1<<4)); }
     53c:	88ea      	ldrh	r2, [r5, #6]
     53e:	f042 0210 	orr.w	r2, r2, #16
     542:	2124      	movs	r1, #36	; 0x24
     544:	4628      	mov	r0, r5
     546:	f7ff ff1f 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		return muteHeadphone();
     54a:	bd38      	pop	{r3, r4, r5, pc}
	} else if (n > 0x80) {
     54c:	2980      	cmp	r1, #128	; 0x80
     54e:	d802      	bhi.n	556 <AudioControlSGTL5000::volumeInteger(unsigned int)+0x2e>
		n = 0;
	} else {
		n = 0x80 - n;
     550:	f1c1 0480 	rsb	r4, r1, #128	; 0x80
     554:	e000      	b.n	558 <AudioControlSGTL5000::volumeInteger(unsigned int)+0x30>
	if (n == 0) {
		muted = true;
		write(CHIP_ANA_HP_CTRL, 0x7F7F);
		return muteHeadphone();
	} else if (n > 0x80) {
		n = 0;
     556:	2400      	movs	r4, #0
	} else {
		n = 0x80 - n;
	}
	if (muted) {
     558:	792b      	ldrb	r3, [r5, #4]
     55a:	b143      	cbz	r3, 56e <AudioControlSGTL5000::volumeInteger(unsigned int)+0x46>
		muted = false;
     55c:	2300      	movs	r3, #0
     55e:	712b      	strb	r3, [r5, #4]
	bool unmuteHeadphone(void) { return write(0x0024, ana_ctrl & ~(1<<4)); }
     560:	88ea      	ldrh	r2, [r5, #6]
     562:	f022 0210 	bic.w	r2, r2, #16
     566:	2124      	movs	r1, #36	; 0x24
     568:	4628      	mov	r0, r5
     56a:	f7ff ff0d 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
		unmuteHeadphone();
	}
	n = n | (n << 8);
	return write(CHIP_ANA_HP_CTRL, n);  // set volume
     56e:	ea44 2204 	orr.w	r2, r4, r4, lsl #8
     572:	2122      	movs	r1, #34	; 0x22
     574:	4628      	mov	r0, r5
     576:	f7ff ff07 	bl	388 <AudioControlSGTL5000::write(unsigned int, unsigned int)>
}
     57a:	bd38      	pop	{r3, r4, r5, pc}

			uint32_t cbcmr = CCM_CBCMR;
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
     57c:	0000      	movs	r0, r0
	...

00000580 <AudioControlSGTL5000::volume(float)>:
public:
	AudioControlSGTL5000(void) : i2c_addr(0x0A) { }
	void setAddress(uint8_t level);
	bool enable(void);
	bool disable(void) { return false; }
	bool volume(float n) { return volumeInteger(n * 129 + 0.499); }
     580:	b508      	push	{r3, lr}
     582:	eddf 7a0b 	vldr	s15, [pc, #44]	; 5b0 <AudioControlSGTL5000::volume(float)+0x30>
     586:	ee20 0a27 	vmul.f32	s0, s0, s15
     58a:	eeb7 0ac0 	vcvt.f64.f32	d0, s0
     58e:	ed9f 7b06 	vldr	d7, [pc, #24]	; 5a8 <AudioControlSGTL5000::volume(float)+0x28>
     592:	ee30 0b07 	vadd.f64	d0, d0, d7
     596:	eefc 7bc0 	vcvt.u32.f64	s15, d0
     59a:	ee17 1a90 	vmov	r1, s15
     59e:	f7ff ffc3 	bl	528 <AudioControlSGTL5000::volumeInteger(unsigned int)>
     5a2:	bd08      	pop	{r3, pc}
     5a4:	f3af 8000 	nop.w
     5a8:	b22d0e56 	.word	0xb22d0e56
     5ac:	3fdfef9d 	.word	0x3fdfef9d
     5b0:	43010000 	.word	0x43010000

000005b4 <__static_initialization_and_destruction_0(int, int)>:
			+ capture_buffer[i * 4 + 2] + capture_buffer[i * 4 + 3];
#endif
	}
	transmit(output);
	release(output);
}
     5b4:	2801      	cmp	r0, #1
     5b6:	d10a      	bne.n	5ce <__static_initialization_and_destruction_0(int, int)+0x1a>
     5b8:	b508      	push	{r3, lr}
     5ba:	f64f 73ff 	movw	r3, #65535	; 0xffff
     5be:	4299      	cmp	r1, r3
     5c0:	d104      	bne.n	5cc <__static_initialization_and_destruction_0(int, int)+0x18>

extern "C" void xbar_connect(unsigned int input, unsigned int output);

#define FILTERLEN 15

DMAChannel AudioInputAnalog::dma(false);
     5c2:	4a03      	ldr	r2, [pc, #12]	; (5d0 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     5c4:	4903      	ldr	r1, [pc, #12]	; (5d4 <__static_initialization_and_destruction_0(int, int)+0x20>)
     5c6:	4804      	ldr	r0, [pc, #16]	; (5d8 <__static_initialization_and_destruction_0(int, int)+0x24>)
     5c8:	f003 fd2e 	bl	4028 <__aeabi_atexit>
     5cc:	bd08      	pop	{r3, pc}
     5ce:	4770      	bx	lr
     5d0:	20000640 	.word	0x20000640
     5d4:	00000365 	.word	0x00000365
     5d8:	2000104c 	.word	0x2000104c

000005dc <_GLOBAL__sub_I__ZN16AudioInputAnalog3dmaE>:
			+ capture_buffer[i * 4 + 2] + capture_buffer[i * 4 + 3];
#endif
	}
	transmit(output);
	release(output);
}
     5dc:	b508      	push	{r3, lr}
     5de:	f64f 71ff 	movw	r1, #65535	; 0xffff
     5e2:	2001      	movs	r0, #1
     5e4:	f7ff ffe6 	bl	5b4 <__static_initialization_and_destruction_0(int, int)>
     5e8:	bd08      	pop	{r3, pc}
			if (pin == 0) {
				CORE_PIN0_PORTCLEAR = CORE_PIN0_BITMASK;
			} else if (pin == 1) {
				CORE_PIN1_PORTCLEAR = CORE_PIN1_BITMASK;
			} else if (pin == 2) {
				CORE_PIN2_PORTCLEAR = CORE_PIN2_BITMASK;
     5ea:	bf00      	nop

000005ec <__static_initialization_and_destruction_0(int, int)>:
	I2S1_RCSR = 0;
	I2S1_RCSR = I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
	update_responsibility = update_setup();
	dma.attachInterrupt(isr);
#endif
}
     5ec:	2801      	cmp	r0, #1
     5ee:	d10a      	bne.n	606 <__static_initialization_and_destruction_0(int, int)+0x1a>
     5f0:	b508      	push	{r3, lr}
     5f2:	f64f 73ff 	movw	r3, #65535	; 0xffff
     5f6:	4299      	cmp	r1, r3
     5f8:	d104      	bne.n	604 <__static_initialization_and_destruction_0(int, int)+0x18>
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S::block_left = NULL;
audio_block_t * AudioInputI2S::block_right = NULL;
uint16_t AudioInputI2S::block_offset = 0;
bool AudioInputI2S::update_responsibility = false;
DMAChannel AudioInputI2S::dma(false);
     5fa:	4a03      	ldr	r2, [pc, #12]	; (608 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     5fc:	4903      	ldr	r1, [pc, #12]	; (60c <__static_initialization_and_destruction_0(int, int)+0x20>)
     5fe:	4804      	ldr	r0, [pc, #16]	; (610 <__static_initialization_and_destruction_0(int, int)+0x24>)
     600:	f003 fd12 	bl	4028 <__aeabi_atexit>
     604:	bd08      	pop	{r3, pc}
     606:	4770      	bx	lr
     608:	20000640 	.word	0x20000640
     60c:	00000365 	.word	0x00000365
     610:	20001054 	.word	0x20001054

00000614 <_GLOBAL__sub_I__ZN13AudioInputI2S10block_leftE>:
	I2S1_RCSR = 0;
	I2S1_RCSR = I2S_RCSR_RE | I2S_RCSR_BCE | I2S_RCSR_FRDE | I2S_RCSR_FR;
	update_responsibility = update_setup();
	dma.attachInterrupt(isr);
#endif
}
     614:	b508      	push	{r3, lr}
     616:	f64f 71ff 	movw	r1, #65535	; 0xffff
     61a:	2001      	movs	r0, #1
     61c:	f7ff ffe6 	bl	5ec <__static_initialization_and_destruction_0(int, int)>
     620:	bd08      	pop	{r3, pc}
		while (count) {
			uint32_t chip = (addr >> 16) + 1;
			digitalWriteFast(MEMBOARD_CS0_PIN, chip & 1);
			digitalWriteFast(MEMBOARD_CS1_PIN, chip & 2);
			digitalWriteFast(MEMBOARD_CS2_PIN, chip & 4);
			uint32_t chipaddr = (addr & 0xFFFF) << 1;
     622:	bf00      	nop

00000624 <__static_initialization_and_destruction_0(int, int)>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     624:	2801      	cmp	r0, #1
     626:	d10a      	bne.n	63e <__static_initialization_and_destruction_0(int, int)+0x1a>
     628:	b508      	push	{r3, lr}
     62a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     62e:	4299      	cmp	r1, r3
     630:	d104      	bne.n	63c <__static_initialization_and_destruction_0(int, int)+0x18>
DMAMEM __attribute__((aligned(32))) static uint32_t i2s2_rx_buffer[AUDIO_BLOCK_SAMPLES];
audio_block_t * AudioInputI2S2::block_left = NULL;
audio_block_t * AudioInputI2S2::block_right = NULL;
uint16_t AudioInputI2S2::block_offset = 0;
bool AudioInputI2S2::update_responsibility = false;
DMAChannel AudioInputI2S2::dma(false);
     632:	4a03      	ldr	r2, [pc, #12]	; (640 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     634:	4903      	ldr	r1, [pc, #12]	; (644 <__static_initialization_and_destruction_0(int, int)+0x20>)
     636:	4804      	ldr	r0, [pc, #16]	; (648 <__static_initialization_and_destruction_0(int, int)+0x24>)
     638:	f003 fcf6 	bl	4028 <__aeabi_atexit>
     63c:	bd08      	pop	{r3, pc}
     63e:	4770      	bx	lr
     640:	20000640 	.word	0x20000640
     644:	00000365 	.word	0x00000365
     648:	2000105c 	.word	0x2000105c

0000064c <_GLOBAL__sub_I__ZN14AudioInputI2S210block_leftE>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     64c:	b508      	push	{r3, lr}
     64e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     652:	2001      	movs	r0, #1
     654:	f7ff ffe6 	bl	624 <__static_initialization_and_destruction_0(int, int)>
     658:	bd08      	pop	{r3, pc}
		//while (!(port().SR & SPI_SR_TCF)) ; // wait
		//return port().POPR;
	}
	uint16_t transfer16(uint16_t data) {
		uint32_t tcr = port().TCR;
		port().TCR = (tcr & 0xfffff000) | LPSPI_TCR_FRAMESZ(15);  // turn on 16 bit mode 
     65a:	bf00      	nop

0000065c <__static_initialization_and_destruction_0(int, int)>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     65c:	2801      	cmp	r0, #1
     65e:	d10a      	bne.n	676 <__static_initialization_and_destruction_0(int, int)+0x1a>
     660:	b508      	push	{r3, lr}
     662:	f64f 73ff 	movw	r3, #65535	; 0xffff
     666:	4299      	cmp	r1, r3
     668:	d104      	bne.n	674 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioInputI2SHex::block_ch4 = NULL;
audio_block_t * AudioInputI2SHex::block_ch5 = NULL;
audio_block_t * AudioInputI2SHex::block_ch6 = NULL;
uint16_t AudioInputI2SHex::block_offset = 0;
bool AudioInputI2SHex::update_responsibility = false;
DMAChannel AudioInputI2SHex::dma(false);
     66a:	4a03      	ldr	r2, [pc, #12]	; (678 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     66c:	4903      	ldr	r1, [pc, #12]	; (67c <__static_initialization_and_destruction_0(int, int)+0x20>)
     66e:	4804      	ldr	r0, [pc, #16]	; (680 <__static_initialization_and_destruction_0(int, int)+0x24>)
     670:	f003 fcda 	bl	4028 <__aeabi_atexit>
     674:	bd08      	pop	{r3, pc}
     676:	4770      	bx	lr
     678:	20000640 	.word	0x20000640
     67c:	00000365 	.word	0x00000365
     680:	20001064 	.word	0x20001064

00000684 <_GLOBAL__sub_I__ZN16AudioInputI2SHex9block_ch1E>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     684:	b508      	push	{r3, lr}
     686:	f64f 71ff 	movw	r1, #65535	; 0xffff
     68a:	2001      	movs	r0, #1
     68c:	f7ff ffe6 	bl	65c <__static_initialization_and_destruction_0(int, int)>
     690:	bd08      	pop	{r3, pc}
     692:	bf00      	nop

00000694 <__static_initialization_and_destruction_0(int, int)>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     694:	2801      	cmp	r0, #1
     696:	d10a      	bne.n	6ae <__static_initialization_and_destruction_0(int, int)+0x1a>
     698:	b508      	push	{r3, lr}
     69a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     69e:	4299      	cmp	r1, r3
     6a0:	d104      	bne.n	6ac <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioInputI2SOct::block_ch6 = NULL;
audio_block_t * AudioInputI2SOct::block_ch7 = NULL;
audio_block_t * AudioInputI2SOct::block_ch8 = NULL;
uint16_t AudioInputI2SOct::block_offset = 0;
bool AudioInputI2SOct::update_responsibility = false;
DMAChannel AudioInputI2SOct::dma(false);
     6a2:	4a03      	ldr	r2, [pc, #12]	; (6b0 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     6a4:	4903      	ldr	r1, [pc, #12]	; (6b4 <__static_initialization_and_destruction_0(int, int)+0x20>)
     6a6:	4804      	ldr	r0, [pc, #16]	; (6b8 <__static_initialization_and_destruction_0(int, int)+0x24>)
     6a8:	f003 fcbe 	bl	4028 <__aeabi_atexit>
     6ac:	bd08      	pop	{r3, pc}
     6ae:	4770      	bx	lr
     6b0:	20000640 	.word	0x20000640
     6b4:	00000365 	.word	0x00000365
     6b8:	2000106c 	.word	0x2000106c

000006bc <_GLOBAL__sub_I__ZN16AudioInputI2SOct9block_ch1E>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     6bc:	b508      	push	{r3, lr}
     6be:	f64f 71ff 	movw	r1, #65535	; 0xffff
     6c2:	2001      	movs	r0, #1
     6c4:	f7ff ffe6 	bl	694 <__static_initialization_and_destruction_0(int, int)>
     6c8:	bd08      	pop	{r3, pc}
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
     6ca:	bf00      	nop

000006cc <__static_initialization_and_destruction_0(int, int)>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     6cc:	2801      	cmp	r0, #1
     6ce:	d10a      	bne.n	6e6 <__static_initialization_and_destruction_0(int, int)+0x1a>
     6d0:	b508      	push	{r3, lr}
     6d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
     6d6:	4299      	cmp	r1, r3
     6d8:	d104      	bne.n	6e4 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioInputI2SQuad::block_ch2 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch3 = NULL;
audio_block_t * AudioInputI2SQuad::block_ch4 = NULL;
uint16_t AudioInputI2SQuad::block_offset = 0;
bool AudioInputI2SQuad::update_responsibility = false;
DMAChannel AudioInputI2SQuad::dma(false);
     6da:	4a03      	ldr	r2, [pc, #12]	; (6e8 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     6dc:	4903      	ldr	r1, [pc, #12]	; (6ec <__static_initialization_and_destruction_0(int, int)+0x20>)
     6de:	4804      	ldr	r0, [pc, #16]	; (6f0 <__static_initialization_and_destruction_0(int, int)+0x24>)
     6e0:	f003 fca2 	bl	4028 <__aeabi_atexit>
     6e4:	bd08      	pop	{r3, pc}
     6e6:	4770      	bx	lr
     6e8:	20000640 	.word	0x20000640
     6ec:	00000365 	.word	0x00000365
     6f0:	20001074 	.word	0x20001074

000006f4 <_GLOBAL__sub_I__ZN17AudioInputI2SQuad9block_ch1E>:
		// The DMA didn't fill blocks, and we could not allocate
		// memory... the system is likely starving for memory!
		// Sadly, there's nothing we can do.
		__enable_irq();
	}
}
     6f4:	b508      	push	{r3, lr}
     6f6:	f64f 71ff 	movw	r1, #65535	; 0xffff
     6fa:	2001      	movs	r0, #1
     6fc:	f7ff ffe6 	bl	6cc <__static_initialization_and_destruction_0(int, int)>
     700:	bd08      	pop	{r3, pc}
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
     702:	bf00      	nop

00000704 <__static_initialization_and_destruction_0(int, int)>:
}

unsigned int AudioInputSPDIF3::sampleRate(void) {
	if (!pllLocked()) return 0;
	return (float)((uint64_t)F_BUS_ACTUAL * SPDIF_SRFM) / (0x8000000ULL * AudioOutputSPDIF3::dpll_Gain()) + 0.5F;
}
     704:	2801      	cmp	r0, #1
     706:	d10a      	bne.n	71e <__static_initialization_and_destruction_0(int, int)+0x1a>
     708:	b508      	push	{r3, lr}
     70a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     70e:	4299      	cmp	r1, r3
     710:	d104      	bne.n	71c <__static_initialization_and_destruction_0(int, int)+0x18>
static uint32_t spdif_rx_buffer[AUDIO_BLOCK_SAMPLES * 4];
audio_block_t * AudioInputSPDIF3::block_left = NULL;
audio_block_t * AudioInputSPDIF3::block_right = NULL;
uint16_t AudioInputSPDIF3::block_offset = 0;
bool AudioInputSPDIF3::update_responsibility = false;
DMAChannel AudioInputSPDIF3::dma(false);
     712:	4a03      	ldr	r2, [pc, #12]	; (720 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     714:	4903      	ldr	r1, [pc, #12]	; (724 <__static_initialization_and_destruction_0(int, int)+0x20>)
     716:	4804      	ldr	r0, [pc, #16]	; (728 <__static_initialization_and_destruction_0(int, int)+0x24>)
     718:	f003 fc86 	bl	4028 <__aeabi_atexit>
     71c:	bd08      	pop	{r3, pc}
     71e:	4770      	bx	lr
     720:	20000640 	.word	0x20000640
     724:	00000365 	.word	0x00000365
     728:	2000107c 	.word	0x2000107c

0000072c <_GLOBAL__sub_I__ZN16AudioInputSPDIF310block_leftE>:
}

unsigned int AudioInputSPDIF3::sampleRate(void) {
	if (!pllLocked()) return 0;
	return (float)((uint64_t)F_BUS_ACTUAL * SPDIF_SRFM) / (0x8000000ULL * AudioOutputSPDIF3::dpll_Gain()) + 0.5F;
}
     72c:	b508      	push	{r3, lr}
     72e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     732:	2001      	movs	r0, #1
     734:	f7ff ffe6 	bl	704 <__static_initialization_and_destruction_0(int, int)>
     738:	bd08      	pop	{r3, pc}
		digitalWriteFast(MEMBOARD_CS1_PIN, LOW);
		digitalWriteFast(MEMBOARD_CS2_PIN, LOW);
		SPI.endTransaction();
	}
#endif
}
     73a:	bf00      	nop

0000073c <__static_initialization_and_destruction_0(int, int)>:
		for (i=0; i < 16; i++) {
			transmit(out_block[i], i);
			release(out_block[i]);
		}
	}
}
     73c:	2801      	cmp	r0, #1
     73e:	d10a      	bne.n	756 <__static_initialization_and_destruction_0(int, int)+0x1a>
     740:	b508      	push	{r3, lr}
     742:	f64f 73ff 	movw	r3, #65535	; 0xffff
     746:	4299      	cmp	r1, r3
     748:	d104      	bne.n	754 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioInputTDM::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM::update_responsibility = false;
DMAChannel AudioInputTDM::dma(false);
     74a:	4a03      	ldr	r2, [pc, #12]	; (758 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     74c:	4903      	ldr	r1, [pc, #12]	; (75c <__static_initialization_and_destruction_0(int, int)+0x20>)
     74e:	4804      	ldr	r0, [pc, #16]	; (760 <__static_initialization_and_destruction_0(int, int)+0x24>)
     750:	f003 fc6a 	bl	4028 <__aeabi_atexit>
     754:	bd08      	pop	{r3, pc}
     756:	4770      	bx	lr
     758:	20000640 	.word	0x20000640
     75c:	00000365 	.word	0x00000365
     760:	20001084 	.word	0x20001084

00000764 <_GLOBAL__sub_I__ZN13AudioInputTDM14block_incomingE>:
		for (i=0; i < 16; i++) {
			transmit(out_block[i], i);
			release(out_block[i]);
		}
	}
}
     764:	b508      	push	{r3, lr}
     766:	f64f 71ff 	movw	r1, #65535	; 0xffff
     76a:	2001      	movs	r0, #1
     76c:	f7ff ffe6 	bl	73c <__static_initialization_and_destruction_0(int, int)>
     770:	bd08      	pop	{r3, pc}
     772:	bf00      	nop

00000774 <__static_initialization_and_destruction_0(int, int)>:
		for (i=0; i < 16; i++) {
			transmit(out_block[i], i);
			release(out_block[i]);
		}
	}
}
     774:	2801      	cmp	r0, #1
     776:	d10a      	bne.n	78e <__static_initialization_and_destruction_0(int, int)+0x1a>
     778:	b508      	push	{r3, lr}
     77a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     77e:	4299      	cmp	r1, r3
     780:	d104      	bne.n	78c <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioInputTDM2::block_incoming[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioInputTDM2::update_responsibility = false;
DMAChannel AudioInputTDM2::dma(false);
     782:	4a03      	ldr	r2, [pc, #12]	; (790 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     784:	4903      	ldr	r1, [pc, #12]	; (794 <__static_initialization_and_destruction_0(int, int)+0x20>)
     786:	4804      	ldr	r0, [pc, #16]	; (798 <__static_initialization_and_destruction_0(int, int)+0x24>)
     788:	f003 fc4e 	bl	4028 <__aeabi_atexit>
     78c:	bd08      	pop	{r3, pc}
     78e:	4770      	bx	lr
     790:	20000640 	.word	0x20000640
     794:	00000365 	.word	0x00000365
     798:	2000108c 	.word	0x2000108c

0000079c <_GLOBAL__sub_I__ZN14AudioInputTDM214block_incomingE>:
		for (i=0; i < 16; i++) {
			transmit(out_block[i], i);
			release(out_block[i]);
		}
	}
}
     79c:	b508      	push	{r3, lr}
     79e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     7a2:	2001      	movs	r0, #1
     7a4:	f7ff ffe6 	bl	774 <__static_initialization_and_destruction_0(int, int)>
     7a8:	bd08      	pop	{r3, pc}
     7aa:	bf00      	nop

000007ac <__static_initialization_and_destruction_0(int, int)>:
	I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP;
	I2S1_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

#endif
}
     7ac:	2801      	cmp	r0, #1
     7ae:	d10a      	bne.n	7c6 <__static_initialization_and_destruction_0(int, int)+0x1a>
     7b0:	b508      	push	{r3, lr}
     7b2:	f64f 73ff 	movw	r3, #65535	; 0xffff
     7b6:	4299      	cmp	r1, r3
     7b8:	d104      	bne.n	7c4 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputI2S::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S::block_right_2nd = NULL;
uint16_t  AudioOutputI2S::block_left_offset = 0;
uint16_t  AudioOutputI2S::block_right_offset = 0;
bool AudioOutputI2S::update_responsibility = false;
DMAChannel AudioOutputI2S::dma(false);
     7ba:	4a03      	ldr	r2, [pc, #12]	; (7c8 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     7bc:	4903      	ldr	r1, [pc, #12]	; (7cc <__static_initialization_and_destruction_0(int, int)+0x20>)
     7be:	4804      	ldr	r0, [pc, #16]	; (7d0 <__static_initialization_and_destruction_0(int, int)+0x24>)
     7c0:	f003 fc32 	bl	4028 <__aeabi_atexit>
     7c4:	bd08      	pop	{r3, pc}
     7c6:	4770      	bx	lr
     7c8:	20000640 	.word	0x20000640
     7cc:	00000365 	.word	0x00000365
     7d0:	20001094 	.word	0x20001094

000007d4 <_GLOBAL__sub_I__ZN14AudioOutputI2S14block_left_1stE>:
	I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP;
	I2S1_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

#endif
}
     7d4:	b508      	push	{r3, lr}
     7d6:	f64f 71ff 	movw	r1, #65535	; 0xffff
     7da:	2001      	movs	r0, #1
     7dc:	f7ff ffe6 	bl	7ac <__static_initialization_and_destruction_0(int, int)>
     7e0:	bd08      	pop	{r3, pc}
     7e2:	bf00      	nop

000007e4 <__static_initialization_and_destruction_0(int, int)>:
	I2S2_RCR3 = I2S_RCR3_RCE;
	I2S2_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S2_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));

}
     7e4:	2801      	cmp	r0, #1
     7e6:	d10a      	bne.n	7fe <__static_initialization_and_destruction_0(int, int)+0x1a>
     7e8:	b508      	push	{r3, lr}
     7ea:	f64f 73ff 	movw	r3, #65535	; 0xffff
     7ee:	4299      	cmp	r1, r3
     7f0:	d104      	bne.n	7fc <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputI2S2::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S2::block_right_2nd = NULL;
uint16_t  AudioOutputI2S2::block_left_offset = 0;
uint16_t  AudioOutputI2S2::block_right_offset = 0;
bool AudioOutputI2S2::update_responsibility = false;
DMAChannel AudioOutputI2S2::dma(false);
     7f2:	4a03      	ldr	r2, [pc, #12]	; (800 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     7f4:	4903      	ldr	r1, [pc, #12]	; (804 <__static_initialization_and_destruction_0(int, int)+0x20>)
     7f6:	4804      	ldr	r0, [pc, #16]	; (808 <__static_initialization_and_destruction_0(int, int)+0x24>)
     7f8:	f003 fc16 	bl	4028 <__aeabi_atexit>
     7fc:	bd08      	pop	{r3, pc}
     7fe:	4770      	bx	lr
     800:	20000640 	.word	0x20000640
     804:	00000365 	.word	0x00000365
     808:	2000109c 	.word	0x2000109c

0000080c <_GLOBAL__sub_I__ZN15AudioOutputI2S214block_left_1stE>:
	I2S2_RCR3 = I2S_RCR3_RCE;
	I2S2_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
		| I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
	I2S2_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));

}
     80c:	b508      	push	{r3, lr}
     80e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     812:	2001      	movs	r0, #1
     814:	f7ff ffe6 	bl	7e4 <__static_initialization_and_destruction_0(int, int)>
     818:	bd08      	pop	{r3, pc}
     81a:	bf00      	nop

0000081c <__static_initialization_and_destruction_0(int, int)>:
			ch6_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     81c:	2801      	cmp	r0, #1
     81e:	d10a      	bne.n	836 <__static_initialization_and_destruction_0(int, int)+0x1a>
     820:	b508      	push	{r3, lr}
     822:	f64f 73ff 	movw	r3, #65535	; 0xffff
     826:	4299      	cmp	r1, r3
     828:	d104      	bne.n	834 <__static_initialization_and_destruction_0(int, int)+0x18>
uint16_t  AudioOutputI2SHex::ch4_offset = 0;
uint16_t  AudioOutputI2SHex::ch5_offset = 0;
uint16_t  AudioOutputI2SHex::ch6_offset = 0;
bool AudioOutputI2SHex::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*3];
DMAChannel AudioOutputI2SHex::dma(false);
     82a:	4a03      	ldr	r2, [pc, #12]	; (838 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     82c:	4903      	ldr	r1, [pc, #12]	; (83c <__static_initialization_and_destruction_0(int, int)+0x20>)
     82e:	4804      	ldr	r0, [pc, #16]	; (840 <__static_initialization_and_destruction_0(int, int)+0x24>)
     830:	f003 fbfa 	bl	4028 <__aeabi_atexit>
     834:	bd08      	pop	{r3, pc}
     836:	4770      	bx	lr
     838:	20000640 	.word	0x20000640
     83c:	00000365 	.word	0x00000365
     840:	200010a4 	.word	0x200010a4

00000844 <_GLOBAL__sub_I__ZN17AudioOutputI2SHex13block_ch1_1stE>:
			ch6_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     844:	b508      	push	{r3, lr}
     846:	f64f 71ff 	movw	r1, #65535	; 0xffff
     84a:	2001      	movs	r0, #1
     84c:	f7ff ffe6 	bl	81c <__static_initialization_and_destruction_0(int, int)>
     850:	bd08      	pop	{r3, pc}
     852:	bf00      	nop

00000854 <__static_initialization_and_destruction_0(int, int)>:
			ch8_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     854:	2801      	cmp	r0, #1
     856:	d10a      	bne.n	86e <__static_initialization_and_destruction_0(int, int)+0x1a>
     858:	b508      	push	{r3, lr}
     85a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     85e:	4299      	cmp	r1, r3
     860:	d104      	bne.n	86c <__static_initialization_and_destruction_0(int, int)+0x18>
uint16_t  AudioOutputI2SOct::ch6_offset = 0;
uint16_t  AudioOutputI2SOct::ch7_offset = 0;
uint16_t  AudioOutputI2SOct::ch8_offset = 0;
bool AudioOutputI2SOct::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
DMAChannel AudioOutputI2SOct::dma(false);
     862:	4a03      	ldr	r2, [pc, #12]	; (870 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     864:	4903      	ldr	r1, [pc, #12]	; (874 <__static_initialization_and_destruction_0(int, int)+0x20>)
     866:	4804      	ldr	r0, [pc, #16]	; (878 <__static_initialization_and_destruction_0(int, int)+0x24>)
     868:	f003 fbde 	bl	4028 <__aeabi_atexit>
     86c:	bd08      	pop	{r3, pc}
     86e:	4770      	bx	lr
     870:	20000640 	.word	0x20000640
     874:	00000365 	.word	0x00000365
     878:	200010ac 	.word	0x200010ac

0000087c <_GLOBAL__sub_I__ZN17AudioOutputI2SOct13block_ch1_1stE>:
			ch8_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     87c:	b508      	push	{r3, lr}
     87e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     882:	2001      	movs	r0, #1
     884:	f7ff ffe6 	bl	854 <__static_initialization_and_destruction_0(int, int)>
     888:	bd08      	pop	{r3, pc}
     88a:	bf00      	nop

0000088c <__static_initialization_and_destruction_0(int, int)>:
			ch4_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     88c:	2801      	cmp	r0, #1
     88e:	d10a      	bne.n	8a6 <__static_initialization_and_destruction_0(int, int)+0x1a>
     890:	b508      	push	{r3, lr}
     892:	f64f 73ff 	movw	r3, #65535	; 0xffff
     896:	4299      	cmp	r1, r3
     898:	d104      	bne.n	8a4 <__static_initialization_and_destruction_0(int, int)+0x18>
uint16_t  AudioOutputI2SQuad::ch2_offset = 0;
uint16_t  AudioOutputI2SQuad::ch3_offset = 0;
uint16_t  AudioOutputI2SQuad::ch4_offset = 0;
bool AudioOutputI2SQuad::update_responsibility = false;
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*2];
DMAChannel AudioOutputI2SQuad::dma(false);
     89a:	4a03      	ldr	r2, [pc, #12]	; (8a8 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     89c:	4903      	ldr	r1, [pc, #12]	; (8ac <__static_initialization_and_destruction_0(int, int)+0x20>)
     89e:	4804      	ldr	r0, [pc, #16]	; (8b0 <__static_initialization_and_destruction_0(int, int)+0x24>)
     8a0:	f003 fbc2 	bl	4028 <__aeabi_atexit>
     8a4:	bd08      	pop	{r3, pc}
     8a6:	4770      	bx	lr
     8a8:	20000640 	.word	0x20000640
     8ac:	00000365 	.word	0x00000365
     8b0:	200010b4 	.word	0x200010b4

000008b4 <_GLOBAL__sub_I__ZN18AudioOutputI2SQuad13block_ch1_1stE>:
			ch4_offset = 0;
			__enable_irq();
			release(tmp);
		}
	}
}
     8b4:	b508      	push	{r3, lr}
     8b6:	f64f 71ff 	movw	r1, #65535	; 0xffff
     8ba:	2001      	movs	r0, #1
     8bc:	f7ff ffe6 	bl	88c <__static_initialization_and_destruction_0(int, int)>
     8c0:	bd08      	pop	{r3, pc}
     8c2:	bf00      	nop

000008c4 <__static_initialization_and_destruction_0(int, int)>:
	I2S3_TCR2 = I2S_TCR2_SYNC(0) /*| I2S_TCR2_BCP*/ // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((7)) | I2S_TCR2_MSEL(1));
	I2S3_TCR3 = I2S_TCR3_TCE;
	I2S3_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((16-1)) | I2S_TCR4_MF | I2S_TCR4_FSD /*| I2S_TCR4_FSE*/ /* | I2S_TCR4_FSP */;
	I2S3_TCR5 = I2S_TCR5_WNW((16-1)) | I2S_TCR5_W0W((16-1)) | I2S_TCR5_FBT((16-1));
}
     8c4:	2801      	cmp	r0, #1
     8c6:	d10a      	bne.n	8de <__static_initialization_and_destruction_0(int, int)+0x1a>
     8c8:	b508      	push	{r3, lr}
     8ca:	f64f 73ff 	movw	r3, #65535	; 0xffff
     8ce:	4299      	cmp	r1, r3
     8d0:	d104      	bne.n	8dc <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputMQS::block_left_2nd = NULL;
audio_block_t * AudioOutputMQS::block_right_2nd = NULL;
uint16_t  AudioOutputMQS::block_left_offset = 0;
uint16_t  AudioOutputMQS::block_right_offset = 0;
bool AudioOutputMQS::update_responsibility = false;
DMAChannel AudioOutputMQS::dma(false);
     8d2:	4a03      	ldr	r2, [pc, #12]	; (8e0 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     8d4:	4903      	ldr	r1, [pc, #12]	; (8e4 <__static_initialization_and_destruction_0(int, int)+0x20>)
     8d6:	4804      	ldr	r0, [pc, #16]	; (8e8 <__static_initialization_and_destruction_0(int, int)+0x24>)
     8d8:	f003 fba6 	bl	4028 <__aeabi_atexit>
     8dc:	bd08      	pop	{r3, pc}
     8de:	4770      	bx	lr
     8e0:	20000640 	.word	0x20000640
     8e4:	00000365 	.word	0x00000365
     8e8:	200010bc 	.word	0x200010bc

000008ec <_GLOBAL__sub_I__ZN14AudioOutputMQS14block_left_1stE>:
	I2S3_TCR2 = I2S_TCR2_SYNC(0) /*| I2S_TCR2_BCP*/ // sync=0; tx is async;
		    | (I2S_TCR2_BCD | I2S_TCR2_DIV((7)) | I2S_TCR2_MSEL(1));
	I2S3_TCR3 = I2S_TCR3_TCE;
	I2S3_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((16-1)) | I2S_TCR4_MF | I2S_TCR4_FSD /*| I2S_TCR4_FSE*/ /* | I2S_TCR4_FSP */;
	I2S3_TCR5 = I2S_TCR5_WNW((16-1)) | I2S_TCR5_W0W((16-1)) | I2S_TCR5_FBT((16-1));
}
     8ec:	b508      	push	{r3, lr}
     8ee:	f64f 71ff 	movw	r1, #65535	; 0xffff
     8f2:	2001      	movs	r0, #1
     8f4:	f7ff ffe6 	bl	8c4 <__static_initialization_and_destruction_0(int, int)>
     8f8:	bd08      	pop	{r3, pc}
     8fa:	bf00      	nop

000008fc <__static_initialization_and_destruction_0(int, int)>:
//	I2S1_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD; //TDA1543	
	I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(15) | I2S_RCR4_MF /*| I2S_RCR4_FSE*/ | I2S_RCR4_FSP | I2S_RCR4_FSD; //PT8211
	I2S1_RCR5 = I2S_RCR5_WNW(15) | I2S_RCR5_W0W(15) | I2S_RCR5_FBT(15);

#endif
}
     8fc:	2801      	cmp	r0, #1
     8fe:	d10a      	bne.n	916 <__static_initialization_and_destruction_0(int, int)+0x1a>
     900:	b508      	push	{r3, lr}
     902:	f64f 73ff 	movw	r3, #65535	; 0xffff
     906:	4299      	cmp	r1, r3
     908:	d104      	bne.n	914 <__static_initialization_and_destruction_0(int, int)+0x18>
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211::dma(false);
     90a:	4a03      	ldr	r2, [pc, #12]	; (918 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     90c:	4903      	ldr	r1, [pc, #12]	; (91c <__static_initialization_and_destruction_0(int, int)+0x20>)
     90e:	4804      	ldr	r0, [pc, #16]	; (920 <__static_initialization_and_destruction_0(int, int)+0x24>)
     910:	f003 fb8a 	bl	4028 <__aeabi_atexit>
     914:	bd08      	pop	{r3, pc}
     916:	4770      	bx	lr
     918:	20000640 	.word	0x20000640
     91c:	00000365 	.word	0x00000365
     920:	200010c4 	.word	0x200010c4

00000924 <_GLOBAL__sub_I__ZN17AudioOutputPT821114block_left_1stE>:
//	I2S1_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD; //TDA1543	
	I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(15) | I2S_RCR4_MF /*| I2S_RCR4_FSE*/ | I2S_RCR4_FSP | I2S_RCR4_FSD; //PT8211
	I2S1_RCR5 = I2S_RCR5_WNW(15) | I2S_RCR5_W0W(15) | I2S_RCR5_FBT(15);

#endif
}
     924:	b508      	push	{r3, lr}
     926:	f64f 71ff 	movw	r1, #65535	; 0xffff
     92a:	2001      	movs	r0, #1
     92c:	f7ff ffe6 	bl	8fc <__static_initialization_and_destruction_0(int, int)>
     930:	bd08      	pop	{r3, pc}
     932:	bf00      	nop

00000934 <__static_initialization_and_destruction_0(int, int)>:
	I2S2_TCR3 = I2S_TCR3_TCE;
//	I2S2_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD; //TDA1543
	I2S2_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF /*| I2S_TCR4_FSE*/ | I2S_TCR4_FSP | I2S_TCR4_FSD; //PT8211
	I2S2_TCR5 = I2S_TCR5_WNW(15) | I2S_TCR5_W0W(15) | I2S_TCR5_FBT(15);

}
     934:	2801      	cmp	r0, #1
     936:	d10a      	bne.n	94e <__static_initialization_and_destruction_0(int, int)+0x1a>
     938:	b508      	push	{r3, lr}
     93a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     93e:	4299      	cmp	r1, r3
     940:	d104      	bne.n	94c <__static_initialization_and_destruction_0(int, int)+0x18>
#if defined(AUDIO_PT8211_OVERSAMPLING)
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES*4];
#else
DMAMEM __attribute__((aligned(32))) static uint32_t i2s_tx_buffer[AUDIO_BLOCK_SAMPLES];
#endif
DMAChannel AudioOutputPT8211_2::dma(false);
     942:	4a03      	ldr	r2, [pc, #12]	; (950 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     944:	4903      	ldr	r1, [pc, #12]	; (954 <__static_initialization_and_destruction_0(int, int)+0x20>)
     946:	4804      	ldr	r0, [pc, #16]	; (958 <__static_initialization_and_destruction_0(int, int)+0x24>)
     948:	f003 fb6e 	bl	4028 <__aeabi_atexit>
     94c:	bd08      	pop	{r3, pc}
     94e:	4770      	bx	lr
     950:	20000640 	.word	0x20000640
     954:	00000365 	.word	0x00000365
     958:	200010cc 	.word	0x200010cc

0000095c <_GLOBAL__sub_I__ZN19AudioOutputPT8211_214block_left_1stE>:
	I2S2_TCR3 = I2S_TCR3_TCE;
//	I2S2_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF | I2S_TCR4_FSE | I2S_TCR4_FSP | I2S_TCR4_FSD; //TDA1543
	I2S2_TCR4 = I2S_TCR4_FRSZ(1) | I2S_TCR4_SYWD(15) | I2S_TCR4_MF /*| I2S_TCR4_FSE*/ | I2S_TCR4_FSP | I2S_TCR4_FSD; //PT8211
	I2S2_TCR5 = I2S_TCR5_WNW(15) | I2S_TCR5_W0W(15) | I2S_TCR5_FBT(15);

}
     95c:	b508      	push	{r3, lr}
     95e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     962:	2001      	movs	r0, #1
     964:	f7ff ffe6 	bl	934 <__static_initialization_and_destruction_0(int, int)>
     968:	bd08      	pop	{r3, pc}
     96a:	bf00      	nop

0000096c <__static_initialization_and_destruction_0(int, int)>:
//	CORE_PIN6_CONFIG  = 3;  //1:TX_DATA0
//	CORE_PIN7_CONFIG  = 3;  //1:RX_DATA0
#endif

#endif
}
     96c:	2801      	cmp	r0, #1
     96e:	d10a      	bne.n	986 <__static_initialization_and_destruction_0(int, int)+0x1a>
     970:	b508      	push	{r3, lr}
     972:	f64f 73ff 	movw	r3, #65535	; 0xffff
     976:	4299      	cmp	r1, r3
     978:	d104      	bne.n	984 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputSPDIF::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF::block_left_offset = 0;
uint16_t  AudioOutputSPDIF::block_right_offset = 0;
bool AudioOutputSPDIF::update_responsibility = false;
DMAChannel AudioOutputSPDIF::dma(false);
     97a:	4a03      	ldr	r2, [pc, #12]	; (988 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     97c:	4903      	ldr	r1, [pc, #12]	; (98c <__static_initialization_and_destruction_0(int, int)+0x20>)
     97e:	4804      	ldr	r0, [pc, #16]	; (990 <__static_initialization_and_destruction_0(int, int)+0x24>)
     980:	f003 fb52 	bl	4028 <__aeabi_atexit>
     984:	bd08      	pop	{r3, pc}
     986:	4770      	bx	lr
     988:	20000640 	.word	0x20000640
     98c:	00000365 	.word	0x00000365
     990:	200010d4 	.word	0x200010d4

00000994 <_GLOBAL__sub_I__ZN16AudioOutputSPDIF14block_left_1stE>:
//	CORE_PIN6_CONFIG  = 3;  //1:TX_DATA0
//	CORE_PIN7_CONFIG  = 3;  //1:RX_DATA0
#endif

#endif
}
     994:	b508      	push	{r3, lr}
     996:	f64f 71ff 	movw	r1, #65535	; 0xffff
     99a:	2001      	movs	r0, #1
     99c:	f7ff ffe6 	bl	96c <__static_initialization_and_destruction_0(int, int)>
     9a0:	bd08      	pop	{r3, pc}
     9a2:	bf00      	nop

000009a4 <__static_initialization_and_destruction_0(int, int)>:
	//debug only:
	CORE_PIN5_CONFIG  = 2;  //2:MCLK	11.43MHz
	CORE_PIN4_CONFIG  = 2;  //2:TX_BCLK	5 MHz
	CORE_PIN3_CONFIG  = 2;  //2:TX_SYNC	44.1 KHz
#endif
}
     9a4:	2801      	cmp	r0, #1
     9a6:	d10a      	bne.n	9be <__static_initialization_and_destruction_0(int, int)+0x1a>
     9a8:	b508      	push	{r3, lr}
     9aa:	f64f 73ff 	movw	r3, #65535	; 0xffff
     9ae:	4299      	cmp	r1, r3
     9b0:	d104      	bne.n	9bc <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputSPDIF2::block_left_2nd = NULL;
audio_block_t * AudioOutputSPDIF2::block_right_2nd = NULL;
uint16_t  AudioOutputSPDIF2::block_left_offset = 0;
uint16_t  AudioOutputSPDIF2::block_right_offset = 0;
bool AudioOutputSPDIF2::update_responsibility = false;
DMAChannel AudioOutputSPDIF2::dma(false);
     9b2:	4a03      	ldr	r2, [pc, #12]	; (9c0 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     9b4:	4903      	ldr	r1, [pc, #12]	; (9c4 <__static_initialization_and_destruction_0(int, int)+0x20>)
     9b6:	4804      	ldr	r0, [pc, #16]	; (9c8 <__static_initialization_and_destruction_0(int, int)+0x24>)
     9b8:	f003 fb36 	bl	4028 <__aeabi_atexit>
     9bc:	bd08      	pop	{r3, pc}
     9be:	4770      	bx	lr
     9c0:	20000640 	.word	0x20000640
     9c4:	00000365 	.word	0x00000365
     9c8:	200010dc 	.word	0x200010dc

000009cc <_GLOBAL__sub_I__ZN17AudioOutputSPDIF214block_left_1stE>:
	//debug only:
	CORE_PIN5_CONFIG  = 2;  //2:MCLK	11.43MHz
	CORE_PIN4_CONFIG  = 2;  //2:TX_BCLK	5 MHz
	CORE_PIN3_CONFIG  = 2;  //2:TX_SYNC	44.1 KHz
#endif
}
     9cc:	b508      	push	{r3, lr}
     9ce:	f64f 71ff 	movw	r1, #65535	; 0xffff
     9d2:	2001      	movs	r0, #1
     9d4:	f7ff ffe6 	bl	9a4 <__static_initialization_and_destruction_0(int, int)>
     9d8:	bd08      	pop	{r3, pc}
     9da:	bf00      	nop

000009dc <__static_initialization_and_destruction_0(int, int)>:
#endif

	SPDIF_STC =
		SPDIF_STC_TXCLK_SOURCE(1) |	//tx_clk input (from SPDIF0_CLK_ROOT)
		SPDIF_STC_TXCLK_DF(clkdiv - 1);
}
     9dc:	2801      	cmp	r0, #1
     9de:	d10a      	bne.n	9f6 <__static_initialization_and_destruction_0(int, int)+0x1a>
     9e0:	b508      	push	{r3, lr}
     9e2:	f64f 73ff 	movw	r3, #65535	; 0xffff
     9e6:	4299      	cmp	r1, r3
     9e8:	d104      	bne.n	9f4 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputSPDIF3::block_left_1st = nullptr;
audio_block_t * AudioOutputSPDIF3::block_right_1st = nullptr;
audio_block_t * AudioOutputSPDIF3::block_left_2nd = nullptr;
audio_block_t * AudioOutputSPDIF3::block_right_2nd = nullptr;
bool AudioOutputSPDIF3::update_responsibility = false;
DMAChannel AudioOutputSPDIF3::dma(false);
     9ea:	4a03      	ldr	r2, [pc, #12]	; (9f8 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     9ec:	4903      	ldr	r1, [pc, #12]	; (9fc <__static_initialization_and_destruction_0(int, int)+0x20>)
     9ee:	4804      	ldr	r0, [pc, #16]	; (a00 <__static_initialization_and_destruction_0(int, int)+0x24>)
     9f0:	f003 fb1a 	bl	4028 <__aeabi_atexit>
     9f4:	bd08      	pop	{r3, pc}
     9f6:	4770      	bx	lr
     9f8:	20000640 	.word	0x20000640
     9fc:	00000365 	.word	0x00000365
     a00:	200010e4 	.word	0x200010e4

00000a04 <_GLOBAL__sub_I__ZN17AudioOutputSPDIF314block_left_1stE>:
#endif

	SPDIF_STC =
		SPDIF_STC_TXCLK_SOURCE(1) |	//tx_clk input (from SPDIF0_CLK_ROOT)
		SPDIF_STC_TXCLK_DF(clkdiv - 1);
}
     a04:	b508      	push	{r3, lr}
     a06:	f64f 71ff 	movw	r1, #65535	; 0xffff
     a0a:	2001      	movs	r0, #1
     a0c:	f7ff ffe6 	bl	9dc <__static_initialization_and_destruction_0(int, int)>
     a10:	bd08      	pop	{r3, pc}
     a12:	bf00      	nop

00000a14 <__static_initialization_and_destruction_0(int, int)>:

	CORE_PIN23_CONFIG = 3;  //1:MCLK
	CORE_PIN21_CONFIG = 3;  //1:RX_BCLK
	CORE_PIN20_CONFIG = 3;  //1:RX_SYNC
#endif
}
     a14:	2801      	cmp	r0, #1
     a16:	d10a      	bne.n	a2e <__static_initialization_and_destruction_0(int, int)+0x1a>
     a18:	b508      	push	{r3, lr}
     a1a:	f64f 73ff 	movw	r3, #65535	; 0xffff
     a1e:	4299      	cmp	r1, r3
     a20:	d104      	bne.n	a2c <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputTDM::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM::update_responsibility = false;
DMAChannel AudioOutputTDM::dma(false);
     a22:	4a03      	ldr	r2, [pc, #12]	; (a30 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     a24:	4903      	ldr	r1, [pc, #12]	; (a34 <__static_initialization_and_destruction_0(int, int)+0x20>)
     a26:	4804      	ldr	r0, [pc, #16]	; (a38 <__static_initialization_and_destruction_0(int, int)+0x24>)
     a28:	f003 fafe 	bl	4028 <__aeabi_atexit>
     a2c:	bd08      	pop	{r3, pc}
     a2e:	4770      	bx	lr
     a30:	20000640 	.word	0x20000640
     a34:	00000365 	.word	0x00000365
     a38:	200010ec 	.word	0x200010ec

00000a3c <_GLOBAL__sub_I__ZN14AudioOutputTDM11block_inputE>:

	CORE_PIN23_CONFIG = 3;  //1:MCLK
	CORE_PIN21_CONFIG = 3;  //1:RX_BCLK
	CORE_PIN20_CONFIG = 3;  //1:RX_SYNC
#endif
}
     a3c:	b508      	push	{r3, lr}
     a3e:	f64f 71ff 	movw	r1, #65535	; 0xffff
     a42:	2001      	movs	r0, #1
     a44:	f7ff ffe6 	bl	a14 <__static_initialization_and_destruction_0(int, int)>
     a48:	bd08      	pop	{r3, pc}
     a4a:	bf00      	nop

00000a4c <__static_initialization_and_destruction_0(int, int)>:
	I2S2_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	CORE_PIN33_CONFIG = 2;  //2:MCLK
	CORE_PIN4_CONFIG  = 2;  //2:TX_BCLK
	CORE_PIN3_CONFIG  = 2;  //2:TX_SYNC
}
     a4c:	2801      	cmp	r0, #1
     a4e:	d10a      	bne.n	a66 <__static_initialization_and_destruction_0(int, int)+0x1a>
     a50:	b508      	push	{r3, lr}
     a52:	f64f 73ff 	movw	r3, #65535	; 0xffff
     a56:	4299      	cmp	r1, r3
     a58:	d104      	bne.n	a64 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputTDM2::block_input[16] = {
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
	nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr
};
bool AudioOutputTDM2::update_responsibility = false;
DMAChannel AudioOutputTDM2::dma(false);
     a5a:	4a03      	ldr	r2, [pc, #12]	; (a68 <__static_initialization_and_destruction_0(int, int)+0x1c>)
     a5c:	4903      	ldr	r1, [pc, #12]	; (a6c <__static_initialization_and_destruction_0(int, int)+0x20>)
     a5e:	4804      	ldr	r0, [pc, #16]	; (a70 <__static_initialization_and_destruction_0(int, int)+0x24>)
     a60:	f003 fae2 	bl	4028 <__aeabi_atexit>
     a64:	bd08      	pop	{r3, pc}
     a66:	4770      	bx	lr
     a68:	20000640 	.word	0x20000640
     a6c:	00000365 	.word	0x00000365
     a70:	200010f4 	.word	0x200010f4

00000a74 <_GLOBAL__sub_I__ZN15AudioOutputTDM211block_inputE>:
	I2S2_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

	CORE_PIN33_CONFIG = 2;  //2:MCLK
	CORE_PIN4_CONFIG  = 2;  //2:TX_BCLK
	CORE_PIN3_CONFIG  = 2;  //2:TX_SYNC
}
     a74:	b508      	push	{r3, lr}
     a76:	f64f 71ff 	movw	r1, #65535	; 0xffff
     a7a:	2001      	movs	r0, #1
     a7c:	f7ff ffe6 	bl	a4c <__static_initialization_and_destruction_0(int, int)>
     a80:	bd08      	pop	{r3, pc}
     a82:	bf00      	nop

00000a84 <_spi_dma_rxISR0()>:
	// Save back out
	port().TCR = tcr;

}

void _spi_dma_rxISR0(void) {SPI.dma_rxisr();}
     a84:	b508      	push	{r3, lr}

//-------------------------------------------------------------------------
// DMA RX ISR
//-------------------------------------------------------------------------
void SPIClass::dma_rxisr(void) {
	_dmaRX->clearInterrupt();
     a86:	4b30      	ldr	r3, [pc, #192]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     a88:	6c99      	ldr	r1, [r3, #72]	; 0x48
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
     a8a:	7908      	ldrb	r0, [r1, #4]
     a8c:	4a2f      	ldr	r2, [pc, #188]	; (b4c <_spi_dma_rxISR0()+0xc8>)
     a8e:	77d0      	strb	r0, [r2, #31]
	_dmaTX->clearComplete();
     a90:	6c58      	ldr	r0, [r3, #68]	; 0x44
	bool complete(void) {
		if (TCD->CSR & DMA_TCD_CSR_DONE) return true;
		return false;
	}
	void clearComplete(void) {
		DMA_CDNE = channel;
     a92:	7900      	ldrb	r0, [r0, #4]
     a94:	7710      	strb	r0, [r2, #28]
     a96:	7909      	ldrb	r1, [r1, #4]
     a98:	7711      	strb	r1, [r2, #28]
	_dmaRX->clearComplete();

	if (_dma_count_remaining) {
     a9a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
     a9c:	2b00      	cmp	r3, #0
     a9e:	d03e      	beq.n	b1e <_spi_dma_rxISR0()+0x9a>
		// What do I need to do to start it back up again...
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
     aa0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
     aa4:	d304      	bcc.n	ab0 <_spi_dma_rxISR0()+0x2c>
			_dma_count_remaining -= MAX_DMA_COUNT;
     aa6:	4a2a      	ldr	r2, [pc, #168]	; (b50 <_spi_dma_rxISR0()+0xcc>)
     aa8:	441a      	add	r2, r3
     aaa:	4b27      	ldr	r3, [pc, #156]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     aac:	641a      	str	r2, [r3, #64]	; 0x40
     aae:	e02d      	b.n	b0c <_spi_dma_rxISR0()+0x88>
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
     ab0:	4a25      	ldr	r2, [pc, #148]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     ab2:	6c52      	ldr	r2, [r2, #68]	; 0x44
// Main Async Transfer function
//=========================================================================
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
     ab4:	6812      	ldr	r2, [r2, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
     ab6:	8bd1      	ldrh	r1, [r2, #30]
     ab8:	f411 4f00 	tst.w	r1, #32768	; 0x8000
     abc:	d103      	bne.n	ac6 <_spi_dma_rxISR0()+0x42>
		tcd->BITER = len & 0x7fff;
     abe:	f3c3 030e 	ubfx	r3, r3, #0, #15
     ac2:	83d3      	strh	r3, [r2, #30]
     ac4:	e006      	b.n	ad4 <_spi_dma_rxISR0()+0x50>
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
     ac6:	8bd1      	ldrh	r1, [r2, #30]
     ac8:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     acc:	f3c3 0308 	ubfx	r3, r3, #0, #9
     ad0:	430b      	orrs	r3, r1
     ad2:	83d3      	strh	r3, [r2, #30]
	}
	tcd->CITER = tcd->BITER; 
     ad4:	8bd3      	ldrh	r3, [r2, #30]
     ad6:	b29b      	uxth	r3, r3
     ad8:	82d3      	strh	r3, [r2, #22]
		// We will use the BITR/CITR from RX as TX may have prefed some stuff
		if (_dma_count_remaining > MAX_DMA_COUNT) {
			_dma_count_remaining -= MAX_DMA_COUNT;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);
     ada:	4b1b      	ldr	r3, [pc, #108]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     adc:	6c99      	ldr	r1, [r3, #72]	; 0x48
     ade:	6c1a      	ldr	r2, [r3, #64]	; 0x40
// Main Async Transfer function
//=========================================================================
#ifndef TRANSFER_COUNT_FIXED
inline void DMAChanneltransferCount(DMAChannel * dmac, unsigned int len) {
	// note does no validation of length...
	DMABaseClass::TCD_t *tcd = dmac->TCD;
     ae0:	680b      	ldr	r3, [r1, #0]
	if (!(tcd->BITER & DMA_TCD_BITER_ELINK)) {
     ae2:	8bd9      	ldrh	r1, [r3, #30]
     ae4:	f411 4f00 	tst.w	r1, #32768	; 0x8000
     ae8:	d103      	bne.n	af2 <_spi_dma_rxISR0()+0x6e>
		tcd->BITER = len & 0x7fff;
     aea:	f3c2 020e 	ubfx	r2, r2, #0, #15
     aee:	83da      	strh	r2, [r3, #30]
     af0:	e006      	b.n	b00 <_spi_dma_rxISR0()+0x7c>
	} else {
		tcd->BITER = (tcd->BITER & 0xFE00) | (len & 0x1ff);
     af2:	8bd9      	ldrh	r1, [r3, #30]
     af4:	f401 417e 	and.w	r1, r1, #65024	; 0xfe00
     af8:	f3c2 0208 	ubfx	r2, r2, #0, #9
     afc:	430a      	orrs	r2, r1
     afe:	83da      	strh	r2, [r3, #30]
	}
	tcd->CITER = tcd->BITER; 
     b00:	8bda      	ldrh	r2, [r3, #30]
     b02:	b292      	uxth	r2, r2
     b04:	82da      	strh	r2, [r3, #22]
			_dma_count_remaining -= MAX_DMA_COUNT;
		} else {
			DMAChanneltransferCount(_dmaTX, _dma_count_remaining);
			DMAChanneltransferCount(_dmaRX, _dma_count_remaining);

			_dma_count_remaining = 0;
     b06:	2200      	movs	r2, #0
     b08:	4b0f      	ldr	r3, [pc, #60]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     b0a:	641a      	str	r2, [r3, #64]	; 0x40
		}
		_dmaRX->enable();
     b0c:	4a0e      	ldr	r2, [pc, #56]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     b0e:	6c93      	ldr	r3, [r2, #72]	; 0x48
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
     b10:	7919      	ldrb	r1, [r3, #4]
     b12:	4b0e      	ldr	r3, [pc, #56]	; (b4c <_spi_dma_rxISR0()+0xc8>)
     b14:	76d9      	strb	r1, [r3, #27]
		_dmaTX->enable();
     b16:	6c52      	ldr	r2, [r2, #68]	; 0x44
     b18:	7912      	ldrb	r2, [r2, #4]
     b1a:	76da      	strb	r2, [r3, #27]
     b1c:	bd08      	pop	{r3, pc}
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
     b1e:	4a0a      	ldr	r2, [pc, #40]	; (b48 <_spi_dma_rxISR0()+0xc4>)
     b20:	6813      	ldr	r3, [r2, #0]
	} else {

		port().FCR = LPSPI_FCR_TXWATER(15); // _spi_fcr_save;	// restore the FSR status... 
     b22:	210f      	movs	r1, #15
     b24:	6599      	str	r1, [r3, #88]	; 0x58
 		port().DER = 0;		// DMA no longer doing TX (or RX)
     b26:	2100      	movs	r1, #0
     b28:	61d9      	str	r1, [r3, #28]

		port().CR = LPSPI_CR_MEN | LPSPI_CR_RRF | LPSPI_CR_RTF;   // actually clear both...
     b2a:	f240 3001 	movw	r0, #769	; 0x301
     b2e:	6118      	str	r0, [r3, #16]
		port().SR = 0x3f00;	// clear out all of the other status...
     b30:	f44f 507c 	mov.w	r0, #16128	; 0x3f00
     b34:	6158      	str	r0, [r3, #20]

		_dma_state = DMAState::completed;   // set back to 1 in case our call wants to start up dma again
     b36:	2303      	movs	r3, #3
     b38:	f882 303d 	strb.w	r3, [r2, #61]	; 0x3d
		_dma_event_responder->triggerEvent();
     b3c:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
     b3e:	6803      	ldr	r3, [r0, #0]
     b40:	681b      	ldr	r3, [r3, #0]
     b42:	460a      	mov	r2, r1
     b44:	4798      	blx	r3
     b46:	bd08      	pop	{r3, pc}
     b48:	20000644 	.word	0x20000644
     b4c:	400e8000 	.word	0x400e8000
     b50:	ffff8001 	.word	0xffff8001

00000b54 <SPIClass::transfer(void const*, void*, unsigned int)>:
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{

	if (count == 0) return;
     b54:	b37b      	cbz	r3, bb6 <SPIClass::transfer(void const*, void*, unsigned int)+0x62>
		interruptMasksUsed &= ~(1 << (n >> 5));
	}
}

void SPIClass::transfer(const void * buf, void * retbuf, size_t count)
{
     b56:	b470      	push	{r4, r5, r6}
     b58:	461e      	mov	r6, r3
     b5a:	6803      	ldr	r3, [r0, #0]
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 
     b5c:	f240 2401 	movw	r4, #513	; 0x201
     b60:	611c      	str	r4, [r3, #16]
{

	if (count == 0) return;
    uint8_t *p_write = (uint8_t*)buf;
    uint8_t *p_read = (uint8_t*)retbuf;
    size_t count_read = count;
     b62:	4635      	mov	r5, r6

	// Pass 1 keep it simple and don't try packing 8 bits into 16 yet..
	// Lets clear the reader queue
	port().CR = LPSPI_CR_RRF | LPSPI_CR_MEN;	// clear the queue and make sure still enabled. 

	while (count > 0) {
     b64:	b1ce      	cbz	r6, b9a <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
     b66:	6803      	ldr	r3, [r0, #0]
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
     b68:	b111      	cbz	r1, b70 <SPIClass::transfer(void const*, void*, unsigned int)+0x1c>
     b6a:	780c      	ldrb	r4, [r1, #0]
     b6c:	3101      	adds	r1, #1
     b6e:	e001      	b.n	b74 <SPIClass::transfer(void const*, void*, unsigned int)+0x20>
     b70:	f890 403c 	ldrb.w	r4, [r0, #60]	; 0x3c
     b74:	665c      	str	r4, [r3, #100]	; 0x64
		count--; // how many bytes left to output.
     b76:	3e01      	subs	r6, #1
     b78:	6803      	ldr	r3, [r0, #0]
		// Make sure queue is not full before pushing next byte out
		do {
			if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
     b7a:	6f1c      	ldr	r4, [r3, #112]	; 0x70
     b7c:	f014 0f02 	tst.w	r4, #2
     b80:	d105      	bne.n	b8e <SPIClass::transfer(void const*, void*, unsigned int)+0x3a>
				uint8_t b = port().RDR;  // Read any pending RX bytes in
     b82:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     b84:	b2db      	uxtb	r3, r3
				if (p_read) *p_read++ = b; 
     b86:	b10a      	cbz	r2, b8c <SPIClass::transfer(void const*, void*, unsigned int)+0x38>
     b88:	7013      	strb	r3, [r2, #0]
     b8a:	3201      	adds	r2, #1
				count_read--;
     b8c:	3d01      	subs	r5, #1
     b8e:	6803      	ldr	r3, [r0, #0]
			}
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;
     b90:	695b      	ldr	r3, [r3, #20]
	while (count > 0) {
		// Push out the next byte; 
		port().TDR = p_write? *p_write++ : _transferWriteFill;
		count--; // how many bytes left to output.
		// Make sure queue is not full before pushing next byte out
		do {
     b92:	f013 0f01 	tst.w	r3, #1
     b96:	d0ef      	beq.n	b78 <SPIClass::transfer(void const*, void*, unsigned int)+0x24>
     b98:	e7e4      	b.n	b64 <SPIClass::transfer(void const*, void*, unsigned int)+0x10>
		} while ((port().SR & LPSPI_SR_TDF) == 0) ;

	}

	// now lets wait for all of the read bytes to be returned...
	while (count_read) {
     b9a:	b15d      	cbz	r5, bb4 <SPIClass::transfer(void const*, void*, unsigned int)+0x60>
     b9c:	6803      	ldr	r3, [r0, #0]
		if ((port().RSR & LPSPI_RSR_RXEMPTY) == 0)  {
     b9e:	6f19      	ldr	r1, [r3, #112]	; 0x70
     ba0:	f011 0f02 	tst.w	r1, #2
     ba4:	d1f9      	bne.n	b9a <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
			uint8_t b = port().RDR;  // Read any pending RX bytes in
     ba6:	6f5b      	ldr	r3, [r3, #116]	; 0x74
     ba8:	b2db      	uxtb	r3, r3
			if (p_read) *p_read++ = b; 
     baa:	b10a      	cbz	r2, bb0 <SPIClass::transfer(void const*, void*, unsigned int)+0x5c>
     bac:	7013      	strb	r3, [r2, #0]
     bae:	3201      	adds	r2, #1
			count_read--;
     bb0:	3d01      	subs	r5, #1
     bb2:	e7f2      	b.n	b9a <SPIClass::transfer(void const*, void*, unsigned int)+0x46>
		}
	}
}
     bb4:	bc70      	pop	{r4, r5, r6}
     bb6:	4770      	bx	lr

00000bb8 <Print::availableForWrite()>:
  public:
	constexpr Print() : write_error(0) {}
	virtual size_t write(uint8_t b) = 0;
	size_t write(const char *str)			{ return write((const uint8_t *)str, strlen(str)); }
	virtual size_t write(const uint8_t *buffer, size_t size);
	virtual int availableForWrite(void)		{ return 0; }
     bb8:	2000      	movs	r0, #0
     bba:	4770      	bx	lr

00000bbc <Print::flush()>:
	virtual void flush()				{ }
     bbc:	4770      	bx	lr
     bbe:	bf00      	nop

00000bc0 <__static_initialization_and_destruction_0(int, int)>:
void File::rewindDirectory(void) {  
  if (isDirectory())
    _file->rewind();
}

SDClass SD;
     bc0:	2801      	cmp	r0, #1
     bc2:	d110      	bne.n	be6 <__static_initialization_and_destruction_0(int, int)+0x26>
     bc4:	f64f 73ff 	movw	r3, #65535	; 0xffff
     bc8:	4299      	cmp	r1, r3
     bca:	d10c      	bne.n	be6 <__static_initialization_and_destruction_0(int, int)+0x26>
 * \brief Raw access to SD and SDHC flash memory cards.
 */
class Sd2Card {
 public:
  /** Construct an instance of Sd2Card. */
  Sd2Card(void) : type_(0) {}
     bcc:	4b06      	ldr	r3, [pc, #24]	; (be8 <__static_initialization_and_destruction_0(int, int)+0x28>)
     bce:	2200      	movs	r2, #0
     bd0:	709a      	strb	r2, [r3, #2]
 * \brief Access FAT16 and FAT32 volumes on SD and SDHC cards.
 */
class SdVolume {
 public:
  /** Create an instance of SdVolume */
  SdVolume(void) :allocSearchStart_(2), fatType_(0) {}
     bd2:	2102      	movs	r1, #2
     bd4:	6059      	str	r1, [r3, #4]
     bd6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
class __FlashStringHelper;

class Print
{
  public:
	constexpr Print() : write_error(0) {}
     bda:	f883 2030 	strb.w	r2, [r3, #48]	; 0x30
 * \brief Access FAT16 and FAT32 files on SD and SDHC cards.
 */
class SdFile : public Print {
 public:
  /** Create an instance of SdFile. */
  SdFile(void) : type_(FAT_FILE_TYPE_CLOSED) {}
     bde:	4903      	ldr	r1, [pc, #12]	; (bec <__static_initialization_and_destruction_0(int, int)+0x2c>)
     be0:	62d9      	str	r1, [r3, #44]	; 0x2c
     be2:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
     be6:	4770      	bx	lr
     be8:	200010fc 	.word	0x200010fc
     bec:	200002d8 	.word	0x200002d8

00000bf0 <_GLOBAL__sub_I__Z20getNextPathComponentPKcPjPc>:
     bf0:	b508      	push	{r3, lr}
     bf2:	f64f 71ff 	movw	r1, #65535	; 0xffff
     bf6:	2001      	movs	r0, #1
     bf8:	f7ff ffe2 	bl	bc0 <__static_initialization_and_destruction_0(int, int)>
     bfc:	bd08      	pop	{r3, pc}
     bfe:	bf00      	nop

00000c00 <SDHC_WaitStatus(unsigned long)>:

// waits for status bits sets
static uint32_t SDHC_WaitStatus(uint32_t mask)
{
  uint32_t             result;
  uint32_t             timeout = 1 << 24;
     c00:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
  do
  { result = SDHC_IRQSTAT & mask;
     c04:	4b05      	ldr	r3, [pc, #20]	; (c1c <SDHC_WaitStatus(unsigned long)+0x1c>)
     c06:	6b1b      	ldr	r3, [r3, #48]	; 0x30
    timeout--;
     c08:	3a01      	subs	r2, #1
  } while (!result && (timeout));
     c0a:	4003      	ands	r3, r0
     c0c:	d101      	bne.n	c12 <SDHC_WaitStatus(unsigned long)+0x12>
     c0e:	2a00      	cmp	r2, #0
     c10:	d1f8      	bne.n	c04 <SDHC_WaitStatus(unsigned long)+0x4>
  if (timeout) return result;
     c12:	b90a      	cbnz	r2, c18 <SDHC_WaitStatus(unsigned long)+0x18>
  return 0;
     c14:	2000      	movs	r0, #0
     c16:	4770      	bx	lr
  uint32_t             timeout = 1 << 24;
  do
  { result = SDHC_IRQSTAT & mask;
    timeout--;
  } while (!result && (timeout));
  if (timeout) return result;
     c18:	4618      	mov	r0, r3
  return 0;
}
     c1a:	4770      	bx	lr
     c1c:	402c0000 	.word	0x402c0000

00000c20 <SDHC_CMD_Do(unsigned long)>:
	return SDHC_RESULT_OK;
}

// sends the command to SDcard
static int SDHC_CMD_Do(uint32_t xfertyp)
{
     c20:	b508      	push	{r3, lr}
  // Card removal check preparation
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CRM;
     c22:	4a21      	ldr	r2, [pc, #132]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c24:	6b13      	ldr	r3, [r2, #48]	; 0x30
     c26:	f043 0380 	orr.w	r3, r3, #128	; 0x80
     c2a:	6313      	str	r3, [r2, #48]	; 0x30

  // Wait for cmd line idle // to do timeout PRSSTAT[CDIHB] and the PRSSTAT[CIHB]
  while ((SDHC_PRSSTAT & SDHC_PRSSTAT_CIHB) || (SDHC_PRSSTAT & SDHC_PRSSTAT_CDIHB)) { };
     c2c:	4b1e      	ldr	r3, [pc, #120]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c2e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c30:	f013 0f01 	tst.w	r3, #1
     c34:	d106      	bne.n	c44 <SDHC_CMD_Do(unsigned long)+0x24>
     c36:	4b1c      	ldr	r3, [pc, #112]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c38:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     c3a:	f013 0f02 	tst.w	r3, #2
     c3e:	d003      	beq.n	c48 <SDHC_CMD_Do(unsigned long)+0x28>
     c40:	2301      	movs	r3, #1
     c42:	e002      	b.n	c4a <SDHC_CMD_Do(unsigned long)+0x2a>
     c44:	2301      	movs	r3, #1
     c46:	e000      	b.n	c4a <SDHC_CMD_Do(unsigned long)+0x2a>
     c48:	2300      	movs	r3, #0
     c4a:	2b00      	cmp	r3, #0
     c4c:	d1ee      	bne.n	c2c <SDHC_CMD_Do(unsigned long)+0xc>
  SDHC_XFERTYP = xfertyp;
     c4e:	4b16      	ldr	r3, [pc, #88]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c50:	60d8      	str	r0, [r3, #12]

  /* Wait for response */
  const uint32_t mask = SDHC_IRQSTAT_CIE | SDHC_IRQSTAT_CEBE | SDHC_IRQSTAT_CCE | SDHC_IRQSTAT_CC;
  if (SDHC_WaitStatus(mask) != SDHC_IRQSTAT_CC) {
     c52:	4816      	ldr	r0, [pc, #88]	; (cac <SDHC_CMD_Do(unsigned long)+0x8c>)
     c54:	f7ff ffd4 	bl	c00 <SDHC_WaitStatus(unsigned long)>
     c58:	2801      	cmp	r0, #1
     c5a:	d006      	beq.n	c6a <SDHC_CMD_Do(unsigned long)+0x4a>
      //SDHC_IRQSTAT |= mask;
      SDHC_IRQSTAT |= (mask | SDHC_IRQSTAT_CTOE);
     c5c:	4a12      	ldr	r2, [pc, #72]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c5e:	6b11      	ldr	r1, [r2, #48]	; 0x30
     c60:	4b13      	ldr	r3, [pc, #76]	; (cb0 <SDHC_CMD_Do(unsigned long)+0x90>)
     c62:	430b      	orrs	r3, r1
     c64:	6313      	str	r3, [r2, #48]	; 0x30
      return SDHC_RESULT_ERROR;
     c66:	2001      	movs	r0, #1
     c68:	bd08      	pop	{r3, pc}
  }
  /* Check card removal */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CRM) {
     c6a:	4b0f      	ldr	r3, [pc, #60]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     c6e:	f013 0f80 	tst.w	r3, #128	; 0x80
     c72:	d006      	beq.n	c82 <SDHC_CMD_Do(unsigned long)+0x62>
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
     c74:	4a0c      	ldr	r2, [pc, #48]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c76:	6b13      	ldr	r3, [r2, #48]	; 0x30
     c78:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
     c7c:	6313      	str	r3, [r2, #48]	; 0x30
      return SDHC_RESULT_NOT_READY;
     c7e:	2003      	movs	r0, #3
     c80:	bd08      	pop	{r3, pc}
  }

  /* Get response, if available */
  if (SDHC_IRQSTAT & SDHC_IRQSTAT_CTOE) {
     c82:	4b09      	ldr	r3, [pc, #36]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     c86:	f413 3f80 	tst.w	r3, #65536	; 0x10000
     c8a:	d006      	beq.n	c9a <SDHC_CMD_Do(unsigned long)+0x7a>
      SDHC_IRQSTAT |= SDHC_IRQSTAT_CTOE | SDHC_IRQSTAT_CC;
     c8c:	4a06      	ldr	r2, [pc, #24]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c8e:	6b13      	ldr	r3, [r2, #48]	; 0x30
     c90:	f043 1301 	orr.w	r3, r3, #65537	; 0x10001
     c94:	6313      	str	r3, [r2, #48]	; 0x30
      return SDHC_RESULT_NO_RESPONSE;
     c96:	2005      	movs	r0, #5
     c98:	bd08      	pop	{r3, pc}
  }
  SDHC_IRQSTAT |= SDHC_IRQSTAT_CC;
     c9a:	4a03      	ldr	r2, [pc, #12]	; (ca8 <SDHC_CMD_Do(unsigned long)+0x88>)
     c9c:	6b13      	ldr	r3, [r2, #48]	; 0x30
     c9e:	f043 0301 	orr.w	r3, r3, #1
     ca2:	6313      	str	r3, [r2, #48]	; 0x30

  return SDHC_RESULT_OK;
     ca4:	2000      	movs	r0, #0
}
     ca6:	bd08      	pop	{r3, pc}
     ca8:	402c0000 	.word	0x402c0000
     cac:	000e0001 	.word	0x000e0001
     cb0:	000f0001 	.word	0x000f0001

00000cb4 <SDHC_CMD12_StopTransfer()>:
  return result;
}

// sends CMD12 to stop transfer
static int SDHC_CMD12_StopTransfer(void)
{
     cb4:	b508      	push	{r3, lr}
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = 0;
     cb6:	2200      	movs	r2, #0
     cb8:	4b02      	ldr	r3, [pc, #8]	; (cc4 <SDHC_CMD12_StopTransfer()+0x10>)
     cba:	609a      	str	r2, [r3, #8]
  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD12) | SDHC_XFERTYP_CMDTYP(SDHC_XFERTYP_CMDTYP_ABORT) |
             SDHC_XFERTYP_CICEN | SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48BUSY));

  result = SDHC_CMD_Do(xfertyp);
     cbc:	4802      	ldr	r0, [pc, #8]	; (cc8 <SDHC_CMD12_StopTransfer()+0x14>)
     cbe:	f7ff ffaf 	bl	c20 <SDHC_CMD_Do(unsigned long)>

  if (result == SDHC_RESULT_OK) { }
  return result;
}
     cc2:	bd08      	pop	{r3, pc}
     cc4:	402c0000 	.word	0x402c0000
     cc8:	0cdb0000 	.word	0x0cdb0000

00000ccc <SDHC_CMD12_StopTransferWaitForBusy()>:

// sends CMD12 to stop transfer and first waits to ready SDCArd
static int SDHC_CMD12_StopTransferWaitForBusy(void)
{
     ccc:	b510      	push	{r4, lr}
  uint32_t timeOut = 1000;
     cce:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
  int result;
  do {
    result = SDHC_CMD12_StopTransfer();
     cd2:	f7ff ffef 	bl	cb4 <SDHC_CMD12_StopTransfer()>
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);
     cd6:	3c01      	subs	r4, #1
     cd8:	d007      	beq.n	cea <SDHC_CMD12_StopTransferWaitForBusy()+0x1e>
     cda:	4b0a      	ldr	r3, [pc, #40]	; (d04 <SDHC_CMD12_StopTransferWaitForBusy()+0x38>)
     cdc:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     cde:	f013 0f04 	tst.w	r3, #4
     ce2:	d004      	beq.n	cee <SDHC_CMD12_StopTransferWaitForBusy()+0x22>
     ce4:	b128      	cbz	r0, cf2 <SDHC_CMD12_StopTransferWaitForBusy()+0x26>
     ce6:	2300      	movs	r3, #0
     ce8:	e004      	b.n	cf4 <SDHC_CMD12_StopTransferWaitForBusy()+0x28>
     cea:	2300      	movs	r3, #0
     cec:	e002      	b.n	cf4 <SDHC_CMD12_StopTransferWaitForBusy()+0x28>
     cee:	2300      	movs	r3, #0
     cf0:	e000      	b.n	cf4 <SDHC_CMD12_StopTransferWaitForBusy()+0x28>
     cf2:	2301      	movs	r3, #1
// sends CMD12 to stop transfer and first waits to ready SDCArd
static int SDHC_CMD12_StopTransferWaitForBusy(void)
{
  uint32_t timeOut = 1000;
  int result;
  do {
     cf4:	2b00      	cmp	r3, #0
     cf6:	d1ec      	bne.n	cd2 <SDHC_CMD12_StopTransferWaitForBusy()+0x6>
    result = SDHC_CMD12_StopTransfer();
    timeOut--;
  } while (timeOut && (SDHC_PRSSTAT & SDHC_PRSSTAT_DLA) && result == SDHC_RESULT_OK);

  if (result != SDHC_RESULT_OK)  return result;
     cf8:	b918      	cbnz	r0, d02 <SDHC_CMD12_StopTransferWaitForBusy()+0x36>
  if (!timeOut)  return SDHC_RESULT_NO_RESPONSE;
     cfa:	b90c      	cbnz	r4, d00 <SDHC_CMD12_StopTransferWaitForBusy()+0x34>
     cfc:	2005      	movs	r0, #5
     cfe:	bd10      	pop	{r4, pc}

  return SDHC_RESULT_OK;
     d00:	2000      	movs	r0, #0
}
     d02:	bd10      	pop	{r4, pc}
     d04:	402c0000 	.word	0x402c0000

00000d08 <SDHC_ReadBlock(unsigned long*)>:
  return 0;
}

// reads one block
static int SDHC_ReadBlock(uint32_t* pData)
{
     d08:	b510      	push	{r4, lr}
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
     d0a:	2200      	movs	r2, #0
     d0c:	2a07      	cmp	r2, #7
     d0e:	d837      	bhi.n	d80 <SDHC_ReadBlock(unsigned long*)+0x78>
		irqstat = SDHC_IRQSTAT;
     d10:	491c      	ldr	r1, [pc, #112]	; (d84 <SDHC_ReadBlock(unsigned long*)+0x7c>)
     d12:	6b0b      	ldr	r3, [r1, #48]	; 0x30
		SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR;
     d14:	f043 0420 	orr.w	r4, r3, #32
     d18:	630c      	str	r4, [r1, #48]	; 0x30
		if (irqstat & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
     d1a:	f413 0fe0 	tst.w	r3, #7340032	; 0x700000
     d1e:	d006      	beq.n	d2e <SDHC_ReadBlock(unsigned long*)+0x26>
			SDHC_IRQSTAT = irqstat | SDHC_IRQSTAT_BRR |
				SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE;
     d20:	4a19      	ldr	r2, [pc, #100]	; (d88 <SDHC_ReadBlock(unsigned long*)+0x80>)
     d22:	431a      	orrs	r2, r3
     d24:	630a      	str	r2, [r1, #48]	; 0x30
			SDHC_CMD12_StopTransferWaitForBusy();
     d26:	f7ff ffd1 	bl	ccc <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
     d2a:	2001      	movs	r0, #1
     d2c:	bd10      	pop	{r4, pc}
		}
		while (!(SDHC_PRSSTAT & SDHC_PRSSTAT_BREN)) { };
     d2e:	4b15      	ldr	r3, [pc, #84]	; (d84 <SDHC_ReadBlock(unsigned long*)+0x7c>)
     d30:	6a5b      	ldr	r3, [r3, #36]	; 0x24
     d32:	f413 6f00 	tst.w	r3, #2048	; 0x800
     d36:	d0fa      	beq.n	d2e <SDHC_ReadBlock(unsigned long*)+0x26>
		*pData++ = SDHC_DATPORT;
     d38:	4b12      	ldr	r3, [pc, #72]	; (d84 <SDHC_ReadBlock(unsigned long*)+0x7c>)
     d3a:	6a19      	ldr	r1, [r3, #32]
     d3c:	6001      	str	r1, [r0, #0]
		*pData++ = SDHC_DATPORT;
     d3e:	6a19      	ldr	r1, [r3, #32]
     d40:	6041      	str	r1, [r0, #4]
		*pData++ = SDHC_DATPORT;
     d42:	6a19      	ldr	r1, [r3, #32]
     d44:	6081      	str	r1, [r0, #8]
		*pData++ = SDHC_DATPORT;
     d46:	6a19      	ldr	r1, [r3, #32]
     d48:	60c1      	str	r1, [r0, #12]
		*pData++ = SDHC_DATPORT;
     d4a:	6a19      	ldr	r1, [r3, #32]
     d4c:	6101      	str	r1, [r0, #16]
		*pData++ = SDHC_DATPORT;
     d4e:	6a19      	ldr	r1, [r3, #32]
     d50:	6141      	str	r1, [r0, #20]
		*pData++ = SDHC_DATPORT;
     d52:	6a19      	ldr	r1, [r3, #32]
     d54:	6181      	str	r1, [r0, #24]
		*pData++ = SDHC_DATPORT;
     d56:	6a19      	ldr	r1, [r3, #32]
     d58:	61c1      	str	r1, [r0, #28]
		*pData++ = SDHC_DATPORT;
     d5a:	6a19      	ldr	r1, [r3, #32]
     d5c:	6201      	str	r1, [r0, #32]
		*pData++ = SDHC_DATPORT;
     d5e:	6a19      	ldr	r1, [r3, #32]
     d60:	6241      	str	r1, [r0, #36]	; 0x24
		*pData++ = SDHC_DATPORT;
     d62:	6a19      	ldr	r1, [r3, #32]
     d64:	6281      	str	r1, [r0, #40]	; 0x28
		*pData++ = SDHC_DATPORT;
     d66:	6a19      	ldr	r1, [r3, #32]
     d68:	62c1      	str	r1, [r0, #44]	; 0x2c
		*pData++ = SDHC_DATPORT;
     d6a:	6a19      	ldr	r1, [r3, #32]
     d6c:	6301      	str	r1, [r0, #48]	; 0x30
		*pData++ = SDHC_DATPORT;
     d6e:	6a19      	ldr	r1, [r3, #32]
     d70:	6341      	str	r1, [r0, #52]	; 0x34
		*pData++ = SDHC_DATPORT;
     d72:	6a19      	ldr	r1, [r3, #32]
     d74:	6381      	str	r1, [r0, #56]	; 0x38
		*pData++ = SDHC_DATPORT;
     d76:	6a1b      	ldr	r3, [r3, #32]
     d78:	63c3      	str	r3, [r0, #60]	; 0x3c
static int SDHC_ReadBlock(uint32_t* pData)
{
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
     d7a:	3201      	adds	r2, #1
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
     d7c:	3040      	adds	r0, #64	; 0x40
static int SDHC_ReadBlock(uint32_t* pData)
{
	uint32_t i, irqstat;
	const uint32_t i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for (i = 0; i < i_max; i++) {
     d7e:	e7c5      	b.n	d0c <SDHC_ReadBlock(unsigned long*)+0x4>
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
		*pData++ = SDHC_DATPORT;
	}
	return SDHC_RESULT_OK;
     d80:	2000      	movs	r0, #0
}
     d82:	bd10      	pop	{r4, pc}
     d84:	402c0000 	.word	0x402c0000
     d88:	00700020 	.word	0x00700020

00000d8c <SDHC_WriteBlock(unsigned long const*)>:

// writes one block
static int SDHC_WriteBlock(const uint32_t* pData)
{
     d8c:	b510      	push	{r4, lr}
	uint32_t i, i_max, j;
	i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for(i = 0; i < i_max; i++) {
     d8e:	2400      	movs	r4, #0
     d90:	2c07      	cmp	r4, #7
     d92:	d82f      	bhi.n	df4 <SDHC_WriteBlock(unsigned long const*)+0x68>
		while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_BWR)) ; // wait
     d94:	4b18      	ldr	r3, [pc, #96]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     d96:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     d98:	f013 0f10 	tst.w	r3, #16
     d9c:	d0fa      	beq.n	d94 <SDHC_WriteBlock(unsigned long const*)+0x8>
		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
     d9e:	4b16      	ldr	r3, [pc, #88]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     da0:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     da2:	f413 0fe0 	tst.w	r3, #7340032	; 0x700000
     da6:	d008      	beq.n	dba <SDHC_WriteBlock(unsigned long const*)+0x2e>
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
     da8:	4a13      	ldr	r2, [pc, #76]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     daa:	6b11      	ldr	r1, [r2, #48]	; 0x30
     dac:	4b13      	ldr	r3, [pc, #76]	; (dfc <SDHC_WriteBlock(unsigned long const*)+0x70>)
     dae:	430b      	orrs	r3, r1
     db0:	6313      	str	r3, [r2, #48]	; 0x30
			(void)SDHC_CMD12_StopTransferWaitForBusy();
     db2:	f7ff ff8b 	bl	ccc <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
     db6:	2001      	movs	r0, #1
     db8:	bd10      	pop	{r4, pc}
     dba:	2300      	movs	r3, #0
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
     dbc:	2b0f      	cmp	r3, #15
     dbe:	d805      	bhi.n	dcc <SDHC_WriteBlock(unsigned long const*)+0x40>
			SDHC_DATPORT = *pData++;
     dc0:	6801      	ldr	r1, [r0, #0]
     dc2:	4a0d      	ldr	r2, [pc, #52]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     dc4:	6211      	str	r1, [r2, #32]
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
     dc6:	3301      	adds	r3, #1
			SDHC_DATPORT = *pData++;
     dc8:	3004      	adds	r0, #4
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
		for(j=0; j<SDHC_FIFO_BUFFER_SIZE; j++) {
     dca:	e7f7      	b.n	dbc <SDHC_WriteBlock(unsigned long const*)+0x30>
			SDHC_DATPORT = *pData++;
		}
		SDHC_IRQSTAT |= SDHC_IRQSTAT_BWR;
     dcc:	4b0a      	ldr	r3, [pc, #40]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     dce:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     dd0:	f042 0210 	orr.w	r2, r2, #16
     dd4:	631a      	str	r2, [r3, #48]	; 0x30

		if (SDHC_IRQSTAT & (SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE | SDHC_IRQSTAT_DTOE)) {
     dd6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     dd8:	f413 0fe0 	tst.w	r3, #7340032	; 0x700000
     ddc:	d008      	beq.n	df0 <SDHC_WriteBlock(unsigned long const*)+0x64>
			SDHC_IRQSTAT |= SDHC_IRQSTAT_DEBE | SDHC_IRQSTAT_DCE |
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
     dde:	4a06      	ldr	r2, [pc, #24]	; (df8 <SDHC_WriteBlock(unsigned long const*)+0x6c>)
     de0:	6b11      	ldr	r1, [r2, #48]	; 0x30
     de2:	4b06      	ldr	r3, [pc, #24]	; (dfc <SDHC_WriteBlock(unsigned long const*)+0x70>)
     de4:	430b      	orrs	r3, r1
     de6:	6313      	str	r3, [r2, #48]	; 0x30
			(void)SDHC_CMD12_StopTransferWaitForBusy();
     de8:	f7ff ff70 	bl	ccc <SDHC_CMD12_StopTransferWaitForBusy()>
			return SDHC_RESULT_ERROR;
     dec:	2001      	movs	r0, #1
     dee:	bd10      	pop	{r4, pc}
static int SDHC_WriteBlock(const uint32_t* pData)
{
	uint32_t i, i_max, j;
	i_max = ((SDHC_BLOCK_SIZE) / (4 * SDHC_FIFO_BUFFER_SIZE));

	for(i = 0; i < i_max; i++) {
     df0:	3401      	adds	r4, #1
     df2:	e7cd      	b.n	d90 <SDHC_WriteBlock(unsigned long const*)+0x4>
				SDHC_IRQSTAT_DTOE | SDHC_IRQSTAT_BWR;
			(void)SDHC_CMD12_StopTransferWaitForBusy();
			return SDHC_RESULT_ERROR;
		}
	}
	return SDHC_RESULT_OK;
     df4:	2000      	movs	r0, #0
}
     df6:	bd10      	pop	{r4, pc}
     df8:	402c0000 	.word	0x402c0000
     dfc:	00700010 	.word	0x00700010

00000e00 <SDHC_CMD17_ReadBlock(unsigned long)>:
  return result;
}

// sends CMD17 to read one block
static int SDHC_CMD17_ReadBlock(uint32_t sector)
{
     e00:	b508      	push	{r3, lr}
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;
     e02:	4b07      	ldr	r3, [pc, #28]	; (e20 <SDHC_CMD17_ReadBlock(unsigned long)+0x20>)
     e04:	6098      	str	r0, [r3, #8]

  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
     e06:	f44f 3281 	mov.w	r2, #66048	; 0x10200
     e0a:	605a      	str	r2, [r3, #4]

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD17) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DTDSEL | SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
     e0c:	4805      	ldr	r0, [pc, #20]	; (e24 <SDHC_CMD17_ReadBlock(unsigned long)+0x24>)
     e0e:	f7ff ff07 	bl	c20 <SDHC_CMD_Do(unsigned long)>
  if (result == SDHC_RESULT_OK) { ( void)SDHC_CMDRSP0; }
     e12:	4603      	mov	r3, r0
     e14:	b908      	cbnz	r0, e1a <SDHC_CMD17_ReadBlock(unsigned long)+0x1a>
     e16:	4a02      	ldr	r2, [pc, #8]	; (e20 <SDHC_CMD17_ReadBlock(unsigned long)+0x20>)
     e18:	6912      	ldr	r2, [r2, #16]

  return result;
}
     e1a:	4618      	mov	r0, r3
     e1c:	bd08      	pop	{r3, pc}
     e1e:	bf00      	nop
     e20:	402c0000 	.word	0x402c0000
     e24:	113a0010 	.word	0x113a0010

00000e28 <SDHC_CMD24_WriteBlock(unsigned long)>:

// sends CMD24 to write one block
static int SDHC_CMD24_WriteBlock(uint32_t sector)
{
     e28:	b508      	push	{r3, lr}
  uint32_t xfertyp;
  int result;

  SDHC_CMDARG = sector;
     e2a:	4b07      	ldr	r3, [pc, #28]	; (e48 <SDHC_CMD24_WriteBlock(unsigned long)+0x20>)
     e2c:	6098      	str	r0, [r3, #8]
  SDHC_BLKATTR = SDHC_BLKATTR_BLKCNT(1) | 512;
     e2e:	f44f 3281 	mov.w	r2, #66048	; 0x10200
     e32:	605a      	str	r2, [r3, #4]

  xfertyp = (SDHC_XFERTYP_CMDINX(SDHC_CMD24) | SDHC_XFERTYP_CICEN |
             SDHC_XFERTYP_CCCEN | SDHC_XFERTYP_RSPTYP(SDHC_XFERTYP_RSPTYP_48) |
             SDHC_XFERTYP_DPSEL);

  result = SDHC_CMD_Do(xfertyp);
     e34:	4805      	ldr	r0, [pc, #20]	; (e4c <SDHC_CMD24_WriteBlock(unsigned long)+0x24>)
     e36:	f7ff fef3 	bl	c20 <SDHC_CMD_Do(unsigned long)>
  if (result == SDHC_RESULT_OK) { (void)SDHC_CMDRSP0; }
     e3a:	4603      	mov	r3, r0
     e3c:	b908      	cbnz	r0, e42 <SDHC_CMD24_WriteBlock(unsigned long)+0x1a>
     e3e:	4a02      	ldr	r2, [pc, #8]	; (e48 <SDHC_CMD24_WriteBlock(unsigned long)+0x20>)
     e40:	6912      	ldr	r2, [r2, #16]

  return result;
}
     e42:	4618      	mov	r0, r3
     e44:	bd08      	pop	{r3, pc}
     e46:	bf00      	nop
     e48:	402c0000 	.word	0x402c0000
     e4c:	183a0000 	.word	0x183a0000

00000e50 <SDHC_CardReadBlock(void*, unsigned long)>:
{
  int result;
  uint32_t* pData = (uint32_t*)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0)
     e50:	4b11      	ldr	r3, [pc, #68]	; (e98 <SDHC_CardReadBlock(void*, unsigned long)+0x48>)
     e52:	781b      	ldrb	r3, [r3, #0]
     e54:	b9eb      	cbnz	r3, e92 <SDHC_CardReadBlock(void*, unsigned long)+0x42>
#if 1
// read a block from disk, using polling
//   buff - pointer on buffer where read data should be stored
//   sector - index of start sector
int SDHC_CardReadBlock(void * buff, uint32_t sector)
{
     e56:	b510      	push	{r4, lr}
     e58:	4604      	mov	r4, r0
  // Check if this is ready
  if (sdCardDesc.status != 0)
     return SDHC_RESULT_NOT_READY;

  // Convert LBA to uint8_t address if needed
  if (!sdCardDesc.highCapacity)
     e5a:	4b0f      	ldr	r3, [pc, #60]	; (e98 <SDHC_CardReadBlock(void*, unsigned long)+0x48>)
     e5c:	785b      	ldrb	r3, [r3, #1]
     e5e:	b903      	cbnz	r3, e62 <SDHC_CardReadBlock(void*, unsigned long)+0x12>
    sector *= 512;
     e60:	0249      	lsls	r1, r1, #9

  SDHC_IRQSTAT = 0xffff;
     e62:	4b0e      	ldr	r3, [pc, #56]	; (e9c <SDHC_CardReadBlock(void*, unsigned long)+0x4c>)
     e64:	f64f 72ff 	movw	r2, #65535	; 0xffff
     e68:	631a      	str	r2, [r3, #48]	; 0x30
#if defined(__IMXRT1062__)
  SDHC_MIX_CTRL |= SDHC_MIX_CTRL_DTDSEL;
     e6a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
     e6c:	f042 0210 	orr.w	r2, r2, #16
     e70:	649a      	str	r2, [r3, #72]	; 0x48
#endif

  // Just single block mode is needed
  result = SDHC_CMD17_ReadBlock(sector);
     e72:	4608      	mov	r0, r1
     e74:	f7ff ffc4 	bl	e00 <SDHC_CMD17_ReadBlock(unsigned long)>
  if(result != SDHC_RESULT_OK) return result;
     e78:	b968      	cbnz	r0, e96 <SDHC_CardReadBlock(void*, unsigned long)+0x46>
  result = SDHC_ReadBlock(pData);
     e7a:	4620      	mov	r0, r4
     e7c:	f7ff ff44 	bl	d08 <SDHC_ReadBlock(unsigned long*)>

  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
     e80:	4b06      	ldr	r3, [pc, #24]	; (e9c <SDHC_CardReadBlock(void*, unsigned long)+0x4c>)
     e82:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     e84:	f013 0f02 	tst.w	r3, #2
     e88:	d0fa      	beq.n	e80 <SDHC_CardReadBlock(void*, unsigned long)+0x30>
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BRR | SDHC_IRQSTAT_AC12E);
     e8a:	4a05      	ldr	r2, [pc, #20]	; (ea0 <SDHC_CardReadBlock(void*, unsigned long)+0x50>)
     e8c:	4b03      	ldr	r3, [pc, #12]	; (e9c <SDHC_CardReadBlock(void*, unsigned long)+0x4c>)
     e8e:	631a      	str	r2, [r3, #48]	; 0x30

  return result;
     e90:	bd10      	pop	{r4, pc}
  int result;
  uint32_t* pData = (uint32_t*)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0)
     return SDHC_RESULT_NOT_READY;
     e92:	2003      	movs	r0, #3
  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BRR | SDHC_IRQSTAT_AC12E);

  return result;
}
     e94:	4770      	bx	lr
     e96:	bd10      	pop	{r4, pc}
     e98:	20001150 	.word	0x20001150
     e9c:	402c0000 	.word	0x402c0000
     ea0:	01000022 	.word	0x01000022

00000ea4 <SDHC_CardWriteBlock(void const*, unsigned long)>:
{
  int result;
  const uint32_t *pData = (const uint32_t *)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;
     ea4:	4b11      	ldr	r3, [pc, #68]	; (eec <SDHC_CardWriteBlock(void const*, unsigned long)+0x48>)
     ea6:	781b      	ldrb	r3, [r3, #0]
     ea8:	b9e3      	cbnz	r3, ee4 <SDHC_CardWriteBlock(void const*, unsigned long)+0x40>
//
// RETURNS:     result of operation
//-----------------------------------------------------------------------------
#if 1
int SDHC_CardWriteBlock(const void * buff, uint32_t sector)
{
     eaa:	b510      	push	{r4, lr}
     eac:	4604      	mov	r4, r0

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;

  // Convert LBA to uint8_t address if needed
  if(!sdCardDesc.highCapacity)
     eae:	4b0f      	ldr	r3, [pc, #60]	; (eec <SDHC_CardWriteBlock(void const*, unsigned long)+0x48>)
     eb0:	785b      	ldrb	r3, [r3, #1]
     eb2:	b903      	cbnz	r3, eb6 <SDHC_CardWriteBlock(void const*, unsigned long)+0x12>
    sector *= 512;
     eb4:	0249      	lsls	r1, r1, #9

  //SDHC_IRQSTAT = 0xffff;
  SDHC_IRQSTAT = SDHC_IRQSTAT;
     eb6:	4b0e      	ldr	r3, [pc, #56]	; (ef0 <SDHC_CardWriteBlock(void const*, unsigned long)+0x4c>)
     eb8:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     eba:	631a      	str	r2, [r3, #48]	; 0x30
#if defined(__IMXRT1062__)
	SDHC_MIX_CTRL &= ~SDHC_MIX_CTRL_DTDSEL;
     ebc:	6c9a      	ldr	r2, [r3, #72]	; 0x48
     ebe:	f022 0210 	bic.w	r2, r2, #16
     ec2:	649a      	str	r2, [r3, #72]	; 0x48
#endif

  // Just single block mode is needed
  result = SDHC_CMD24_WriteBlock(sector);
     ec4:	4608      	mov	r0, r1
     ec6:	f7ff ffaf 	bl	e28 <SDHC_CMD24_WriteBlock(unsigned long)>
  if (result != SDHC_RESULT_OK) return result;
     eca:	b968      	cbnz	r0, ee8 <SDHC_CardWriteBlock(void const*, unsigned long)+0x44>
  result = SDHC_WriteBlock(pData);
     ecc:	4620      	mov	r0, r4
     ece:	f7ff ff5d 	bl	d8c <SDHC_WriteBlock(unsigned long const*)>

  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
     ed2:	4b07      	ldr	r3, [pc, #28]	; (ef0 <SDHC_CardWriteBlock(void const*, unsigned long)+0x4c>)
     ed4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
     ed6:	f013 0f02 	tst.w	r3, #2
     eda:	d0fa      	beq.n	ed2 <SDHC_CardWriteBlock(void const*, unsigned long)+0x2e>
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BWR | SDHC_IRQSTAT_AC12E);
     edc:	4a05      	ldr	r2, [pc, #20]	; (ef4 <SDHC_CardWriteBlock(void const*, unsigned long)+0x50>)
     ede:	4b04      	ldr	r3, [pc, #16]	; (ef0 <SDHC_CardWriteBlock(void const*, unsigned long)+0x4c>)
     ee0:	631a      	str	r2, [r3, #48]	; 0x30

  return result;
     ee2:	bd10      	pop	{r4, pc}
{
  int result;
  const uint32_t *pData = (const uint32_t *)buff;

  // Check if this is ready
  if (sdCardDesc.status != 0) return SDHC_RESULT_NOT_READY;
     ee4:	2003      	movs	r0, #3
  // finish up
  while (!(SDHC_IRQSTAT & SDHC_IRQSTAT_TC)) { }  // wait for transfer to complete
  SDHC_IRQSTAT = (SDHC_IRQSTAT_TC | SDHC_IRQSTAT_BWR | SDHC_IRQSTAT_AC12E);

  return result;
}
     ee6:	4770      	bx	lr
     ee8:	bd10      	pop	{r4, pc}
     eea:	bf00      	nop
     eec:	20001150 	.word	0x20001150
     ef0:	402c0000 	.word	0x402c0000
     ef4:	01000012 	.word	0x01000012

00000ef8 <spiSend(unsigned char)>:
     ef8:	4b04      	ldr	r3, [pc, #16]	; (f0c <spiSend(unsigned char)+0x14>)
     efa:	681a      	ldr	r2, [r3, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
     efc:	6650      	str	r0, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
     efe:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
     f00:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
     f04:	d0fb      	beq.n	efe <spiSend(unsigned char)+0x6>
     f06:	6f53      	ldr	r3, [r2, #116]	; 0x74
     f08:	4770      	bx	lr
     f0a:	bf00      	nop
     f0c:	20000644 	.word	0x20000644

00000f10 <spiRec()>:
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
     f10:	4b05      	ldr	r3, [pc, #20]	; (f28 <spiRec()+0x18>)
     f12:	681a      	ldr	r2, [r3, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
     f14:	23ff      	movs	r3, #255	; 0xff
     f16:	6653      	str	r3, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
     f18:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
     f1a:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
     f1e:	d0fb      	beq.n	f18 <spiRec()+0x8>
     f20:	6f50      	ldr	r0, [r2, #116]	; 0x74
	SPI.transfer(b);
 }
 
 static  uint8_t spiRec(void) {
	return SPI.transfer(0xff);
 }
     f22:	b2c0      	uxtb	r0, r0
     f24:	4770      	bx	lr
     f26:	bf00      	nop
     f28:	20000644 	.word	0x20000644

00000f2c <spiRecIgnore(unsigned int)>:
	memset(buf, 0xFF, len);
	SPI.transfer(buf, len);	
 }
 
 static void spiRecIgnore(size_t len) {
	for (size_t i=0; i < len; i++) 
     f2c:	2100      	movs	r1, #0
     f2e:	4281      	cmp	r1, r0
     f30:	d20a      	bcs.n	f48 <spiRecIgnore(unsigned int)+0x1c>
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
     f32:	4b06      	ldr	r3, [pc, #24]	; (f4c <spiRecIgnore(unsigned int)+0x20>)
     f34:	681a      	ldr	r2, [r3, #0]
	}

	// Write to the SPI bus (MOSI pin) and also receive (MISO pin)
	uint8_t transfer(uint8_t data) {
		// TODO: check for space in fifo?
		port().TDR = data;
     f36:	23ff      	movs	r3, #255	; 0xff
     f38:	6653      	str	r3, [r2, #100]	; 0x64
		while (1) {
			uint32_t fifo = (port().FSR >> 16) & 0x1F;
     f3a:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
			if (fifo > 0) return port().RDR;
     f3c:	f413 1ff8 	tst.w	r3, #2031616	; 0x1f0000
     f40:	d0fb      	beq.n	f3a <spiRecIgnore(unsigned int)+0xe>
     f42:	6f53      	ldr	r3, [r2, #116]	; 0x74
     f44:	3101      	adds	r1, #1
     f46:	e7f2      	b.n	f2e <spiRecIgnore(unsigned int)+0x2>
     f48:	4770      	bx	lr
     f4a:	bf00      	nop
     f4c:	20000644 	.word	0x20000644

00000f50 <__static_initialization_and_destruction_0(int, int)>:
  status_ = spiRec();
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    return false; // SD_CARD_ERROR_WRITE
  }
  return true;
}
     f50:	2801      	cmp	r0, #1
     f52:	d108      	bne.n	f66 <__static_initialization_and_destruction_0(int, int)+0x16>
     f54:	f64f 73ff 	movw	r3, #65535	; 0xffff
     f58:	4299      	cmp	r1, r3
     f5a:	d104      	bne.n	f66 <__static_initialization_and_destruction_0(int, int)+0x16>
public:
	SPISettings(uint32_t clockIn, uint8_t bitOrderIn, uint8_t dataModeIn) : _clock(clockIn) {
		init_AlwaysInline(bitOrderIn, dataModeIn);
	}

	SPISettings() : _clock(4000000) {
     f5c:	4b02      	ldr	r3, [pc, #8]	; (f68 <__static_initialization_and_destruction_0(int, int)+0x18>)
     f5e:	4a03      	ldr	r2, [pc, #12]	; (f6c <__static_initialization_and_destruction_0(int, int)+0x1c>)
     f60:	601a      	str	r2, [r3, #0]
		init_AlwaysInline(MSBFIRST, SPI_MODE0);
	}
private:
	void init_AlwaysInline(uint8_t bitOrder, uint8_t dataMode)
	  __attribute__((__always_inline__)) {
			tcr = LPSPI_TCR_FRAMESZ(7);    // TCR has polarity and bit order too
     f62:	2207      	movs	r2, #7
     f64:	605a      	str	r2, [r3, #4]
     f66:	4770      	bx	lr
     f68:	20001160 	.word	0x20001160
     f6c:	003d0900 	.word	0x003d0900

00000f70 <spiRec(unsigned char*, unsigned int)>:
 
 static  uint8_t spiRec(void) {
	return SPI.transfer(0xff);
 }
 
 static void spiRec(uint8_t* buf, size_t len) {
     f70:	b538      	push	{r3, r4, r5, lr}
     f72:	4604      	mov	r4, r0
     f74:	460d      	mov	r5, r1
	memset(buf, 0xFF, len);
     f76:	460a      	mov	r2, r1
     f78:	21ff      	movs	r1, #255	; 0xff
     f7a:	f003 fb4f 	bl	461c <memset>
		while ((port().RSR & LPSPI_RSR_RXEMPTY)) ;	// wait while the RSR fifo is empty...
		port().TCR = tcr;	// restore back
		return port().RDR;
	}

	void inline transfer(void *buf, size_t count) {transfer(buf, buf, count);}
     f7e:	462b      	mov	r3, r5
     f80:	4622      	mov	r2, r4
     f82:	4621      	mov	r1, r4
     f84:	4801      	ldr	r0, [pc, #4]	; (f8c <spiRec(unsigned char*, unsigned int)+0x1c>)
     f86:	f7ff fde5 	bl	b54 <SPIClass::transfer(void const*, void*, unsigned int)>
     f8a:	bd38      	pop	{r3, r4, r5, pc}
     f8c:	20000644 	.word	0x20000644

00000f90 <Sd2Card::chipSelectHigh()>:
}
//------------------------------------------------------------------------------
#ifdef SPI_HAS_TRANSACTION
static uint8_t chip_select_asserted = 0;
#endif
void Sd2Card::chipSelectHigh(void) {
     f90:	b508      	push	{r3, lr}
  digitalWrite(chipSelectPin_, HIGH);
     f92:	2101      	movs	r1, #1
     f94:	7800      	ldrb	r0, [r0, #0]
     f96:	f001 fcbf 	bl	2918 <digitalWrite>
#ifdef SPI_HAS_TRANSACTION
  if (chip_select_asserted) {
     f9a:	4b1b      	ldr	r3, [pc, #108]	; (1008 <Sd2Card::chipSelectHigh()+0x78>)
     f9c:	781b      	ldrb	r3, [r3, #0]
     f9e:	2b00      	cmp	r3, #0
     fa0:	d031      	beq.n	1006 <Sd2Card::chipSelectHigh()+0x76>
    chip_select_asserted = 0;
     fa2:	2200      	movs	r2, #0
     fa4:	4b18      	ldr	r3, [pc, #96]	; (1008 <Sd2Card::chipSelectHigh()+0x78>)
     fa6:	701a      	strb	r2, [r3, #0]
			pinMode(SPI_TRANSACTION_MISMATCH_LED, OUTPUT);
			digitalWrite(SPI_TRANSACTION_MISMATCH_LED, HIGH);
		}
		inTransactionFlag = 0;
		#endif
		if (interruptMasksUsed) {
     fa8:	4b18      	ldr	r3, [pc, #96]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     faa:	7cdb      	ldrb	r3, [r3, #19]
     fac:	2b00      	cmp	r3, #0
     fae:	d02a      	beq.n	1006 <Sd2Card::chipSelectHigh()+0x76>
			if (interruptMasksUsed & 0x01) NVIC_ISER0 = interruptSave[0];
     fb0:	f013 0f01 	tst.w	r3, #1
     fb4:	d003      	beq.n	fbe <Sd2Card::chipSelectHigh()+0x2e>
     fb6:	4b15      	ldr	r3, [pc, #84]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fb8:	6a9a      	ldr	r2, [r3, #40]	; 0x28
     fba:	4b15      	ldr	r3, [pc, #84]	; (1010 <Sd2Card::chipSelectHigh()+0x80>)
     fbc:	601a      	str	r2, [r3, #0]
			if (interruptMasksUsed & 0x02) NVIC_ISER1 = interruptSave[1];
     fbe:	4b13      	ldr	r3, [pc, #76]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fc0:	7cdb      	ldrb	r3, [r3, #19]
     fc2:	f013 0f02 	tst.w	r3, #2
     fc6:	d003      	beq.n	fd0 <Sd2Card::chipSelectHigh()+0x40>
     fc8:	4b10      	ldr	r3, [pc, #64]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fca:	6ada      	ldr	r2, [r3, #44]	; 0x2c
     fcc:	4b11      	ldr	r3, [pc, #68]	; (1014 <Sd2Card::chipSelectHigh()+0x84>)
     fce:	601a      	str	r2, [r3, #0]
			if (interruptMasksUsed & 0x04) NVIC_ISER2 = interruptSave[2];
     fd0:	4b0e      	ldr	r3, [pc, #56]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fd2:	7cdb      	ldrb	r3, [r3, #19]
     fd4:	f013 0f04 	tst.w	r3, #4
     fd8:	d003      	beq.n	fe2 <Sd2Card::chipSelectHigh()+0x52>
     fda:	4b0c      	ldr	r3, [pc, #48]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fdc:	6b1a      	ldr	r2, [r3, #48]	; 0x30
     fde:	4b0e      	ldr	r3, [pc, #56]	; (1018 <Sd2Card::chipSelectHigh()+0x88>)
     fe0:	601a      	str	r2, [r3, #0]
			if (interruptMasksUsed & 0x08) NVIC_ISER3 = interruptSave[3];
     fe2:	4b0a      	ldr	r3, [pc, #40]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fe4:	7cdb      	ldrb	r3, [r3, #19]
     fe6:	f013 0f08 	tst.w	r3, #8
     fea:	d003      	beq.n	ff4 <Sd2Card::chipSelectHigh()+0x64>
     fec:	4b07      	ldr	r3, [pc, #28]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     fee:	6b5a      	ldr	r2, [r3, #52]	; 0x34
     ff0:	4b0a      	ldr	r3, [pc, #40]	; (101c <Sd2Card::chipSelectHigh()+0x8c>)
     ff2:	601a      	str	r2, [r3, #0]
			if (interruptMasksUsed & 0x10) NVIC_ISER4 = interruptSave[4];
     ff4:	4b05      	ldr	r3, [pc, #20]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
     ff6:	7cdb      	ldrb	r3, [r3, #19]
     ff8:	f013 0f10 	tst.w	r3, #16
     ffc:	d003      	beq.n	1006 <Sd2Card::chipSelectHigh()+0x76>
     ffe:	4b03      	ldr	r3, [pc, #12]	; (100c <Sd2Card::chipSelectHigh()+0x7c>)
    1000:	6b9a      	ldr	r2, [r3, #56]	; 0x38
    1002:	4b07      	ldr	r3, [pc, #28]	; (1020 <Sd2Card::chipSelectHigh()+0x90>)
    1004:	601a      	str	r2, [r3, #0]
    1006:	bd08      	pop	{r3, pc}
    1008:	20001168 	.word	0x20001168
    100c:	20000644 	.word	0x20000644
    1010:	e000e100 	.word	0xe000e100
    1014:	e000e104 	.word	0xe000e104
    1018:	e000e108 	.word	0xe000e108
    101c:	e000e10c 	.word	0xe000e10c
    1020:	e000e110 	.word	0xe000e110

00001024 <Sd2Card::chipSelectLow()>:
    SPI.endTransaction();
  }
#endif
}
//------------------------------------------------------------------------------
void Sd2Card::chipSelectLow(void) {
    1024:	b510      	push	{r4, lr}
    1026:	b082      	sub	sp, #8
    1028:	4602      	mov	r2, r0
#ifdef SPI_HAS_TRANSACTION
  if (!chip_select_asserted) {
    102a:	4b4a      	ldr	r3, [pc, #296]	; (1154 <Sd2Card::chipSelectLow()+0x130>)
    102c:	781b      	ldrb	r3, [r3, #0]
    102e:	2b00      	cmp	r3, #0
    1030:	f040 808a 	bne.w	1148 <Sd2Card::chipSelectLow()+0x124>
    chip_select_asserted = 1;
    1034:	2101      	movs	r1, #1
    1036:	4b47      	ldr	r3, [pc, #284]	; (1154 <Sd2Card::chipSelectLow()+0x130>)
    1038:	7019      	strb	r1, [r3, #0]
    103a:	4b47      	ldr	r3, [pc, #284]	; (1158 <Sd2Card::chipSelectLow()+0x134>)
    103c:	e893 0003 	ldmia.w	r3, {r0, r1}
    1040:	ab02      	add	r3, sp, #8
    1042:	e903 0003 	stmdb	r3, {r0, r1}

	// Before using SPI.transfer() or asserting chip select pins,
	// this function is used to gain exclusive access to the SPI bus
	// and configure the correct settings.
	void beginTransaction(SPISettings settings) {
		if (interruptMasksUsed) {
    1046:	4b45      	ldr	r3, [pc, #276]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1048:	7cdb      	ldrb	r3, [r3, #19]
    104a:	2b00      	cmp	r3, #0
    104c:	d03d      	beq.n	10ca <Sd2Card::chipSelectLow()+0xa6>
			__disable_irq();
    104e:	b672      	cpsid	i
			if (interruptMasksUsed & 0x01) {
    1050:	4b42      	ldr	r3, [pc, #264]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1052:	7cdb      	ldrb	r3, [r3, #19]
    1054:	f013 0f01 	tst.w	r3, #1
    1058:	d006      	beq.n	1068 <Sd2Card::chipSelectLow()+0x44>
				interruptSave[0] = NVIC_ICER0 & interruptMask[0];
    105a:	4941      	ldr	r1, [pc, #260]	; (1160 <Sd2Card::chipSelectLow()+0x13c>)
    105c:	680c      	ldr	r4, [r1, #0]
    105e:	483f      	ldr	r0, [pc, #252]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1060:	6943      	ldr	r3, [r0, #20]
    1062:	4023      	ands	r3, r4
    1064:	6283      	str	r3, [r0, #40]	; 0x28
				NVIC_ICER0 = interruptSave[0];
    1066:	600b      	str	r3, [r1, #0]
			}
			if (interruptMasksUsed & 0x02) {
    1068:	4b3c      	ldr	r3, [pc, #240]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    106a:	7cdb      	ldrb	r3, [r3, #19]
    106c:	f013 0f02 	tst.w	r3, #2
    1070:	d006      	beq.n	1080 <Sd2Card::chipSelectLow()+0x5c>
				interruptSave[1] = NVIC_ICER1 & interruptMask[1];
    1072:	493c      	ldr	r1, [pc, #240]	; (1164 <Sd2Card::chipSelectLow()+0x140>)
    1074:	680c      	ldr	r4, [r1, #0]
    1076:	4839      	ldr	r0, [pc, #228]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1078:	6983      	ldr	r3, [r0, #24]
    107a:	4023      	ands	r3, r4
    107c:	62c3      	str	r3, [r0, #44]	; 0x2c
				NVIC_ICER1 = interruptSave[1];
    107e:	600b      	str	r3, [r1, #0]
			}
			if (interruptMasksUsed & 0x04) {
    1080:	4b36      	ldr	r3, [pc, #216]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1082:	7cdb      	ldrb	r3, [r3, #19]
    1084:	f013 0f04 	tst.w	r3, #4
    1088:	d006      	beq.n	1098 <Sd2Card::chipSelectLow()+0x74>
				interruptSave[2] = NVIC_ICER2 & interruptMask[2];
    108a:	4937      	ldr	r1, [pc, #220]	; (1168 <Sd2Card::chipSelectLow()+0x144>)
    108c:	680c      	ldr	r4, [r1, #0]
    108e:	4833      	ldr	r0, [pc, #204]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1090:	69c3      	ldr	r3, [r0, #28]
    1092:	4023      	ands	r3, r4
    1094:	6303      	str	r3, [r0, #48]	; 0x30
				NVIC_ICER2 = interruptSave[2];
    1096:	600b      	str	r3, [r1, #0]
			}
			if (interruptMasksUsed & 0x08) {
    1098:	4b30      	ldr	r3, [pc, #192]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    109a:	7cdb      	ldrb	r3, [r3, #19]
    109c:	f013 0f08 	tst.w	r3, #8
    10a0:	d006      	beq.n	10b0 <Sd2Card::chipSelectLow()+0x8c>
				interruptSave[3] = NVIC_ICER3 & interruptMask[3];
    10a2:	4932      	ldr	r1, [pc, #200]	; (116c <Sd2Card::chipSelectLow()+0x148>)
    10a4:	680c      	ldr	r4, [r1, #0]
    10a6:	482d      	ldr	r0, [pc, #180]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    10a8:	6a03      	ldr	r3, [r0, #32]
    10aa:	4023      	ands	r3, r4
    10ac:	6343      	str	r3, [r0, #52]	; 0x34
				NVIC_ICER3 = interruptSave[3];
    10ae:	600b      	str	r3, [r1, #0]
			}
			if (interruptMasksUsed & 0x10) {
    10b0:	4b2a      	ldr	r3, [pc, #168]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    10b2:	7cdb      	ldrb	r3, [r3, #19]
    10b4:	f013 0f10 	tst.w	r3, #16
    10b8:	d006      	beq.n	10c8 <Sd2Card::chipSelectLow()+0xa4>
				interruptSave[4] = NVIC_ICER4 & interruptMask[4];
    10ba:	492d      	ldr	r1, [pc, #180]	; (1170 <Sd2Card::chipSelectLow()+0x14c>)
    10bc:	680c      	ldr	r4, [r1, #0]
    10be:	4827      	ldr	r0, [pc, #156]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    10c0:	6a43      	ldr	r3, [r0, #36]	; 0x24
    10c2:	4023      	ands	r3, r4
    10c4:	6383      	str	r3, [r0, #56]	; 0x38
				NVIC_ICER4 = interruptSave[4];
    10c6:	600b      	str	r3, [r1, #0]
			}
			__enable_irq();
    10c8:	b662      	cpsie	i
			// Note: On T3.2 when we set CPHA it also updated the timing.  It moved the 
			// PCS to SCK Delay Prescaler into the After SCK Delay Prescaler	
			if (dataMode & 0x04) tcr |= LPSPI_TCR_CPHA; 
	}

	inline uint32_t clock() {return _clock;}
    10ca:	9800      	ldr	r0, [sp, #0]
		}
		inTransactionFlag = 1;
		#endif

		//printf("trans\n");
		if (settings.clock() != _clock) {
    10cc:	4b23      	ldr	r3, [pc, #140]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    10ce:	689b      	ldr	r3, [r3, #8]
    10d0:	4298      	cmp	r0, r3
    10d2:	d02d      	beq.n	1130 <Sd2Card::chipSelectLow()+0x10c>
						     720000000,  // PLL3 PFD0
						     528000000,  // PLL2
						     396000000}; // PLL2 PFD2				

		    // First save away the new settings..
		    _clock = settings.clock();
    10d4:	4b21      	ldr	r3, [pc, #132]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    10d6:	6098      	str	r0, [r3, #8]

			uint32_t cbcmr = CCM_CBCMR;
    10d8:	4b26      	ldr	r3, [pc, #152]	; (1174 <Sd2Card::chipSelectLow()+0x150>)
    10da:	699b      	ldr	r3, [r3, #24]
			uint32_t clkhz = clk_sel[(cbcmr >> 4) & 0x03] / (((cbcmr >> 26 ) & 0x07 ) + 1);  // LPSPI peripheral clock
    10dc:	f3c3 1401 	ubfx	r4, r3, #4, #2
    10e0:	4925      	ldr	r1, [pc, #148]	; (1178 <Sd2Card::chipSelectLow()+0x154>)
    10e2:	f851 1024 	ldr.w	r1, [r1, r4, lsl #2]
    10e6:	f3c3 6382 	ubfx	r3, r3, #26, #3
    10ea:	3301      	adds	r3, #1
    10ec:	fbb1 f1f3 	udiv	r1, r1, r3
			
			uint32_t d, div;		
			d = _clock ? clkhz/_clock : clkhz;
    10f0:	b110      	cbz	r0, 10f8 <Sd2Card::chipSelectLow()+0xd4>
    10f2:	fbb1 f3f0 	udiv	r3, r1, r0
    10f6:	e000      	b.n	10fa <Sd2Card::chipSelectLow()+0xd6>
    10f8:	460b      	mov	r3, r1

			if (d && clkhz/d > _clock) d++;
    10fa:	b123      	cbz	r3, 1106 <Sd2Card::chipSelectLow()+0xe2>
    10fc:	fbb1 f1f3 	udiv	r1, r1, r3
    1100:	4288      	cmp	r0, r1
    1102:	d200      	bcs.n	1106 <Sd2Card::chipSelectLow()+0xe2>
    1104:	3301      	adds	r3, #1
			if (d > 257) d= 257;  // max div
    1106:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    110a:	d301      	bcc.n	1110 <Sd2Card::chipSelectLow()+0xec>
    110c:	f240 1301 	movw	r3, #257	; 0x101
			if (d > 2) {
    1110:	2b02      	cmp	r3, #2
    1112:	d901      	bls.n	1118 <Sd2Card::chipSelectLow()+0xf4>
				div = d-2;
    1114:	3b02      	subs	r3, #2
    1116:	e000      	b.n	111a <Sd2Card::chipSelectLow()+0xf6>
			} else {
				div =0;
    1118:	2300      	movs	r3, #0
			}
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);
    111a:	b2d8      	uxtb	r0, r3
    111c:	085b      	lsrs	r3, r3, #1
    111e:	0219      	lsls	r1, r3, #8
    1120:	b289      	uxth	r1, r1
    1122:	4301      	orrs	r1, r0
    1124:	041b      	lsls	r3, r3, #16
    1126:	f403 037f 	and.w	r3, r3, #16711680	; 0xff0000
    112a:	430b      	orrs	r3, r1
    112c:	490b      	ldr	r1, [pc, #44]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    112e:	60cb      	str	r3, [r1, #12]
	// programs/sketches.  See the ILI3941_t3 library for an example.
	uint8_t setCS(uint8_t pin);

private:
private:
	IMXRT_LPSPI_t & port() { return *(IMXRT_LPSPI_t *)port_addr; }
    1130:	490a      	ldr	r1, [pc, #40]	; (115c <Sd2Card::chipSelectLow()+0x138>)
    1132:	680b      	ldr	r3, [r1, #0]
	
			_ccr = LPSPI_CCR_SCKDIV(div) | LPSPI_CCR_DBT(div/2) | LPSPI_CCR_PCSSCK(div/2);

		} 
		//Serial.printf("SPI.beginTransaction CCR:%x TCR:%x\n", _ccr, settings.tcr);
		port().CR = 0;
    1134:	2000      	movs	r0, #0
    1136:	6118      	str	r0, [r3, #16]
		port().CFGR1 = LPSPI_CFGR1_MASTER | LPSPI_CFGR1_SAMPLE;
    1138:	2003      	movs	r0, #3
    113a:	6258      	str	r0, [r3, #36]	; 0x24
		port().CCR = _ccr;
    113c:	68c9      	ldr	r1, [r1, #12]
    113e:	6419      	str	r1, [r3, #64]	; 0x40
		port().TCR = settings.tcr;
    1140:	9901      	ldr	r1, [sp, #4]
    1142:	6619      	str	r1, [r3, #96]	; 0x60
		port().CR = LPSPI_CR_MEN;
    1144:	2101      	movs	r1, #1
    1146:	6119      	str	r1, [r3, #16]
    SPI.beginTransaction(settings);
  }
#endif
  digitalWrite(chipSelectPin_, LOW);
    1148:	2100      	movs	r1, #0
    114a:	7810      	ldrb	r0, [r2, #0]
    114c:	f001 fbe4 	bl	2918 <digitalWrite>
}
    1150:	b002      	add	sp, #8
    1152:	bd10      	pop	{r4, pc}
    1154:	20001168 	.word	0x20001168
    1158:	20001160 	.word	0x20001160
    115c:	20000644 	.word	0x20000644
    1160:	e000e180 	.word	0xe000e180
    1164:	e000e184 	.word	0xe000e184
    1168:	e000e188 	.word	0xe000e188
    116c:	e000e18c 	.word	0xe000e18c
    1170:	e000e190 	.word	0xe000e190
    1174:	400fc000 	.word	0x400fc000
    1178:	20000270 	.word	0x20000270

0000117c <Sd2Card::waitNotBusy(unsigned int)>:
  return true;
#endif
}
//------------------------------------------------------------------------------
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
    117c:	b538      	push	{r3, r4, r5, lr}
    117e:	460d      	mov	r5, r1
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
    1180:	4b07      	ldr	r3, [pc, #28]	; (11a0 <Sd2Card::waitNotBusy(unsigned int)+0x24>)
    1182:	681c      	ldr	r4, [r3, #0]
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
    1184:	f7ff fec4 	bl	f10 <spiRec()>
    1188:	28ff      	cmp	r0, #255	; 0xff
    118a:	d006      	beq.n	119a <Sd2Card::waitNotBusy(unsigned int)+0x1e>
    118c:	4b04      	ldr	r3, [pc, #16]	; (11a0 <Sd2Card::waitNotBusy(unsigned int)+0x24>)
    118e:	681b      	ldr	r3, [r3, #0]
    d = millis() - t0;
    1190:	1b1b      	subs	r3, r3, r4
  }
  while (d < timeoutMillis);
    1192:	42ab      	cmp	r3, r5
    1194:	d3f6      	bcc.n	1184 <Sd2Card::waitNotBusy(unsigned int)+0x8>
  return false;
    1196:	2000      	movs	r0, #0
    1198:	bd38      	pop	{r3, r4, r5, pc}
// wait for card to go not busy
uint8_t Sd2Card::waitNotBusy(unsigned int timeoutMillis) {
  unsigned int t0 = millis();
  unsigned int d;
  do {
    if (spiRec() == 0XFF) return true;
    119a:	2001      	movs	r0, #1
    d = millis() - t0;
  }
  while (d < timeoutMillis);
  return false;
}
    119c:	bd38      	pop	{r3, r4, r5, pc}
    119e:	bf00      	nop
    11a0:	200013d4 	.word	0x200013d4

000011a4 <Sd2Card::cardCommand(unsigned char, unsigned long)>:


//------------------------------------------------------------------------------
// send command and return error code.  Return zero for OK
uint8_t Sd2Card::cardCommand(uint8_t cmd, uint32_t arg)
{
    11a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    11a6:	4605      	mov	r5, r0
    11a8:	460f      	mov	r7, r1
    11aa:	4616      	mov	r6, r2
  // wait up to 300 ms if busy
  waitNotBusy(300);
    11ac:	f44f 7196 	mov.w	r1, #300	; 0x12c
    11b0:	f7ff ffe4 	bl	117c <Sd2Card::waitNotBusy(unsigned int)>

  // send command
  spiSend(cmd | 0x40);
    11b4:	f047 0040 	orr.w	r0, r7, #64	; 0x40
    11b8:	f7ff fe9e 	bl	ef8 <spiSend(unsigned char)>

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);
    11bc:	2418      	movs	r4, #24
    11be:	2c00      	cmp	r4, #0
    11c0:	db07      	blt.n	11d2 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x2e>
    11c2:	fa26 f004 	lsr.w	r0, r6, r4
    11c6:	b2c0      	uxtb	r0, r0
    11c8:	f7ff fe96 	bl	ef8 <spiSend(unsigned char)>
    11cc:	3c08      	subs	r4, #8
    11ce:	b264      	sxtb	r4, r4
    11d0:	e7f5      	b.n	11be <Sd2Card::cardCommand(unsigned char, unsigned long)+0x1a>

  // send CRC
  uint8_t crc = 0XFF;
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
    11d2:	b10f      	cbz	r7, 11d8 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x34>

  // send argument
  for (int8_t s = 24; s >= 0; s -= 8) spiSend(arg >> s);

  // send CRC
  uint8_t crc = 0XFF;
    11d4:	20ff      	movs	r0, #255	; 0xff
    11d6:	e000      	b.n	11da <Sd2Card::cardCommand(unsigned char, unsigned long)+0x36>
  if (cmd == CMD0) crc = 0X95;  // correct crc for CMD0 with arg 0
    11d8:	2095      	movs	r0, #149	; 0x95
  if (cmd == CMD8) crc = 0X87;  // correct crc for CMD8 with arg 0X1AA
    11da:	2f08      	cmp	r7, #8
    11dc:	d100      	bne.n	11e0 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x3c>
    11de:	2087      	movs	r0, #135	; 0x87
  spiSend(crc);
    11e0:	f7ff fe8a 	bl	ef8 <spiSend(unsigned char)>

  // wait for response
  for (uint8_t i = 0; ((status_ = spiRec()) & 0X80) && i != 0XFF; i++);
    11e4:	2400      	movs	r4, #0
    11e6:	f7ff fe93 	bl	f10 <spiRec()>
    11ea:	7068      	strb	r0, [r5, #1]
    11ec:	f010 0f80 	tst.w	r0, #128	; 0x80
    11f0:	d003      	beq.n	11fa <Sd2Card::cardCommand(unsigned char, unsigned long)+0x56>
    11f2:	2cff      	cmp	r4, #255	; 0xff
    11f4:	d103      	bne.n	11fe <Sd2Card::cardCommand(unsigned char, unsigned long)+0x5a>
    11f6:	2300      	movs	r3, #0
    11f8:	e002      	b.n	1200 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x5c>
    11fa:	2300      	movs	r3, #0
    11fc:	e000      	b.n	1200 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x5c>
    11fe:	2301      	movs	r3, #1
    1200:	b113      	cbz	r3, 1208 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x64>
    1202:	3401      	adds	r4, #1
    1204:	b2e4      	uxtb	r4, r4
    1206:	e7ee      	b.n	11e6 <Sd2Card::cardCommand(unsigned char, unsigned long)+0x42>
  return status_;
}
    1208:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    120a:	bf00      	nop

0000120c <Sd2Card::waitStartBlock()>:
  while (d < timeoutMillis);
  return false;
}
//------------------------------------------------------------------------------
/** Wait for start block token */
uint8_t Sd2Card::waitStartBlock(void) {
    120c:	b538      	push	{r3, r4, r5, lr}
    120e:	4604      	mov	r4, r0
    1210:	4b0a      	ldr	r3, [pc, #40]	; (123c <Sd2Card::waitStartBlock()+0x30>)
    1212:	681d      	ldr	r5, [r3, #0]
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    1214:	f7ff fe7c 	bl	f10 <spiRec()>
    1218:	7060      	strb	r0, [r4, #1]
    121a:	28ff      	cmp	r0, #255	; 0xff
    121c:	d106      	bne.n	122c <Sd2Card::waitStartBlock()+0x20>
    121e:	4b07      	ldr	r3, [pc, #28]	; (123c <Sd2Card::waitStartBlock()+0x30>)
    1220:	681b      	ldr	r3, [r3, #0]
    unsigned int d = millis() - t0;
    1222:	1b5b      	subs	r3, r3, r5
    if (d > SD_READ_TIMEOUT) {
    1224:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
    1228:	d9f4      	bls.n	1214 <Sd2Card::waitStartBlock()+0x8>
    122a:	e003      	b.n	1234 <Sd2Card::waitStartBlock()+0x28>
      return false; // SD_CARD_ERROR_READ_TIMEOUT
    }
  }
  if (status_ != DATA_START_BLOCK) {
    122c:	28fe      	cmp	r0, #254	; 0xfe
    122e:	d003      	beq.n	1238 <Sd2Card::waitStartBlock()+0x2c>
    return false; // SD_CARD_ERROR_READ
    1230:	2000      	movs	r0, #0
    1232:	bd38      	pop	{r3, r4, r5, pc}
uint8_t Sd2Card::waitStartBlock(void) {
  unsigned int t0 = millis();
  while ((status_ = spiRec()) == 0XFF) {
    unsigned int d = millis() - t0;
    if (d > SD_READ_TIMEOUT) {
      return false; // SD_CARD_ERROR_READ_TIMEOUT
    1234:	2000      	movs	r0, #0
    1236:	bd38      	pop	{r3, r4, r5, pc}
    }
  }
  if (status_ != DATA_START_BLOCK) {
    return false; // SD_CARD_ERROR_READ
  }
  return true;
    1238:	2001      	movs	r0, #1
}
    123a:	bd38      	pop	{r3, r4, r5, pc}
    123c:	200013d4 	.word	0x200013d4

00001240 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>:

 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_readBlock(uint32_t block, uint8_t* dst)
{
    1240:	b570      	push	{r4, r5, r6, lr}
    1242:	4604      	mov	r4, r0
    1244:	460d      	mov	r5, r1
    1246:	4616      	mov	r6, r2
  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) block <<= 9;
    1248:	7883      	ldrb	r3, [r0, #2]
    124a:	2b03      	cmp	r3, #3
    124c:	d000      	beq.n	1250 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x10>
    124e:	024d      	lsls	r5, r1, #9
  chipSelectLow();
    1250:	4620      	mov	r0, r4
    1252:	f7ff fee7 	bl	1024 <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD17, block)) {
    1256:	462a      	mov	r2, r5
    1258:	2111      	movs	r1, #17
    125a:	4620      	mov	r0, r4
    125c:	f7ff ffa2 	bl	11a4 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    1260:	b980      	cbnz	r0, 1284 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x44>
    goto fail; // SD_CARD_ERROR_CMD17
  }
  if (!waitStartBlock()) {
    1262:	4620      	mov	r0, r4
    1264:	f7ff ffd2 	bl	120c <Sd2Card::waitStartBlock()>
    1268:	b160      	cbz	r0, 1284 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)+0x44>
    goto fail;
  }
#if defined(USE_TEENSY3_SPI) | defined(USE_SPI_LIB)
  spiRec(dst, 512);
    126a:	f44f 7100 	mov.w	r1, #512	; 0x200
    126e:	4630      	mov	r0, r6
    1270:	f7ff fe7e 	bl	f70 <spiRec(unsigned char*, unsigned int)>
  spiRecIgnore(2);
    1274:	2002      	movs	r0, #2
    1276:	f7ff fe59 	bl	f2c <spiRecIgnore(unsigned int)>
  dst[511] = SPDR;
  // skip CRC bytes
  spiRec();
  spiRec();
#endif
  chipSelectHigh();
    127a:	4620      	mov	r0, r4
    127c:	f7ff fe88 	bl	f90 <Sd2Card::chipSelectHigh()>
  return true;
    1280:	2001      	movs	r0, #1
    1282:	bd70      	pop	{r4, r5, r6, pc}

 fail:
  chipSelectHigh();
    1284:	4620      	mov	r0, r4
    1286:	f7ff fe83 	bl	f90 <Sd2Card::chipSelectHigh()>
  return false;
    128a:	2000      	movs	r0, #0
}
    128c:	bd70      	pop	{r4, r5, r6, pc}
    128e:	bf00      	nop

00001290 <Sd2Card::writeData(unsigned char, unsigned char const*)>:
  chipSelectHigh();
  return false;
}
//------------------------------------------------------------------------------
// send one block of data for write block or write multiple blocks
uint8_t Sd2Card::writeData(uint8_t token, const uint8_t* src) {
    1290:	b570      	push	{r4, r5, r6, lr}
    1292:	4606      	mov	r6, r0
    1294:	4615      	mov	r5, r2

  // wait for last data byte
  while (!(SPSR & (1 << SPIF)));

#else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
    1296:	4608      	mov	r0, r1
    1298:	f7ff fe2e 	bl	ef8 <spiSend(unsigned char)>
  for (uint16_t i = 0; i < 512; i++) {
    129c:	2400      	movs	r4, #0
    129e:	f5b4 7f00 	cmp.w	r4, #512	; 0x200
    12a2:	d205      	bcs.n	12b0 <Sd2Card::writeData(unsigned char, unsigned char const*)+0x20>
    spiSend(src[i]); 
    12a4:	5d28      	ldrb	r0, [r5, r4]
    12a6:	f7ff fe27 	bl	ef8 <spiSend(unsigned char)>
  // wait for last data byte
  while (!(SPSR & (1 << SPIF)));

#else  // OPTIMIZE_HARDWARE_SPI
  spiSend(token);
  for (uint16_t i = 0; i < 512; i++) {
    12aa:	3401      	adds	r4, #1
    12ac:	b2a4      	uxth	r4, r4
    12ae:	e7f6      	b.n	129e <Sd2Card::writeData(unsigned char, unsigned char const*)+0xe>
    spiSend(src[i]); 
  }
#endif  // OPTIMIZE_HARDWARE_SPI
  spiSend(0xff);  // dummy crc
    12b0:	20ff      	movs	r0, #255	; 0xff
    12b2:	f7ff fe21 	bl	ef8 <spiSend(unsigned char)>
  spiSend(0xff);  // dummy crc
    12b6:	20ff      	movs	r0, #255	; 0xff
    12b8:	f7ff fe1e 	bl	ef8 <spiSend(unsigned char)>

  status_ = spiRec();
    12bc:	f7ff fe28 	bl	f10 <spiRec()>
    12c0:	7070      	strb	r0, [r6, #1]
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    12c2:	f000 001f 	and.w	r0, r0, #31
    12c6:	2805      	cmp	r0, #5
    12c8:	d001      	beq.n	12ce <Sd2Card::writeData(unsigned char, unsigned char const*)+0x3e>
    return false; // SD_CARD_ERROR_WRITE
    12ca:	2000      	movs	r0, #0
    12cc:	bd70      	pop	{r4, r5, r6, pc}
  }
  return true;
    12ce:	2001      	movs	r0, #1
}
    12d0:	bd70      	pop	{r4, r5, r6, pc}
    12d2:	bf00      	nop

000012d4 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>:
 * \param[in] blockNumber Logical block to be written.
 * \param[in] src Pointer to the location of the data to be written.
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t Sd2Card::SD_writeBlock(uint32_t blockNumber, const uint8_t* src) {
    12d4:	b570      	push	{r4, r5, r6, lr}
    12d6:	4604      	mov	r4, r0
#if SD_PROTECT_BLOCK_ZERO
  // don't allow write to first block
  if (blockNumber == 0) {
    12d8:	b371      	cbz	r1, 1338 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x64>
    12da:	4616      	mov	r6, r2
    12dc:	460d      	mov	r5, r1
    goto fail; // SD_CARD_ERROR_WRITE_BLOCK_ZERO
  }
#endif  // SD_PROTECT_BLOCK_ZERO

  // use address if not SDHC card
  if (type_ != SD_CARD_TYPE_SDHC) blockNumber <<= 9;
    12de:	7883      	ldrb	r3, [r0, #2]
    12e0:	2b03      	cmp	r3, #3
    12e2:	d000      	beq.n	12e6 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x12>
    12e4:	024d      	lsls	r5, r1, #9
  chipSelectLow();
    12e6:	4620      	mov	r0, r4
    12e8:	f7ff fe9c 	bl	1024 <Sd2Card::chipSelectLow()>
  if (cardCommand(CMD24, blockNumber)) {
    12ec:	462a      	mov	r2, r5
    12ee:	2118      	movs	r1, #24
    12f0:	4620      	mov	r0, r4
    12f2:	f7ff ff57 	bl	11a4 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    12f6:	b9f8      	cbnz	r0, 1338 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x64>
    goto fail; // SD_CARD_ERROR_CMD24
  }
  if (!writeData(DATA_START_BLOCK, src)) goto fail;
    12f8:	4632      	mov	r2, r6
    12fa:	21fe      	movs	r1, #254	; 0xfe
    12fc:	4620      	mov	r0, r4
    12fe:	f7ff ffc7 	bl	1290 <Sd2Card::writeData(unsigned char, unsigned char const*)>
    1302:	b1c8      	cbz	r0, 1338 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x64>

  // wait for flash programming to complete
  if (!waitNotBusy(SD_WRITE_TIMEOUT)) {
    1304:	f44f 7116 	mov.w	r1, #600	; 0x258
    1308:	4620      	mov	r0, r4
    130a:	f7ff ff37 	bl	117c <Sd2Card::waitNotBusy(unsigned int)>
    130e:	b198      	cbz	r0, 1338 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x64>
    goto fail; // SD_CARD_ERROR_WRITE_TIMEOUT
  }
  // response is r2 so get and check two bytes for nonzero
  if (cardCommand(CMD13, 0) || spiRec()) {
    1310:	2200      	movs	r2, #0
    1312:	210d      	movs	r1, #13
    1314:	4620      	mov	r0, r4
    1316:	f7ff ff45 	bl	11a4 <Sd2Card::cardCommand(unsigned char, unsigned long)>
    131a:	b920      	cbnz	r0, 1326 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x52>
    131c:	f7ff fdf8 	bl	f10 <spiRec()>
    1320:	b918      	cbnz	r0, 132a <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x56>
    1322:	2300      	movs	r3, #0
    1324:	e002      	b.n	132c <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x58>
    1326:	2301      	movs	r3, #1
    1328:	e000      	b.n	132c <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x58>
    132a:	2301      	movs	r3, #1
    132c:	b923      	cbnz	r3, 1338 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)+0x64>
    goto fail; // SD_CARD_ERROR_WRITE_PROGRAMMING
  }
  chipSelectHigh();
    132e:	4620      	mov	r0, r4
    1330:	f7ff fe2e 	bl	f90 <Sd2Card::chipSelectHigh()>
  return true;
    1334:	2001      	movs	r0, #1
    1336:	bd70      	pop	{r4, r5, r6, pc}

 fail:
  chipSelectHigh();
    1338:	4620      	mov	r0, r4
    133a:	f7ff fe29 	bl	f90 <Sd2Card::chipSelectHigh()>
  return false;
    133e:	2000      	movs	r0, #0
}
    1340:	bd70      	pop	{r4, r5, r6, pc}
    1342:	bf00      	nop

00001344 <_GLOBAL__sub_I__ZN7Sd2Card11cardCommandEhm>:
  status_ = spiRec();
  if ((status_ & DATA_RES_MASK) != DATA_RES_ACCEPTED) {
    return false; // SD_CARD_ERROR_WRITE
  }
  return true;
}
    1344:	b508      	push	{r3, lr}
    1346:	f64f 71ff 	movw	r1, #65535	; 0xffff
    134a:	2001      	movs	r0, #1
    134c:	f7ff fe00 	bl	f50 <__static_initialization_and_destruction_0(int, int)>
    1350:	bd08      	pop	{r3, pc}
    1352:	bf00      	nop

00001354 <SdFile::addCluster()>:
// suppress cpplint warnings with NOLINT comment
void (*SdFile::oldDateTime_)(uint16_t& date, uint16_t& time) = NULL;  // NOLINT
#endif  // ALLOW_DEPRECATED_FUNCTIONS
//------------------------------------------------------------------------------
// add a cluster to a file
uint8_t SdFile::addCluster() {
    1354:	b510      	push	{r4, lr}
    1356:	4604      	mov	r4, r0
  if (!vol_->allocContiguous(1, &curCluster_)) return false;
    1358:	f100 0208 	add.w	r2, r0, #8
    135c:	2101      	movs	r1, #1
    135e:	6a00      	ldr	r0, [r0, #32]
    1360:	f000 fa72 	bl	1848 <SdVolume::allocContiguous(unsigned long, unsigned long*)>
    1364:	4603      	mov	r3, r0
    1366:	b150      	cbz	r0, 137e <SdFile::addCluster()+0x2a>

  // if first cluster of file link to directory entry
  if (firstCluster_ == 0) {
    1368:	69e3      	ldr	r3, [r4, #28]
    136a:	b93b      	cbnz	r3, 137c <SdFile::addCluster()+0x28>
    firstCluster_ = curCluster_;
    136c:	68a3      	ldr	r3, [r4, #8]
    136e:	61e3      	str	r3, [r4, #28]
    flags_ |= F_FILE_DIR_DIRTY;
    1370:	7963      	ldrb	r3, [r4, #5]
    1372:	f063 037f 	orn	r3, r3, #127	; 0x7f
    1376:	7163      	strb	r3, [r4, #5]
  }
  return true;
    1378:	2301      	movs	r3, #1
    137a:	e000      	b.n	137e <SdFile::addCluster()+0x2a>
    137c:	2301      	movs	r3, #1
}
    137e:	4618      	mov	r0, r3
    1380:	bd10      	pop	{r4, pc}
    1382:	bf00      	nop

00001384 <SdFile::cacheDirEntry(unsigned char)>:
  return true;
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
    1384:	b510      	push	{r4, lr}
    1386:	4604      	mov	r4, r0
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
    1388:	6900      	ldr	r0, [r0, #16]
    138a:	f000 f9af 	bl	16ec <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    138e:	b120      	cbz	r0, 139a <SdFile::cacheDirEntry(unsigned char)+0x16>
  return SdVolume::cacheBuffer_.dir + dirIndex_;
    1390:	7d20      	ldrb	r0, [r4, #20]
    1392:	4b03      	ldr	r3, [pc, #12]	; (13a0 <SdFile::cacheDirEntry(unsigned char)+0x1c>)
    1394:	eb03 1040 	add.w	r0, r3, r0, lsl #5
    1398:	bd10      	pop	{r4, pc}
}
//------------------------------------------------------------------------------
// cache a file's directory entry
// return pointer to cached entry or null for failure
dir_t* SdFile::cacheDirEntry(uint8_t action) {
  if (!SdVolume::cacheRawBlock(dirBlock_, action)) return NULL;
    139a:	2000      	movs	r0, #0
  return SdVolume::cacheBuffer_.dir + dirIndex_;
}
    139c:	bd10      	pop	{r4, pc}
    139e:	bf00      	nop
    13a0:	20001178 	.word	0x20001178

000013a4 <SdFile::seekSet(unsigned long)>:
  /** \return True if this is a SdFile for a directory else false. */
  uint8_t isDir(void) const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
  /** \return True if this is a SdFile for a file else false. */
  uint8_t isFile(void) const {return type_ == FAT_FILE_TYPE_NORMAL;}
  /** \return True if this is a SdFile for an open file/directory else false. */
  uint8_t isOpen(void) const {return type_ != FAT_FILE_TYPE_CLOSED;}
    13a4:	7983      	ldrb	r3, [r0, #6]
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
    13a6:	b123      	cbz	r3, 13b2 <SdFile::seekSet(unsigned long)+0xe>
    13a8:	6982      	ldr	r2, [r0, #24]
    13aa:	428a      	cmp	r2, r1
    13ac:	d203      	bcs.n	13b6 <SdFile::seekSet(unsigned long)+0x12>
    13ae:	2201      	movs	r2, #1
    13b0:	e002      	b.n	13b8 <SdFile::seekSet(unsigned long)+0x14>
    13b2:	2201      	movs	r2, #1
    13b4:	e000      	b.n	13b8 <SdFile::seekSet(unsigned long)+0x14>
    13b6:	2200      	movs	r2, #0
    13b8:	bb6a      	cbnz	r2, 1416 <SdFile::seekSet(unsigned long)+0x72>

  if (type_ == FAT_FILE_TYPE_ROOT16) {
    13ba:	2b02      	cmp	r3, #2
    13bc:	d102      	bne.n	13c4 <SdFile::seekSet(unsigned long)+0x20>
    curPosition_ = pos;
    13be:	60c1      	str	r1, [r0, #12]
    return true;
    13c0:	2201      	movs	r2, #1
    13c2:	e029      	b.n	1418 <SdFile::seekSet(unsigned long)+0x74>
  }
  if (pos == 0) {
    13c4:	b921      	cbnz	r1, 13d0 <SdFile::seekSet(unsigned long)+0x2c>
    // set position to start of file
    curCluster_ = 0;
    13c6:	2300      	movs	r3, #0
    13c8:	6083      	str	r3, [r0, #8]
    curPosition_ = 0;
    13ca:	60c3      	str	r3, [r0, #12]
    return true;
    13cc:	2201      	movs	r2, #1
    13ce:	e023      	b.n	1418 <SdFile::seekSet(unsigned long)+0x74>
 * \param[in] pos The new position in bytes from the beginning of the file.
 *
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
    13d0:	b570      	push	{r4, r5, r6, lr}
    13d2:	460e      	mov	r6, r1
    13d4:	4604      	mov	r4, r0
    curCluster_ = 0;
    curPosition_ = 0;
    return true;
  }
  // calculate cluster index for cur and new position
  uint32_t nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
    13d6:	68c0      	ldr	r0, [r0, #12]
    13d8:	1e41      	subs	r1, r0, #1
    13da:	6a23      	ldr	r3, [r4, #32]
    13dc:	7c1b      	ldrb	r3, [r3, #16]
    13de:	f103 0209 	add.w	r2, r3, #9
    13e2:	40d1      	lsrs	r1, r2
  uint32_t nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
    13e4:	1e73      	subs	r3, r6, #1
    13e6:	40d3      	lsrs	r3, r2

  if (nNew < nCur || curPosition_ == 0) {
    13e8:	4299      	cmp	r1, r3
    13ea:	d800      	bhi.n	13ee <SdFile::seekSet(unsigned long)+0x4a>
    13ec:	b910      	cbnz	r0, 13f4 <SdFile::seekSet(unsigned long)+0x50>
    // must follow chain from first cluster
    curCluster_ = firstCluster_;
    13ee:	69e2      	ldr	r2, [r4, #28]
    13f0:	60a2      	str	r2, [r4, #8]
    13f2:	e000      	b.n	13f6 <SdFile::seekSet(unsigned long)+0x52>
  } else {
    // advance from curPosition
    nNew -= nCur;
    13f4:	1a5b      	subs	r3, r3, r1
  }
  while (nNew--) {
    13f6:	1e5d      	subs	r5, r3, #1
    13f8:	b153      	cbz	r3, 1410 <SdFile::seekSet(unsigned long)+0x6c>
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
    13fa:	f104 0208 	add.w	r2, r4, #8
    13fe:	68a1      	ldr	r1, [r4, #8]
    1400:	6a20      	ldr	r0, [r4, #32]
    1402:	f000 f9a3 	bl	174c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    curCluster_ = firstCluster_;
  } else {
    // advance from curPosition
    nNew -= nCur;
  }
  while (nNew--) {
    1406:	462b      	mov	r3, r5
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
    1408:	4602      	mov	r2, r0
    140a:	2800      	cmp	r0, #0
    140c:	d1f3      	bne.n	13f6 <SdFile::seekSet(unsigned long)+0x52>
    140e:	e005      	b.n	141c <SdFile::seekSet(unsigned long)+0x78>
  }
  curPosition_ = pos;
    1410:	60e6      	str	r6, [r4, #12]
  return true;
    1412:	2201      	movs	r2, #1
    1414:	e002      	b.n	141c <SdFile::seekSet(unsigned long)+0x78>
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 */
uint8_t SdFile::seekSet(uint32_t pos) {
  // error if file not open or seek past end of file
  if (!isOpen() || pos > fileSize_) return false;
    1416:	2200      	movs	r2, #0
  while (nNew--) {
    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
  }
  curPosition_ = pos;
  return true;
}
    1418:	4610      	mov	r0, r2
    141a:	4770      	bx	lr
    141c:	4610      	mov	r0, r2
    141e:	bd70      	pop	{r4, r5, r6, pc}

00001420 <SdFile::sync()>:
 * \return The value one, true, is returned for success and
 * the value zero, false, is returned for failure.
 * Reasons for failure include a call to sync() before a file has been
 * opened or an I/O error.
 */
uint8_t SdFile::sync(void) {
    1420:	b538      	push	{r3, r4, r5, lr}
    1422:	4603      	mov	r3, r0
    1424:	7980      	ldrb	r0, [r0, #6]
  // only allow open files and directories
  if (!isOpen()) return false;
    1426:	b328      	cbz	r0, 1474 <SdFile::sync()+0x54>
    1428:	461c      	mov	r4, r3

  if (flags_ & F_FILE_DIR_DIRTY) {
    142a:	f993 3005 	ldrsb.w	r3, [r3, #5]
    142e:	2b00      	cmp	r3, #0
    1430:	da1c      	bge.n	146c <SdFile::sync()+0x4c>
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    1432:	2101      	movs	r1, #1
    1434:	4620      	mov	r0, r4
    1436:	f7ff ffa5 	bl	1384 <SdFile::cacheDirEntry(unsigned char)>
    if (!d) return false;
    143a:	4605      	mov	r5, r0
    143c:	b1c8      	cbz	r0, 1472 <SdFile::sync()+0x52>
  /** \return The total number of bytes in a file or directory. */
  uint32_t fileSize(void) const {return fileSize_;}
  /** \return The first cluster number for a file or directory. */
  uint32_t firstCluster(void) const {return firstCluster_;}
  /** \return True if this is a SdFile for a directory else false. */
  uint8_t isDir(void) const {return type_ >= FAT_FILE_TYPE_MIN_DIR;}
    143e:	79a3      	ldrb	r3, [r4, #6]

    // do not set filesize for dir files
    if (!isDir()) d->fileSize = fileSize_;
    1440:	2b01      	cmp	r3, #1
    1442:	d801      	bhi.n	1448 <SdFile::sync()+0x28>
    1444:	69a3      	ldr	r3, [r4, #24]
    1446:	61c3      	str	r3, [r0, #28]

    // update first cluster fields
    d->firstClusterLow = firstCluster_ & 0XFFFF;
    1448:	8ba3      	ldrh	r3, [r4, #28]
    144a:	836b      	strh	r3, [r5, #26]
    d->firstClusterHigh = firstCluster_ >> 16;
    144c:	8be3      	ldrh	r3, [r4, #30]
    144e:	82ab      	strh	r3, [r5, #20]

    // set modify time if user supplied a callback date/time function
    if (dateTime_) {
    1450:	4b09      	ldr	r3, [pc, #36]	; (1478 <SdFile::sync()+0x58>)
    1452:	681b      	ldr	r3, [r3, #0]
    1454:	b133      	cbz	r3, 1464 <SdFile::sync()+0x44>
      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
    1456:	f105 0116 	add.w	r1, r5, #22
    145a:	f105 0018 	add.w	r0, r5, #24
    145e:	4798      	blx	r3
      d->lastAccessDate = d->lastWriteDate;
    1460:	8b2b      	ldrh	r3, [r5, #24]
    1462:	826b      	strh	r3, [r5, #18]
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
    1464:	7963      	ldrb	r3, [r4, #5]
    1466:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    146a:	7163      	strb	r3, [r4, #5]
  }
  return SdVolume::cacheFlush();
    146c:	f000 f900 	bl	1670 <SdVolume::cacheFlush()>
    1470:	bd38      	pop	{r3, r4, r5, pc}
  // only allow open files and directories
  if (!isOpen()) return false;

  if (flags_ & F_FILE_DIR_DIRTY) {
    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
    if (!d) return false;
    1472:	2000      	movs	r0, #0
    }
    // clear directory dirty
    flags_ &= ~F_FILE_DIR_DIRTY;
  }
  return SdVolume::cacheFlush();
}
    1474:	bd38      	pop	{r3, r4, r5, pc}
    1476:	bf00      	nop
    1478:	2000116c 	.word	0x2000116c

0000147c <SdFile::write(void const*, unsigned int)>:
 * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
 * include write() is called before a file has been opened, write is called
 * for a read-only file, device is full, a corrupt file system or an I/O error.
 *
 */
size_t SdFile::write(const void* buf, size_t nbyte) {
    147c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    1480:	b083      	sub	sp, #12
    1482:	4606      	mov	r6, r0
    1484:	460c      	mov	r4, r1
    1486:	4690      	mov	r8, r2
  /** \return True if this is a SdFile for a file else false. */
  uint8_t isFile(void) const {return type_ == FAT_FILE_TYPE_NORMAL;}
    1488:	7983      	ldrb	r3, [r0, #6]

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    148a:	2b01      	cmp	r3, #1
    148c:	d105      	bne.n	149a <SdFile::write(void const*, unsigned int)+0x1e>
    148e:	7943      	ldrb	r3, [r0, #5]
    1490:	f013 0f02 	tst.w	r3, #2
    1494:	d103      	bne.n	149e <SdFile::write(void const*, unsigned int)+0x22>
    1496:	2301      	movs	r3, #1
    1498:	e002      	b.n	14a0 <SdFile::write(void const*, unsigned int)+0x24>
    149a:	2301      	movs	r3, #1
    149c:	e000      	b.n	14a0 <SdFile::write(void const*, unsigned int)+0x24>
    149e:	2300      	movs	r3, #0
    14a0:	2b00      	cmp	r3, #0
    14a2:	f040 80c3 	bne.w	162c <SdFile::write(void const*, unsigned int)+0x1b0>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    14a6:	7973      	ldrb	r3, [r6, #5]
    14a8:	f013 0f04 	tst.w	r3, #4
    14ac:	d101      	bne.n	14b2 <SdFile::write(void const*, unsigned int)+0x36>

  // number of bytes left to write  -  must be before goto statements
  size_t nToWrite = nbyte;

  // error if not a normal file or is read-only
  if (!isFile() || !(flags_ & O_WRITE)) goto writeErrorReturn;
    14ae:	4647      	mov	r7, r8
    14b0:	e00a      	b.n	14c8 <SdFile::write(void const*, unsigned int)+0x4c>

  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    14b2:	68f3      	ldr	r3, [r6, #12]
    14b4:	69b1      	ldr	r1, [r6, #24]
    14b6:	428b      	cmp	r3, r1
    14b8:	d0f9      	beq.n	14ae <SdFile::write(void const*, unsigned int)+0x32>
  }
  /**
   *  Set the files current position to end of file.  Useful to position
   *  a file for append. See seekSet().
   */
  uint8_t seekEnd(void) {return seekSet(fileSize_);}
    14ba:	4630      	mov	r0, r6
    14bc:	f7ff ff72 	bl	13a4 <SdFile::seekSet(unsigned long)>
    if (!seekEnd()) goto writeErrorReturn;
    14c0:	2800      	cmp	r0, #0
    14c2:	f000 80b3 	beq.w	162c <SdFile::write(void const*, unsigned int)+0x1b0>
    14c6:	e7f2      	b.n	14ae <SdFile::write(void const*, unsigned int)+0x32>
  }

  while (nToWrite > 0) {
    14c8:	2f00      	cmp	r7, #0
    14ca:	f000 8093 	beq.w	15f4 <SdFile::write(void const*, unsigned int)+0x178>
    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
    14ce:	6a30      	ldr	r0, [r6, #32]
    14d0:	68f3      	ldr	r3, [r6, #12]
  uint16_t rootDirEntryCount_;  // number of entries in FAT16 root dir
  uint32_t rootDirStart_;       // root start block for FAT16, cluster for FAT32
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
    14d2:	f890 9004 	ldrb.w	r9, [r0, #4]
    14d6:	f109 39ff 	add.w	r9, r9, #4294967295	; 0xffffffff
    14da:	ea09 2953 	and.w	r9, r9, r3, lsr #9
    uint16_t blockOffset = curPosition_ & 0X1FF;
    14de:	f3c3 0a08 	ubfx	sl, r3, #0, #9
    if (blockOfCluster == 0 && blockOffset == 0) {
    14e2:	f019 0bff 	ands.w	fp, r9, #255	; 0xff
    14e6:	bf0c      	ite	eq
    14e8:	2301      	moveq	r3, #1
    14ea:	2300      	movne	r3, #0
    14ec:	f1ba 0f00 	cmp.w	sl, #0
    14f0:	bf14      	ite	ne
    14f2:	2300      	movne	r3, #0
    14f4:	f003 0301 	andeq.w	r3, r3, #1
    14f8:	b313      	cbz	r3, 1540 <SdFile::write(void const*, unsigned int)+0xc4>
      // start of new cluster
      if (curCluster_ == 0) {
    14fa:	68b1      	ldr	r1, [r6, #8]
    14fc:	b941      	cbnz	r1, 1510 <SdFile::write(void const*, unsigned int)+0x94>
        if (firstCluster_ == 0) {
    14fe:	69f3      	ldr	r3, [r6, #28]
    1500:	b923      	cbnz	r3, 150c <SdFile::write(void const*, unsigned int)+0x90>
          // allocate first cluster of file
          if (!addCluster()) goto writeErrorReturn;
    1502:	4630      	mov	r0, r6
    1504:	f7ff ff26 	bl	1354 <SdFile::addCluster()>
    1508:	b9d0      	cbnz	r0, 1540 <SdFile::write(void const*, unsigned int)+0xc4>
    150a:	e08f      	b.n	162c <SdFile::write(void const*, unsigned int)+0x1b0>
        } else {
          curCluster_ = firstCluster_;
    150c:	60b3      	str	r3, [r6, #8]
    150e:	e017      	b.n	1540 <SdFile::write(void const*, unsigned int)+0xc4>
        }
      } else {
        uint32_t next;
        if (!vol_->fatGet(curCluster_, &next)) return false;
    1510:	aa01      	add	r2, sp, #4
    1512:	f000 f91b 	bl	174c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    1516:	2800      	cmp	r0, #0
    1518:	f000 808f 	beq.w	163a <SdFile::write(void const*, unsigned int)+0x1be>
        if (vol_->isEOC(next)) {
    151c:	6a32      	ldr	r2, [r6, #32]
    151e:	9b01      	ldr	r3, [sp, #4]
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
  }
  uint8_t freeChain(uint32_t cluster);
  uint8_t isEOC(uint32_t cluster) const {
    return  cluster >= (fatType_ == 16 ? FAT16EOC_MIN : FAT32EOC_MIN);
    1520:	f892 2020 	ldrb.w	r2, [r2, #32]
    1524:	2a10      	cmp	r2, #16
    1526:	d102      	bne.n	152e <SdFile::write(void const*, unsigned int)+0xb2>
    1528:	f64f 72f8 	movw	r2, #65528	; 0xfff8
    152c:	e000      	b.n	1530 <SdFile::write(void const*, unsigned int)+0xb4>
    152e:	4a44      	ldr	r2, [pc, #272]	; (1640 <SdFile::write(void const*, unsigned int)+0x1c4>)
    1530:	4293      	cmp	r3, r2
    1532:	d304      	bcc.n	153e <SdFile::write(void const*, unsigned int)+0xc2>
          // add cluster if at end of chain
          if (!addCluster()) goto writeErrorReturn;
    1534:	4630      	mov	r0, r6
    1536:	f7ff ff0d 	bl	1354 <SdFile::addCluster()>
    153a:	b908      	cbnz	r0, 1540 <SdFile::write(void const*, unsigned int)+0xc4>
    153c:	e076      	b.n	162c <SdFile::write(void const*, unsigned int)+0x1b0>
        } else {
          curCluster_ = next;
    153e:	60b3      	str	r3, [r6, #8]
        }
      }
    }
    // max space in block
    uint16_t n = 512 - blockOffset;
    1540:	f5ca 7500 	rsb	r5, sl, #512	; 0x200
    1544:	b2ad      	uxth	r5, r5

    // lesser of space and amount to write
    if (n > nToWrite) n = nToWrite;
    1546:	42af      	cmp	r7, r5
    1548:	d200      	bcs.n	154c <SdFile::write(void const*, unsigned int)+0xd0>
    154a:	b2bd      	uxth	r5, r7

    // block for data write
    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
    154c:	6a32      	ldr	r2, [r6, #32]
    154e:	68b3      	ldr	r3, [r6, #8]
  //----------------------------------------------------------------------------
  uint8_t allocContiguous(uint32_t count, uint32_t* curCluster);
  uint8_t blockOfCluster(uint32_t position) const {
          return (position >> 9) & (blocksPerCluster_ - 1);}
  uint32_t clusterStartBlock(uint32_t cluster) const {
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
    1550:	6951      	ldr	r1, [r2, #20]
    1552:	3b02      	subs	r3, #2
    1554:	f892 9010 	ldrb.w	r9, [r2, #16]
    1558:	fa03 f309 	lsl.w	r3, r3, r9
    155c:	eb01 0903 	add.w	r9, r1, r3
    1560:	44d9      	add	r9, fp
    if (n == 512) {
    1562:	f5b5 7f00 	cmp.w	r5, #512	; 0x200
    1566:	d11d      	bne.n	15a4 <SdFile::write(void const*, unsigned int)+0x128>
      // full block - don't need to use cache
      // invalidate cache if block is in cache
      if (SdVolume::cacheBlockNumber_ == block) {
    1568:	4b36      	ldr	r3, [pc, #216]	; (1644 <SdFile::write(void const*, unsigned int)+0x1c8>)
    156a:	681b      	ldr	r3, [r3, #0]
    156c:	4599      	cmp	r9, r3
    156e:	d103      	bne.n	1578 <SdFile::write(void const*, unsigned int)+0xfc>
        SdVolume::cacheBlockNumber_ = 0XFFFFFFFF;
    1570:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    1574:	4b33      	ldr	r3, [pc, #204]	; (1644 <SdFile::write(void const*, unsigned int)+0x1c8>)
    1576:	601a      	str	r2, [r3, #0]
  }
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    return sdCard_->readBlock(block, dst);
  }
  uint8_t writeBlock(uint32_t block, const uint8_t* dst) {
    return sdCard_->writeBlock(block, dst);
    1578:	4b33      	ldr	r3, [pc, #204]	; (1648 <SdFile::write(void const*, unsigned int)+0x1cc>)
    157a:	6818      	ldr	r0, [r3, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
    157c:	7803      	ldrb	r3, [r0, #0]
    157e:	2bfe      	cmp	r3, #254	; 0xfe
    1580:	d107      	bne.n	1592 <SdFile::write(void const*, unsigned int)+0x116>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    1582:	4649      	mov	r1, r9
    1584:	4620      	mov	r0, r4
    1586:	f7ff fc8d 	bl	ea4 <SDHC_CardWriteBlock(void const*, unsigned long)>
    158a:	fab0 f080 	clz	r0, r0
    158e:	0940      	lsrs	r0, r0, #5
    1590:	e003      	b.n	159a <SdFile::write(void const*, unsigned int)+0x11e>
    }
    #endif
    return SD_writeBlock(block, src);
    1592:	4622      	mov	r2, r4
    1594:	4649      	mov	r1, r9
    1596:	f7ff fe9d 	bl	12d4 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
      }
      if (!vol_->writeBlock(block, src)) goto writeErrorReturn;
    159a:	2800      	cmp	r0, #0
    159c:	d046      	beq.n	162c <SdFile::write(void const*, unsigned int)+0x1b0>
      src += 512;
    159e:	f504 7400 	add.w	r4, r4, #512	; 0x200
    15a2:	e022      	b.n	15ea <SdFile::write(void const*, unsigned int)+0x16e>
    } else {
      if (blockOffset == 0 && curPosition_ >= fileSize_) {
    15a4:	f1ba 0f00 	cmp.w	sl, #0
    15a8:	d110      	bne.n	15cc <SdFile::write(void const*, unsigned int)+0x150>
    15aa:	68f2      	ldr	r2, [r6, #12]
    15ac:	69b3      	ldr	r3, [r6, #24]
    15ae:	429a      	cmp	r2, r3
    15b0:	d30c      	bcc.n	15cc <SdFile::write(void const*, unsigned int)+0x150>
        // start of new block don't need to read into cache
        if (!SdVolume::cacheFlush()) goto writeErrorReturn;
    15b2:	f000 f85d 	bl	1670 <SdVolume::cacheFlush()>
    15b6:	2800      	cmp	r0, #0
    15b8:	d038      	beq.n	162c <SdFile::write(void const*, unsigned int)+0x1b0>
        SdVolume::cacheBlockNumber_ = block;
    15ba:	4b22      	ldr	r3, [pc, #136]	; (1644 <SdFile::write(void const*, unsigned int)+0x1c8>)
    15bc:	f8c3 9000 	str.w	r9, [r3]
           return dataStartBlock_ + ((cluster - 2) << clusterSizeShift_);}
  uint32_t blockNumber(uint32_t cluster, uint32_t position) const {
           return clusterStartBlock(cluster) + blockOfCluster(position);}
  static uint8_t cacheFlush(void);
  static uint8_t cacheRawBlock(uint32_t blockNumber, uint8_t action);
  static void cacheSetDirty(void) {cacheDirty_ |= CACHE_FOR_WRITE;}
    15c0:	4a22      	ldr	r2, [pc, #136]	; (164c <SdFile::write(void const*, unsigned int)+0x1d0>)
    15c2:	7813      	ldrb	r3, [r2, #0]
    15c4:	f043 0301 	orr.w	r3, r3, #1
    15c8:	7013      	strb	r3, [r2, #0]
    15ca:	e004      	b.n	15d6 <SdFile::write(void const*, unsigned int)+0x15a>
        SdVolume::cacheSetDirty();
      } else {
        // rewrite part of block
        if (!SdVolume::cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) {
    15cc:	2101      	movs	r1, #1
    15ce:	4648      	mov	r0, r9
    15d0:	f000 f88c 	bl	16ec <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    15d4:	b350      	cbz	r0, 162c <SdFile::write(void const*, unsigned int)+0x1b0>
          goto writeErrorReturn;
        }
      }
      uint8_t* dst = SdVolume::cacheBuffer_.data + blockOffset;
    15d6:	4b1e      	ldr	r3, [pc, #120]	; (1650 <SdFile::write(void const*, unsigned int)+0x1d4>)
    15d8:	4453      	add	r3, sl
      uint8_t* end = dst + n;
    15da:	1959      	adds	r1, r3, r5
      while (dst != end) *dst++ = *src++;
    15dc:	428b      	cmp	r3, r1
    15de:	d004      	beq.n	15ea <SdFile::write(void const*, unsigned int)+0x16e>
    15e0:	7822      	ldrb	r2, [r4, #0]
    15e2:	701a      	strb	r2, [r3, #0]
    15e4:	3301      	adds	r3, #1
    15e6:	3401      	adds	r4, #1
    15e8:	e7f8      	b.n	15dc <SdFile::write(void const*, unsigned int)+0x160>
    }
    nToWrite -= n;
    15ea:	1b7f      	subs	r7, r7, r5
    curPosition_ += n;
    15ec:	68f3      	ldr	r3, [r6, #12]
    15ee:	441d      	add	r5, r3
    15f0:	60f5      	str	r5, [r6, #12]
  // seek to end of file if append flag
  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
    if (!seekEnd()) goto writeErrorReturn;
  }

  while (nToWrite > 0) {
    15f2:	e769      	b.n	14c8 <SdFile::write(void const*, unsigned int)+0x4c>
      while (dst != end) *dst++ = *src++;
    }
    nToWrite -= n;
    curPosition_ += n;
  }
  if (curPosition_ > fileSize_) {
    15f4:	68f3      	ldr	r3, [r6, #12]
    15f6:	69b2      	ldr	r2, [r6, #24]
    15f8:	4293      	cmp	r3, r2
    15fa:	d905      	bls.n	1608 <SdFile::write(void const*, unsigned int)+0x18c>
    // update fileSize and insure sync will update dir entry
    fileSize_ = curPosition_;
    15fc:	61b3      	str	r3, [r6, #24]
    flags_ |= F_FILE_DIR_DIRTY;
    15fe:	7973      	ldrb	r3, [r6, #5]
    1600:	f063 037f 	orn	r3, r3, #127	; 0x7f
    1604:	7173      	strb	r3, [r6, #5]
    1606:	e009      	b.n	161c <SdFile::write(void const*, unsigned int)+0x1a0>
  } else if (dateTime_ && nbyte) {
    1608:	4b12      	ldr	r3, [pc, #72]	; (1654 <SdFile::write(void const*, unsigned int)+0x1d8>)
    160a:	681b      	ldr	r3, [r3, #0]
    160c:	b133      	cbz	r3, 161c <SdFile::write(void const*, unsigned int)+0x1a0>
    160e:	f1b8 0f00 	cmp.w	r8, #0
    1612:	d003      	beq.n	161c <SdFile::write(void const*, unsigned int)+0x1a0>
    // insure sync will update modified date and time
    flags_ |= F_FILE_DIR_DIRTY;
    1614:	7973      	ldrb	r3, [r6, #5]
    1616:	f063 037f 	orn	r3, r3, #127	; 0x7f
    161a:	7173      	strb	r3, [r6, #5]
  }

  if (flags_ & O_SYNC) {
    161c:	7973      	ldrb	r3, [r6, #5]
    161e:	f013 0f08 	tst.w	r3, #8
    1622:	d007      	beq.n	1634 <SdFile::write(void const*, unsigned int)+0x1b8>
    if (!sync()) goto writeErrorReturn;
    1624:	4630      	mov	r0, r6
    1626:	f7ff fefb 	bl	1420 <SdFile::sync()>
    162a:	b928      	cbnz	r0, 1638 <SdFile::write(void const*, unsigned int)+0x1bc>
	int getWriteError() { return write_error; }
	void clearWriteError() { setWriteError(0); }
	int printf(const char *format, ...);
	int printf(const __FlashStringHelper *format, ...);
  protected:
	void setWriteError(int err = 1) { write_error = err; }
    162c:	2301      	movs	r3, #1
    162e:	7133      	strb	r3, [r6, #4]

 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
    1630:	2000      	movs	r0, #0
    1632:	e002      	b.n	163a <SdFile::write(void const*, unsigned int)+0x1be>
  }

  if (flags_ & O_SYNC) {
    if (!sync()) goto writeErrorReturn;
  }
  return nbyte;
    1634:	4640      	mov	r0, r8
    1636:	e000      	b.n	163a <SdFile::write(void const*, unsigned int)+0x1be>
    1638:	4640      	mov	r0, r8
 writeErrorReturn:
  // return for write error
  //writeError = true;
  setWriteError();
  return 0;
}
    163a:	b003      	add	sp, #12
    163c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1640:	0ffffff8 	.word	0x0ffffff8
    1644:	20000694 	.word	0x20000694
    1648:	20001174 	.word	0x20001174
    164c:	20001378 	.word	0x20001378
    1650:	20001178 	.word	0x20001178
    1654:	2000116c 	.word	0x2000116c

00001658 <SdFile::write(unsigned char)>:
/**
 * Write a byte to a file. Required by the Arduino Print class.
 *
 * Use SdFile::writeError to check for errors.
 */
size_t SdFile::write(uint8_t b) {
    1658:	b500      	push	{lr}
    165a:	b083      	sub	sp, #12
    165c:	ab02      	add	r3, sp, #8
    165e:	f803 1d01 	strb.w	r1, [r3, #-1]!
  return write(&b, 1);
    1662:	2201      	movs	r2, #1
    1664:	4619      	mov	r1, r3
    1666:	f7ff ff09 	bl	147c <SdFile::write(void const*, unsigned int)>
}
    166a:	b003      	add	sp, #12
    166c:	f85d fb04 	ldr.w	pc, [sp], #4

00001670 <SdVolume::cacheFlush()>:
  if (setStart) allocSearchStart_ = bgnCluster + 1;

  return true;
}
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheFlush(void) {
    1670:	b508      	push	{r3, lr}
  if (cacheDirty_) {
    1672:	4b19      	ldr	r3, [pc, #100]	; (16d8 <SdVolume::cacheFlush()+0x68>)
    1674:	781b      	ldrb	r3, [r3, #0]
    1676:	b363      	cbz	r3, 16d2 <SdVolume::cacheFlush()+0x62>
    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
    1678:	4b18      	ldr	r3, [pc, #96]	; (16dc <SdVolume::cacheFlush()+0x6c>)
    167a:	6818      	ldr	r0, [r3, #0]
    167c:	4b18      	ldr	r3, [pc, #96]	; (16e0 <SdVolume::cacheFlush()+0x70>)
    167e:	6819      	ldr	r1, [r3, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
    1680:	7803      	ldrb	r3, [r0, #0]
    1682:	2bfe      	cmp	r3, #254	; 0xfe
    1684:	d106      	bne.n	1694 <SdVolume::cacheFlush()+0x24>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    1686:	4817      	ldr	r0, [pc, #92]	; (16e4 <SdVolume::cacheFlush()+0x74>)
    1688:	f7ff fc0c 	bl	ea4 <SDHC_CardWriteBlock(void const*, unsigned long)>
    168c:	fab0 f080 	clz	r0, r0
    1690:	0940      	lsrs	r0, r0, #5
    1692:	e002      	b.n	169a <SdVolume::cacheFlush()+0x2a>
    }
    #endif
    return SD_writeBlock(block, src);
    1694:	4a13      	ldr	r2, [pc, #76]	; (16e4 <SdVolume::cacheFlush()+0x74>)
    1696:	f7ff fe1d 	bl	12d4 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
    169a:	b1d8      	cbz	r0, 16d4 <SdVolume::cacheFlush()+0x64>
      return false;
    }
    // mirror FAT tables
    if (cacheMirrorBlock_) {
    169c:	4b12      	ldr	r3, [pc, #72]	; (16e8 <SdVolume::cacheFlush()+0x78>)
    169e:	6819      	ldr	r1, [r3, #0]
    16a0:	b191      	cbz	r1, 16c8 <SdVolume::cacheFlush()+0x58>
      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
    16a2:	4b0e      	ldr	r3, [pc, #56]	; (16dc <SdVolume::cacheFlush()+0x6c>)
    16a4:	6818      	ldr	r0, [r3, #0]
    return SD_readBlock(block, dst);
  }
  /** Return the card type: SD V1, SD V2 or SDHC */
  uint8_t writeBlock(uint32_t block, const uint8_t* src) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
    16a6:	7803      	ldrb	r3, [r0, #0]
    16a8:	2bfe      	cmp	r3, #254	; 0xfe
    16aa:	d106      	bne.n	16ba <SdVolume::cacheFlush()+0x4a>
      return (SDHC_CardWriteBlock(src, block) == 0) ? true : false;
    16ac:	480d      	ldr	r0, [pc, #52]	; (16e4 <SdVolume::cacheFlush()+0x74>)
    16ae:	f7ff fbf9 	bl	ea4 <SDHC_CardWriteBlock(void const*, unsigned long)>
    16b2:	fab0 f080 	clz	r0, r0
    16b6:	0940      	lsrs	r0, r0, #5
    16b8:	e002      	b.n	16c0 <SdVolume::cacheFlush()+0x50>
    }
    #endif
    return SD_writeBlock(block, src);
    16ba:	4a0a      	ldr	r2, [pc, #40]	; (16e4 <SdVolume::cacheFlush()+0x74>)
    16bc:	f7ff fe0a 	bl	12d4 <Sd2Card::SD_writeBlock(unsigned long, unsigned char const*)>
    16c0:	b140      	cbz	r0, 16d4 <SdVolume::cacheFlush()+0x64>
        return false;
      }
      cacheMirrorBlock_ = 0;
    16c2:	2200      	movs	r2, #0
    16c4:	4b08      	ldr	r3, [pc, #32]	; (16e8 <SdVolume::cacheFlush()+0x78>)
    16c6:	601a      	str	r2, [r3, #0]
    }
    cacheDirty_ = 0;
    16c8:	2200      	movs	r2, #0
    16ca:	4b03      	ldr	r3, [pc, #12]	; (16d8 <SdVolume::cacheFlush()+0x68>)
    16cc:	701a      	strb	r2, [r3, #0]
  }
  return true;
    16ce:	2001      	movs	r0, #1
    16d0:	bd08      	pop	{r3, pc}
    16d2:	2001      	movs	r0, #1
}
    16d4:	bd08      	pop	{r3, pc}
    16d6:	bf00      	nop
    16d8:	20001378 	.word	0x20001378
    16dc:	20001174 	.word	0x20001174
    16e0:	20000694 	.word	0x20000694
    16e4:	20001178 	.word	0x20001178
    16e8:	20001170 	.word	0x20001170

000016ec <SdVolume::cacheRawBlock(unsigned long, unsigned char)>:
//------------------------------------------------------------------------------
uint8_t SdVolume::cacheRawBlock(uint32_t blockNumber, uint8_t action) {
    16ec:	b538      	push	{r3, r4, r5, lr}
    16ee:	460d      	mov	r5, r1
  if (cacheBlockNumber_ != blockNumber) {
    16f0:	4b12      	ldr	r3, [pc, #72]	; (173c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x50>)
    16f2:	681b      	ldr	r3, [r3, #0]
    16f4:	4283      	cmp	r3, r0
    16f6:	d019      	beq.n	172c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x40>
    16f8:	4604      	mov	r4, r0
    if (!cacheFlush()) return false;
    16fa:	f7ff ffb9 	bl	1670 <SdVolume::cacheFlush()>
    16fe:	4603      	mov	r3, r0
    1700:	b1c8      	cbz	r0, 1736 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x4a>
    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
    1702:	4b0f      	ldr	r3, [pc, #60]	; (1740 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x54>)
    1704:	6818      	ldr	r0, [r3, #0]
  /* return the type of SD card detected during init() */
  uint8_t type(void) const {return type_;}
  /** Returns the current value, true or false, for partial block read. */
  uint8_t readBlock(uint32_t block, uint8_t* dst) {
    #if defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__IMXRT1052__) || defined(__IMXRT1062__)
    if (chipSelectPin_ == BUILTIN_SDCARD) {
    1706:	7803      	ldrb	r3, [r0, #0]
    1708:	2bfe      	cmp	r3, #254	; 0xfe
    170a:	d107      	bne.n	171c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x30>
      return (SDHC_CardReadBlock(dst, block) == 0) ? true : false;
    170c:	4621      	mov	r1, r4
    170e:	480d      	ldr	r0, [pc, #52]	; (1744 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x58>)
    1710:	f7ff fb9e 	bl	e50 <SDHC_CardReadBlock(void*, unsigned long)>
    1714:	fab0 f380 	clz	r3, r0
    1718:	095b      	lsrs	r3, r3, #5
    171a:	e004      	b.n	1726 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x3a>
    }
    #endif
    return SD_readBlock(block, dst);
    171c:	4a09      	ldr	r2, [pc, #36]	; (1744 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x58>)
    171e:	4621      	mov	r1, r4
    1720:	f7ff fd8e 	bl	1240 <Sd2Card::SD_readBlock(unsigned long, unsigned char*)>
    1724:	4603      	mov	r3, r0
    1726:	b133      	cbz	r3, 1736 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x4a>
    cacheBlockNumber_ = blockNumber;
    1728:	4b04      	ldr	r3, [pc, #16]	; (173c <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x50>)
    172a:	601c      	str	r4, [r3, #0]
  }
  cacheDirty_ |= action;
    172c:	4b06      	ldr	r3, [pc, #24]	; (1748 <SdVolume::cacheRawBlock(unsigned long, unsigned char)+0x5c>)
    172e:	7819      	ldrb	r1, [r3, #0]
    1730:	4329      	orrs	r1, r5
    1732:	7019      	strb	r1, [r3, #0]
  return true;
    1734:	2301      	movs	r3, #1
}
    1736:	4618      	mov	r0, r3
    1738:	bd38      	pop	{r3, r4, r5, pc}
    173a:	bf00      	nop
    173c:	20000694 	.word	0x20000694
    1740:	20001174 	.word	0x20001174
    1744:	20001178 	.word	0x20001178
    1748:	20001378 	.word	0x20001378

0000174c <SdVolume::fatGet(unsigned long, unsigned long*) const>:
  *size = s;
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
    174c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  if (cluster > (clusterCount_ + 1)) return false;
    174e:	68c3      	ldr	r3, [r0, #12]
    1750:	3301      	adds	r3, #1
    1752:	428b      	cmp	r3, r1
    1754:	d329      	bcc.n	17aa <SdVolume::fatGet(unsigned long, unsigned long*) const+0x5e>
  uint32_t lba = fatStartBlock_;
    1756:	69c3      	ldr	r3, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    1758:	f890 4020 	ldrb.w	r4, [r0, #32]
    175c:	2c10      	cmp	r4, #16
    175e:	d101      	bne.n	1764 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x18>
    1760:	0a0f      	lsrs	r7, r1, #8
    1762:	e000      	b.n	1766 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x1a>
    1764:	09cf      	lsrs	r7, r1, #7
    1766:	4616      	mov	r6, r2
    1768:	460d      	mov	r5, r1
    176a:	4604      	mov	r4, r0
    176c:	18f8      	adds	r0, r7, r3
  if (lba != cacheBlockNumber_) {
    176e:	4b10      	ldr	r3, [pc, #64]	; (17b0 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x64>)
    1770:	681b      	ldr	r3, [r3, #0]
    1772:	4298      	cmp	r0, r3
    1774:	d004      	beq.n	1780 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x34>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
    1776:	2100      	movs	r1, #0
    1778:	f7ff ffb8 	bl	16ec <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    177c:	4603      	mov	r3, r0
    177e:	b1a8      	cbz	r0, 17ac <SdVolume::fatGet(unsigned long, unsigned long*) const+0x60>
  }
  if (fatType_ == 16) {
    1780:	f894 3020 	ldrb.w	r3, [r4, #32]
    1784:	2b10      	cmp	r3, #16
    1786:	d106      	bne.n	1796 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x4a>
    *value = cacheBuffer_.fat16[cluster & 0XFF];
    1788:	b2e9      	uxtb	r1, r5
    178a:	4b0a      	ldr	r3, [pc, #40]	; (17b4 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x68>)
    178c:	f833 3011 	ldrh.w	r3, [r3, r1, lsl #1]
    1790:	6033      	str	r3, [r6, #0]
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
    1792:	2301      	movs	r3, #1
    1794:	e00a      	b.n	17ac <SdVolume::fatGet(unsigned long, unsigned long*) const+0x60>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
  }
  if (fatType_ == 16) {
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
    1796:	f005 017f 	and.w	r1, r5, #127	; 0x7f
    179a:	4b06      	ldr	r3, [pc, #24]	; (17b4 <SdVolume::fatGet(unsigned long, unsigned long*) const+0x68>)
    179c:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    17a0:	f023 4370 	bic.w	r3, r3, #4026531840	; 0xf0000000
    17a4:	6033      	str	r3, [r6, #0]
  }
  return true;
    17a6:	2301      	movs	r3, #1
    17a8:	e000      	b.n	17ac <SdVolume::fatGet(unsigned long, unsigned long*) const+0x60>
  return true;
}
//------------------------------------------------------------------------------
// Fetch a FAT entry
uint8_t SdVolume::fatGet(uint32_t cluster, uint32_t* value) const {
  if (cluster > (clusterCount_ + 1)) return false;
    17aa:	2300      	movs	r3, #0
    *value = cacheBuffer_.fat16[cluster & 0XFF];
  } else {
    *value = cacheBuffer_.fat32[cluster & 0X7F] & FAT32MASK;
  }
  return true;
}
    17ac:	4618      	mov	r0, r3
    17ae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    17b0:	20000694 	.word	0x20000694
    17b4:	20001178 	.word	0x20001178

000017b8 <SdVolume::fatPut(unsigned long, unsigned long)>:
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
    17b8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  // error if reserved cluster
  if (cluster < 2) return false;
    17ba:	2901      	cmp	r1, #1
    17bc:	d935      	bls.n	182a <SdVolume::fatPut(unsigned long, unsigned long)+0x72>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
    17be:	68c3      	ldr	r3, [r0, #12]
    17c0:	3301      	adds	r3, #1
    17c2:	4299      	cmp	r1, r3
    17c4:	d833      	bhi.n	182e <SdVolume::fatPut(unsigned long, unsigned long)+0x76>

  // calculate block address for entry
  uint32_t lba = fatStartBlock_;
    17c6:	69c3      	ldr	r3, [r0, #28]
  lba += fatType_ == 16 ? cluster >> 8 : cluster >> 7;
    17c8:	f890 4020 	ldrb.w	r4, [r0, #32]
    17cc:	2c10      	cmp	r4, #16
    17ce:	d101      	bne.n	17d4 <SdVolume::fatPut(unsigned long, unsigned long)+0x1c>
    17d0:	0a0e      	lsrs	r6, r1, #8
    17d2:	e000      	b.n	17d6 <SdVolume::fatPut(unsigned long, unsigned long)+0x1e>
    17d4:	09ce      	lsrs	r6, r1, #7
    17d6:	4617      	mov	r7, r2
    17d8:	460c      	mov	r4, r1
    17da:	4605      	mov	r5, r0
    17dc:	441e      	add	r6, r3

  if (lba != cacheBlockNumber_) {
    17de:	4b16      	ldr	r3, [pc, #88]	; (1838 <SdVolume::fatPut(unsigned long, unsigned long)+0x80>)
    17e0:	681b      	ldr	r3, [r3, #0]
    17e2:	429e      	cmp	r6, r3
    17e4:	d005      	beq.n	17f2 <SdVolume::fatPut(unsigned long, unsigned long)+0x3a>
    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
    17e6:	2100      	movs	r1, #0
    17e8:	4630      	mov	r0, r6
    17ea:	f7ff ff7f 	bl	16ec <SdVolume::cacheRawBlock(unsigned long, unsigned char)>
    17ee:	4603      	mov	r3, r0
    17f0:	b300      	cbz	r0, 1834 <SdVolume::fatPut(unsigned long, unsigned long)+0x7c>
  }
  // store entry
  if (fatType_ == 16) {
    17f2:	f895 3020 	ldrb.w	r3, [r5, #32]
    17f6:	2b10      	cmp	r3, #16
    17f8:	d104      	bne.n	1804 <SdVolume::fatPut(unsigned long, unsigned long)+0x4c>
    cacheBuffer_.fat16[cluster & 0XFF] = value;
    17fa:	b2e1      	uxtb	r1, r4
    17fc:	4b0f      	ldr	r3, [pc, #60]	; (183c <SdVolume::fatPut(unsigned long, unsigned long)+0x84>)
    17fe:	f823 7011 	strh.w	r7, [r3, r1, lsl #1]
    1802:	e004      	b.n	180e <SdVolume::fatPut(unsigned long, unsigned long)+0x56>
  } else {
    cacheBuffer_.fat32[cluster & 0X7F] = value;
    1804:	f004 017f 	and.w	r1, r4, #127	; 0x7f
    1808:	4b0c      	ldr	r3, [pc, #48]	; (183c <SdVolume::fatPut(unsigned long, unsigned long)+0x84>)
    180a:	f843 7021 	str.w	r7, [r3, r1, lsl #2]
    180e:	4a0c      	ldr	r2, [pc, #48]	; (1840 <SdVolume::fatPut(unsigned long, unsigned long)+0x88>)
    1810:	7813      	ldrb	r3, [r2, #0]
    1812:	f043 0301 	orr.w	r3, r3, #1
    1816:	7013      	strb	r3, [r2, #0]
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
    1818:	7e2b      	ldrb	r3, [r5, #24]
    181a:	2b01      	cmp	r3, #1
    181c:	d909      	bls.n	1832 <SdVolume::fatPut(unsigned long, unsigned long)+0x7a>
    181e:	68ab      	ldr	r3, [r5, #8]
    1820:	441e      	add	r6, r3
    1822:	4b08      	ldr	r3, [pc, #32]	; (1844 <SdVolume::fatPut(unsigned long, unsigned long)+0x8c>)
    1824:	601e      	str	r6, [r3, #0]
  return true;
    1826:	2301      	movs	r3, #1
    1828:	e004      	b.n	1834 <SdVolume::fatPut(unsigned long, unsigned long)+0x7c>
}
//------------------------------------------------------------------------------
// Store a FAT entry
uint8_t SdVolume::fatPut(uint32_t cluster, uint32_t value) {
  // error if reserved cluster
  if (cluster < 2) return false;
    182a:	2300      	movs	r3, #0
    182c:	e002      	b.n	1834 <SdVolume::fatPut(unsigned long, unsigned long)+0x7c>

  // error if not in FAT
  if (cluster > (clusterCount_ + 1)) return false;
    182e:	2300      	movs	r3, #0
    1830:	e000      	b.n	1834 <SdVolume::fatPut(unsigned long, unsigned long)+0x7c>
  }
  cacheSetDirty();

  // mirror second FAT
  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
  return true;
    1832:	2301      	movs	r3, #1
}
    1834:	4618      	mov	r0, r3
    1836:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    1838:	20000694 	.word	0x20000694
    183c:	20001178 	.word	0x20001178
    1840:	20001378 	.word	0x20001378
    1844:	20001170 	.word	0x20001170

00001848 <SdVolume::allocContiguous(unsigned long, unsigned long*)>:
Sd2Card* SdVolume::sdCard_;          // pointer to SD card object
uint8_t  SdVolume::cacheDirty_ = 0;  // cacheFlush() will write block if true
uint32_t SdVolume::cacheMirrorBlock_ = 0;  // mirror  block for second FAT
//------------------------------------------------------------------------------
// find a contiguous group of clusters
uint8_t SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
    1848:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    184c:	b083      	sub	sp, #12
    184e:	4606      	mov	r6, r0
    1850:	4689      	mov	r9, r1
    1852:	4692      	mov	sl, r2

  // flag to save place to start next search
  uint8_t setStart;

  // set search start cluster
  if (*curCluster) {
    1854:	6817      	ldr	r7, [r2, #0]
    1856:	b11f      	cbz	r7, 1860 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x18>
    // try to make file contiguous
    bgnCluster = *curCluster + 1;
    1858:	3701      	adds	r7, #1

    // don't save new start location
    setStart = false;
    185a:	f04f 0b00 	mov.w	fp, #0
    185e:	e006      	b.n	186e <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x26>
  } else {
    // start at likely place for free cluster
    bgnCluster = allocSearchStart_;
    1860:	6807      	ldr	r7, [r0, #0]

    // save next search start if one cluster
    setStart = 1 == count;
    1862:	2901      	cmp	r1, #1
    1864:	bf14      	ite	ne
    1866:	f04f 0b00 	movne.w	fp, #0
    186a:	f04f 0b01 	moveq.w	fp, #1
  }
  // end of group
  uint32_t endCluster = bgnCluster;

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;
    186e:	68f3      	ldr	r3, [r6, #12]
    1870:	f103 0801 	add.w	r8, r3, #1

    // save next search start if one cluster
    setStart = 1 == count;
  }
  // end of group
  uint32_t endCluster = bgnCluster;
    1874:	463c      	mov	r4, r7

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    1876:	2500      	movs	r5, #0
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    1878:	68f3      	ldr	r3, [r6, #12]
    187a:	429d      	cmp	r5, r3
    187c:	d214      	bcs.n	18a8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x60>

    // past end - start from beginning of FAT
    if (endCluster > fatEnd) {
    187e:	4544      	cmp	r4, r8
    1880:	d901      	bls.n	1886 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x3e>
      bgnCluster = endCluster = 2;
    1882:	2402      	movs	r4, #2
    1884:	4627      	mov	r7, r4
    }
    uint32_t f;
    if (!fatGet(endCluster, &f)) return false;
    1886:	aa01      	add	r2, sp, #4
    1888:	4621      	mov	r1, r4
    188a:	4630      	mov	r0, r6
    188c:	f7ff ff5e 	bl	174c <SdVolume::fatGet(unsigned long, unsigned long*) const>
    1890:	b150      	cbz	r0, 18a8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x60>

    if (f != 0) {
    1892:	9b01      	ldr	r3, [sp, #4]
    1894:	b10b      	cbz	r3, 189a <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x52>
      // cluster in use try next cluster as bgnCluster
      bgnCluster = endCluster + 1;
    1896:	1c67      	adds	r7, r4, #1
    1898:	e003      	b.n	18a2 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x5a>
    } else if ((endCluster - bgnCluster + 1) == count) {
    189a:	1be3      	subs	r3, r4, r7
    189c:	3301      	adds	r3, #1
    189e:	4599      	cmp	r9, r3
    18a0:	d004      	beq.n	18ac <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x64>

  // last cluster of FAT
  uint32_t fatEnd = clusterCount_ + 1;

  // search the FAT for free clusters
  for (uint32_t n = 0;; n++, endCluster++) {
    18a2:	3501      	adds	r5, #1
    18a4:	3401      	adds	r4, #1
    18a6:	e7e7      	b.n	1878 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x30>
    // can't find space checked all clusters
    if (n >= clusterCount_) return false;
    18a8:	2300      	movs	r3, #0
    18aa:	e026      	b.n	18fa <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb2>
  static uint8_t cacheZeroBlock(uint32_t blockNumber);
  uint8_t chainSize(uint32_t beginCluster, uint32_t* size) const;
  uint8_t fatGet(uint32_t cluster, uint32_t* value) const;
  uint8_t fatPut(uint32_t cluster, uint32_t value);
  uint8_t fatPutEOC(uint32_t cluster) {
    return fatPut(cluster, 0x0FFFFFFF);
    18ac:	f06f 4270 	mvn.w	r2, #4026531840	; 0xf0000000
    18b0:	4621      	mov	r1, r4
    18b2:	4630      	mov	r0, r6
    18b4:	f7ff ff80 	bl	17b8 <SdVolume::fatPut(unsigned long, unsigned long)>
      // done - found space
      break;
    }
  }
  // mark end of chain
  if (!fatPutEOC(endCluster)) return false;
    18b8:	4603      	mov	r3, r0
    18ba:	b1f0      	cbz	r0, 18fa <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb2>

  // link clusters
  while (endCluster > bgnCluster) {
    18bc:	42a7      	cmp	r7, r4
    18be:	d209      	bcs.n	18d4 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x8c>
    if (!fatPut(endCluster - 1, endCluster)) return false;
    18c0:	1e65      	subs	r5, r4, #1
    18c2:	4622      	mov	r2, r4
    18c4:	4629      	mov	r1, r5
    18c6:	4630      	mov	r0, r6
    18c8:	f7ff ff76 	bl	17b8 <SdVolume::fatPut(unsigned long, unsigned long)>
    18cc:	4603      	mov	r3, r0
    18ce:	b1a0      	cbz	r0, 18fa <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb2>
    endCluster--;
    18d0:	462c      	mov	r4, r5
    18d2:	e7f3      	b.n	18bc <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x74>
  }
  if (*curCluster != 0) {
    18d4:	f8da 1000 	ldr.w	r1, [sl]
    18d8:	b129      	cbz	r1, 18e6 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0x9e>
    // connect chains
    if (!fatPut(*curCluster, bgnCluster)) return false;
    18da:	463a      	mov	r2, r7
    18dc:	4630      	mov	r0, r6
    18de:	f7ff ff6b 	bl	17b8 <SdVolume::fatPut(unsigned long, unsigned long)>
    18e2:	4603      	mov	r3, r0
    18e4:	b148      	cbz	r0, 18fa <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb2>
  }
  // return first cluster number to caller
  *curCluster = bgnCluster;
    18e6:	f8ca 7000 	str.w	r7, [sl]

  // remember possible next free cluster
  if (setStart) allocSearchStart_ = bgnCluster + 1;
    18ea:	f1bb 0f00 	cmp.w	fp, #0
    18ee:	d003      	beq.n	18f8 <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb0>
    18f0:	3701      	adds	r7, #1
    18f2:	6037      	str	r7, [r6, #0]

  return true;
    18f4:	2301      	movs	r3, #1
    18f6:	e000      	b.n	18fa <SdVolume::allocContiguous(unsigned long, unsigned long*)+0xb2>
    18f8:	2301      	movs	r3, #1
}
    18fa:	4618      	mov	r0, r3
    18fc:	b003      	add	sp, #12
    18fe:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    1902:	bf00      	nop

00001904 <TL_AudioOutputI2S_OA_F32::isr()>:
    dma.attachInterrupt(isr);
                                                 //Serial.println("CCC");
}    // end begin()

void TL_AudioOutputI2S_OA_F32::isr(void)
{
    1904:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#if defined(KINETISK) || defined(__IMXRT1062__)
    int16_t *dest;
    audio_block_t *blockL, *blockR;
    uint32_t saddr, offsetL, offsetR;

    saddr = (uint32_t)(dma.TCD->SADDR);
    1908:	4b3d      	ldr	r3, [pc, #244]	; (1a00 <TL_AudioOutputI2S_OA_F32::isr()+0xfc>)
    190a:	681a      	ldr	r2, [r3, #0]
    190c:	6812      	ldr	r2, [r2, #0]
	void detachInterrupt(void) {
		NVIC_DISABLE_IRQ(IRQ_DMA_CH0 + channel);
	}

	void clearInterrupt(void) {
		DMA_CINT = channel;
    190e:	7919      	ldrb	r1, [r3, #4]
    1910:	4b3c      	ldr	r3, [pc, #240]	; (1a04 <TL_AudioOutputI2S_OA_F32::isr()+0x100>)
    1912:	77d9      	strb	r1, [r3, #31]
    dma.clearInterrupt();
    if (saddr < (uint32_t)i2s_tx_buffer + sizeof(i2s_tx_buffer) / 2) {
    1914:	4b3c      	ldr	r3, [pc, #240]	; (1a08 <TL_AudioOutputI2S_OA_F32::isr()+0x104>)
    1916:	429a      	cmp	r2, r3
    1918:	d207      	bcs.n	192a <TL_AudioOutputI2S_OA_F32::isr()+0x26>
        // DMA is transmitting the first half of the buffer
        // so we must fill the second half
        dest = (int16_t *)&i2s_tx_buffer[AUDIO_BLOCK_SAMPLES/2];
        if (TL_AudioOutputI2S_OA_F32::update_responsibility) AudioStream_F32::update_all();
    191a:	4b3c      	ldr	r3, [pc, #240]	; (1a0c <TL_AudioOutputI2S_OA_F32::isr()+0x108>)
    191c:	781b      	ldrb	r3, [r3, #0]
    191e:	b133      	cbz	r3, 192e <TL_AudioOutputI2S_OA_F32::isr()+0x2a>
	void transmit(audio_block_t *block, unsigned char index = 0);
	audio_block_t * receiveReadOnly(unsigned int index = 0);
	audio_block_t * receiveWritable(unsigned int index = 0);
	static bool update_setup(void);
	static void update_stop(void);
	static void update_all(void) { NVIC_SET_PENDING(IRQ_SOFTWARE); }
    1920:	2240      	movs	r2, #64	; 0x40
    1922:	4b3b      	ldr	r3, [pc, #236]	; (1a10 <TL_AudioOutputI2S_OA_F32::isr()+0x10c>)
    1924:	601a      	str	r2, [r3, #0]
    saddr = (uint32_t)(dma.TCD->SADDR);
    dma.clearInterrupt();
    if (saddr < (uint32_t)i2s_tx_buffer + sizeof(i2s_tx_buffer) / 2) {
        // DMA is transmitting the first half of the buffer
        // so we must fill the second half
        dest = (int16_t *)&i2s_tx_buffer[AUDIO_BLOCK_SAMPLES/2];
    1926:	4c38      	ldr	r4, [pc, #224]	; (1a08 <TL_AudioOutputI2S_OA_F32::isr()+0x104>)
    1928:	e002      	b.n	1930 <TL_AudioOutputI2S_OA_F32::isr()+0x2c>
        if (TL_AudioOutputI2S_OA_F32::update_responsibility) AudioStream_F32::update_all();
    } else {
        // DMA is transmitting the second half of the buffer
        // so we must fill the first half
        dest = (int16_t *)i2s_tx_buffer;
    192a:	4c3a      	ldr	r4, [pc, #232]	; (1a14 <TL_AudioOutputI2S_OA_F32::isr()+0x110>)
    192c:	e000      	b.n	1930 <TL_AudioOutputI2S_OA_F32::isr()+0x2c>
    saddr = (uint32_t)(dma.TCD->SADDR);
    dma.clearInterrupt();
    if (saddr < (uint32_t)i2s_tx_buffer + sizeof(i2s_tx_buffer) / 2) {
        // DMA is transmitting the first half of the buffer
        // so we must fill the second half
        dest = (int16_t *)&i2s_tx_buffer[AUDIO_BLOCK_SAMPLES/2];
    192e:	4c36      	ldr	r4, [pc, #216]	; (1a08 <TL_AudioOutputI2S_OA_F32::isr()+0x104>)
        // DMA is transmitting the second half of the buffer
        // so we must fill the first half
        dest = (int16_t *)i2s_tx_buffer;
    }

    blockL = TL_AudioOutputI2S_OA_F32::block_left_1st;  // These 2 are I16*
    1930:	4b39      	ldr	r3, [pc, #228]	; (1a18 <TL_AudioOutputI2S_OA_F32::isr()+0x114>)
    1932:	681f      	ldr	r7, [r3, #0]
    blockR = TL_AudioOutputI2S_OA_F32::block_right_1st;
    1934:	4b39      	ldr	r3, [pc, #228]	; (1a1c <TL_AudioOutputI2S_OA_F32::isr()+0x118>)
    1936:	f8d3 8000 	ldr.w	r8, [r3]
    offsetL = TL_AudioOutputI2S_OA_F32::block_left_offset;
    193a:	4b39      	ldr	r3, [pc, #228]	; (1a20 <TL_AudioOutputI2S_OA_F32::isr()+0x11c>)
    193c:	881d      	ldrh	r5, [r3, #0]
    offsetR = TL_AudioOutputI2S_OA_F32::block_right_offset;
    193e:	4b39      	ldr	r3, [pc, #228]	; (1a24 <TL_AudioOutputI2S_OA_F32::isr()+0x120>)
    1940:	881e      	ldrh	r6, [r3, #0]

    if (blockL && blockR) {
    1942:	2f00      	cmp	r7, #0
    1944:	bf18      	it	ne
    1946:	f1b8 0f00 	cmpne.w	r8, #0
    194a:	d00c      	beq.n	1966 <TL_AudioOutputI2S_OA_F32::isr()+0x62>
        memcpy_tointerleaveLR(dest, blockL->data + offsetL, blockR->data + offsetR);
    194c:	1d39      	adds	r1, r7, #4
    194e:	f108 0204 	add.w	r2, r8, #4
    1952:	eb02 0246 	add.w	r2, r2, r6, lsl #1
    1956:	eb01 0145 	add.w	r1, r1, r5, lsl #1
    195a:	4620      	mov	r0, r4
    195c:	f7fe fc72 	bl	244 <memcpy_tointerleaveLR>
        offsetL += AUDIO_BLOCK_SAMPLES / 2;
    1960:	3540      	adds	r5, #64	; 0x40
        offsetR += AUDIO_BLOCK_SAMPLES / 2;
    1962:	3640      	adds	r6, #64	; 0x40
    1964:	e01a      	b.n	199c <TL_AudioOutputI2S_OA_F32::isr()+0x98>
    } else if (blockL) {
    1966:	b13f      	cbz	r7, 1978 <TL_AudioOutputI2S_OA_F32::isr()+0x74>
        memcpy_tointerleaveL(dest, blockL->data + offsetL);
    1968:	1d39      	adds	r1, r7, #4
    196a:	eb01 0145 	add.w	r1, r1, r5, lsl #1
    196e:	4620      	mov	r0, r4
    1970:	f7fe fc87 	bl	282 <memcpy_tointerleaveL>
        offsetL += AUDIO_BLOCK_SAMPLES / 2;
    1974:	3540      	adds	r5, #64	; 0x40
    1976:	e011      	b.n	199c <TL_AudioOutputI2S_OA_F32::isr()+0x98>
    } else if (blockR) {
    1978:	f1b8 0f00 	cmp.w	r8, #0
    197c:	d008      	beq.n	1990 <TL_AudioOutputI2S_OA_F32::isr()+0x8c>
        memcpy_tointerleaveR(dest, blockR->data + offsetR);
    197e:	f108 0104 	add.w	r1, r8, #4
    1982:	eb01 0146 	add.w	r1, r1, r6, lsl #1
    1986:	4620      	mov	r0, r4
    1988:	f7fe fc9b 	bl	2c2 <memcpy_tointerleaveR>
        offsetR += AUDIO_BLOCK_SAMPLES / 2;
    198c:	3640      	adds	r6, #64	; 0x40
    198e:	e005      	b.n	199c <TL_AudioOutputI2S_OA_F32::isr()+0x98>
    } else {
        memset(dest,0,AUDIO_BLOCK_SAMPLES * 2);
    1990:	f44f 7280 	mov.w	r2, #256	; 0x100
    1994:	2100      	movs	r1, #0
    1996:	4620      	mov	r0, r4
    1998:	f002 fe40 	bl	461c <memset>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    199c:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    19a0:	f504 7080 	add.w	r0, r4, #256	; 0x100
	asm volatile("": : :"memory");
	asm("dsb");
    19a4:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    19a8:	4a1f      	ldr	r2, [pc, #124]	; (1a28 <TL_AudioOutputI2S_OA_F32::isr()+0x124>)
    19aa:	6013      	str	r3, [r2, #0]
		location += 32;
    19ac:	3320      	adds	r3, #32
	} while (location < end_addr);
    19ae:	4298      	cmp	r0, r3
    19b0:	d8fa      	bhi.n	19a8 <TL_AudioOutputI2S_OA_F32::isr()+0xa4>
	asm("dsb");
    19b2:	f3bf 8f4f 	dsb	sy
	asm("isb");
    19b6:	f3bf 8f6f 	isb	sy
    }

    arm_dcache_flush_delete(dest, sizeof(i2s_tx_buffer) / 2 );

    if (offsetL < AUDIO_BLOCK_SAMPLES) {
    19ba:	2d7f      	cmp	r5, #127	; 0x7f
    19bc:	d802      	bhi.n	19c4 <TL_AudioOutputI2S_OA_F32::isr()+0xc0>
        TL_AudioOutputI2S_OA_F32::block_left_offset = offsetL;
    19be:	4b18      	ldr	r3, [pc, #96]	; (1a20 <TL_AudioOutputI2S_OA_F32::isr()+0x11c>)
    19c0:	801d      	strh	r5, [r3, #0]
    19c2:	e00a      	b.n	19da <TL_AudioOutputI2S_OA_F32::isr()+0xd6>
    } else {
        TL_AudioOutputI2S_OA_F32::block_left_offset = 0;
    19c4:	2400      	movs	r4, #0
    19c6:	4b16      	ldr	r3, [pc, #88]	; (1a20 <TL_AudioOutputI2S_OA_F32::isr()+0x11c>)
    19c8:	801c      	strh	r4, [r3, #0]
        AudioStream::release(blockL);
    19ca:	4638      	mov	r0, r7
    19cc:	f002 f94a 	bl	3c64 <AudioStream::release(audio_block_struct*)>
        TL_AudioOutputI2S_OA_F32::block_left_1st = TL_AudioOutputI2S_OA_F32::block_left_2nd;
    19d0:	4b16      	ldr	r3, [pc, #88]	; (1a2c <TL_AudioOutputI2S_OA_F32::isr()+0x128>)
    19d2:	6819      	ldr	r1, [r3, #0]
    19d4:	4a10      	ldr	r2, [pc, #64]	; (1a18 <TL_AudioOutputI2S_OA_F32::isr()+0x114>)
    19d6:	6011      	str	r1, [r2, #0]
        TL_AudioOutputI2S_OA_F32::block_left_2nd = NULL;
    19d8:	601c      	str	r4, [r3, #0]
    }
    if (offsetR < AUDIO_BLOCK_SAMPLES) {
    19da:	2e7f      	cmp	r6, #127	; 0x7f
    19dc:	d803      	bhi.n	19e6 <TL_AudioOutputI2S_OA_F32::isr()+0xe2>
        TL_AudioOutputI2S_OA_F32::block_right_offset = offsetR;
    19de:	4b11      	ldr	r3, [pc, #68]	; (1a24 <TL_AudioOutputI2S_OA_F32::isr()+0x120>)
    19e0:	801e      	strh	r6, [r3, #0]
    19e2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    } else {
        TL_AudioOutputI2S_OA_F32::block_right_offset = 0;
    19e6:	2400      	movs	r4, #0
    19e8:	4b0e      	ldr	r3, [pc, #56]	; (1a24 <TL_AudioOutputI2S_OA_F32::isr()+0x120>)
    19ea:	801c      	strh	r4, [r3, #0]
        AudioStream::release(blockR);
    19ec:	4640      	mov	r0, r8
    19ee:	f002 f939 	bl	3c64 <AudioStream::release(audio_block_struct*)>
        TL_AudioOutputI2S_OA_F32::block_right_1st = TL_AudioOutputI2S_OA_F32::block_right_2nd;
    19f2:	4b0f      	ldr	r3, [pc, #60]	; (1a30 <TL_AudioOutputI2S_OA_F32::isr()+0x12c>)
    19f4:	6819      	ldr	r1, [r3, #0]
    19f6:	4a09      	ldr	r2, [pc, #36]	; (1a1c <TL_AudioOutputI2S_OA_F32::isr()+0x118>)
    19f8:	6011      	str	r1, [r2, #0]
        TL_AudioOutputI2S_OA_F32::block_right_2nd = NULL;
    19fa:	601c      	str	r4, [r3, #0]
    19fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1a00:	20001384 	.word	0x20001384
    1a04:	400e8000 	.word	0x400e8000
    1a08:	20200b40 	.word	0x20200b40
    1a0c:	2000138e 	.word	0x2000138e
    1a10:	e000e208 	.word	0xe000e208
    1a14:	20200a40 	.word	0x20200a40
    1a18:	20001394 	.word	0x20001394
    1a1c:	20001380 	.word	0x20001380
    1a20:	2000138c 	.word	0x2000138c
    1a24:	20001398 	.word	0x20001398
    1a28:	e000ef70 	.word	0xe000ef70
    1a2c:	2000137c 	.word	0x2000137c
    1a30:	20001390 	.word	0x20001390

00001a34 <TL_AudioOutputI2S_OA_F32::update()>:
    }
#endif
}

void TL_AudioOutputI2S_OA_F32::update(void)
{
    1a34:	b570      	push	{r4, r5, r6, lr}
    1a36:	4606      	mov	r6, r0
    audio_block_f32_t *blockF32;
    audio_block_t *blockI16;
    
    blockF32 = AudioStream_F32::receiveReadOnly_f32(0); // input 0 = left
    1a38:	2100      	movs	r1, #0
    1a3a:	f000 fa69 	bl	1f10 <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    1a3e:	4605      	mov	r5, r0
    blockI16 = AudioStream::allocate();
    1a40:	f002 f8c8 	bl	3bd4 <AudioStream::allocate()>
    1a44:	4604      	mov	r4, r0
    if (blockF32) {
    1a46:	2d00      	cmp	r5, #0
    1a48:	d031      	beq.n	1aae <TL_AudioOutputI2S_OA_F32::update()+0x7a>
    1a4a:	2200      	movs	r2, #0
        // Change F32 to I16
        for(int i=0; i<128; i++) {
    1a4c:	2a7f      	cmp	r2, #127	; 0x7f
    1a4e:	dc10      	bgt.n	1a72 <TL_AudioOutputI2S_OA_F32::update()+0x3e>
            blockI16->data[i] = (int16_t)(32768.0f*blockF32->data[i]);
    1a50:	eb05 0382 	add.w	r3, r5, r2, lsl #2
    1a54:	edd3 7a01 	vldr	s15, [r3, #4]
    1a58:	ed9f 7a33 	vldr	s14, [pc, #204]	; 1b28 <TL_AudioOutputI2S_OA_F32::update()+0xf4>
    1a5c:	ee67 7a87 	vmul.f32	s15, s15, s14
    1a60:	eb04 0142 	add.w	r1, r4, r2, lsl #1
    1a64:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    1a68:	ee17 3a90 	vmov	r3, s15
    1a6c:	808b      	strh	r3, [r1, #4]
    
    blockF32 = AudioStream_F32::receiveReadOnly_f32(0); // input 0 = left
    blockI16 = AudioStream::allocate();
    if (blockF32) {
        // Change F32 to I16
        for(int i=0; i<128; i++) {
    1a6e:	3201      	adds	r2, #1
    1a70:	e7ec      	b.n	1a4c <TL_AudioOutputI2S_OA_F32::update()+0x18>
            blockI16->data[i] = (int16_t)(32768.0f*blockF32->data[i]);
        }
        AudioStream_F32::release(blockF32);  // End of F32 activity
    1a72:	4628      	mov	r0, r5
    1a74:	f000 fa16 	bl	1ea4 <AudioStream_F32::release(audio_block_f32_t*)>

        // From here down to end of left channel is the same as for I16 Teensy Audio
        // Now I16, so sort out the DMA data
        __disable_irq();
    1a78:	b672      	cpsid	i
        if (block_left_1st == NULL) {
    1a7a:	4b2c      	ldr	r3, [pc, #176]	; (1b2c <TL_AudioOutputI2S_OA_F32::update()+0xf8>)
    1a7c:	6818      	ldr	r0, [r3, #0]
    1a7e:	b928      	cbnz	r0, 1a8c <TL_AudioOutputI2S_OA_F32::update()+0x58>
            block_left_1st = blockI16;
    1a80:	601c      	str	r4, [r3, #0]
            block_left_offset = 0;
    1a82:	2200      	movs	r2, #0
    1a84:	4b2a      	ldr	r3, [pc, #168]	; (1b30 <TL_AudioOutputI2S_OA_F32::update()+0xfc>)
    1a86:	801a      	strh	r2, [r3, #0]
            __enable_irq();
    1a88:	b662      	cpsie	i
    1a8a:	e010      	b.n	1aae <TL_AudioOutputI2S_OA_F32::update()+0x7a>
        } else if (block_left_2nd == NULL) {
    1a8c:	4b29      	ldr	r3, [pc, #164]	; (1b34 <TL_AudioOutputI2S_OA_F32::update()+0x100>)
    1a8e:	681b      	ldr	r3, [r3, #0]
    1a90:	b91b      	cbnz	r3, 1a9a <TL_AudioOutputI2S_OA_F32::update()+0x66>
            block_left_2nd = blockI16;
    1a92:	4b28      	ldr	r3, [pc, #160]	; (1b34 <TL_AudioOutputI2S_OA_F32::update()+0x100>)
    1a94:	601c      	str	r4, [r3, #0]
            __enable_irq();
    1a96:	b662      	cpsie	i
    1a98:	e009      	b.n	1aae <TL_AudioOutputI2S_OA_F32::update()+0x7a>
        } else {
            audio_block_t *tmp = block_left_1st;
            block_left_1st = block_left_2nd;
    1a9a:	4a24      	ldr	r2, [pc, #144]	; (1b2c <TL_AudioOutputI2S_OA_F32::update()+0xf8>)
    1a9c:	6013      	str	r3, [r2, #0]
            block_left_2nd = blockI16;
    1a9e:	4b25      	ldr	r3, [pc, #148]	; (1b34 <TL_AudioOutputI2S_OA_F32::update()+0x100>)
    1aa0:	601c      	str	r4, [r3, #0]
            block_left_offset = 0;
    1aa2:	2200      	movs	r2, #0
    1aa4:	4b22      	ldr	r3, [pc, #136]	; (1b30 <TL_AudioOutputI2S_OA_F32::update()+0xfc>)
    1aa6:	801a      	strh	r2, [r3, #0]
            __enable_irq();
    1aa8:	b662      	cpsie	i
            AudioStream::release(tmp);
    1aaa:	f002 f8db 	bl	3c64 <AudioStream::release(audio_block_struct*)>
        }
    }

    blockF32 = AudioStream_F32::receiveReadOnly_f32(1); // input 1 = right
    1aae:	2101      	movs	r1, #1
    1ab0:	4630      	mov	r0, r6
    1ab2:	f000 fa2d 	bl	1f10 <AudioStream_F32::receiveReadOnly_f32(unsigned int)>
    if (blockF32) {
    1ab6:	4605      	mov	r5, r0
    1ab8:	2800      	cmp	r0, #0
    1aba:	d031      	beq.n	1b20 <TL_AudioOutputI2S_OA_F32::update()+0xec>
    1abc:	2200      	movs	r2, #0
		for(int i=0; i<128; i++) {
    1abe:	2a7f      	cmp	r2, #127	; 0x7f
    1ac0:	dc10      	bgt.n	1ae4 <TL_AudioOutputI2S_OA_F32::update()+0xb0>
            blockI16->data[i] = (int16_t)(32768.0f*blockF32->data[i]);
    1ac2:	eb05 0382 	add.w	r3, r5, r2, lsl #2
    1ac6:	edd3 7a01 	vldr	s15, [r3, #4]
    1aca:	ed9f 7a17 	vldr	s14, [pc, #92]	; 1b28 <TL_AudioOutputI2S_OA_F32::update()+0xf4>
    1ace:	ee67 7a87 	vmul.f32	s15, s15, s14
    1ad2:	eb04 0142 	add.w	r1, r4, r2, lsl #1
    1ad6:	eefd 7ae7 	vcvt.s32.f32	s15, s15
    1ada:	ee17 3a90 	vmov	r3, s15
    1ade:	808b      	strh	r3, [r1, #4]
        }
    }

    blockF32 = AudioStream_F32::receiveReadOnly_f32(1); // input 1 = right
    if (blockF32) {
		for(int i=0; i<128; i++) {
    1ae0:	3201      	adds	r2, #1
    1ae2:	e7ec      	b.n	1abe <TL_AudioOutputI2S_OA_F32::update()+0x8a>
            blockI16->data[i] = (int16_t)(32768.0f*blockF32->data[i]);
        }
        AudioStream_F32::release(blockF32);  // Second end of F32 activity
    1ae4:	4628      	mov	r0, r5
    1ae6:	f000 f9dd 	bl	1ea4 <AudioStream_F32::release(audio_block_f32_t*)>

        __disable_irq();
    1aea:	b672      	cpsid	i
        if (block_right_1st == NULL) {
    1aec:	4b12      	ldr	r3, [pc, #72]	; (1b38 <TL_AudioOutputI2S_OA_F32::update()+0x104>)
    1aee:	6818      	ldr	r0, [r3, #0]
    1af0:	b928      	cbnz	r0, 1afe <TL_AudioOutputI2S_OA_F32::update()+0xca>
            block_right_1st = blockI16;
    1af2:	601c      	str	r4, [r3, #0]
            block_right_offset = 0;
    1af4:	2200      	movs	r2, #0
    1af6:	4b11      	ldr	r3, [pc, #68]	; (1b3c <TL_AudioOutputI2S_OA_F32::update()+0x108>)
    1af8:	801a      	strh	r2, [r3, #0]
            __enable_irq();
    1afa:	b662      	cpsie	i
    1afc:	e010      	b.n	1b20 <TL_AudioOutputI2S_OA_F32::update()+0xec>
        } else if (block_right_2nd == NULL) {
    1afe:	4b10      	ldr	r3, [pc, #64]	; (1b40 <TL_AudioOutputI2S_OA_F32::update()+0x10c>)
    1b00:	681b      	ldr	r3, [r3, #0]
    1b02:	b91b      	cbnz	r3, 1b0c <TL_AudioOutputI2S_OA_F32::update()+0xd8>
            block_right_2nd = blockI16;
    1b04:	4b0e      	ldr	r3, [pc, #56]	; (1b40 <TL_AudioOutputI2S_OA_F32::update()+0x10c>)
    1b06:	601c      	str	r4, [r3, #0]
            __enable_irq();
    1b08:	b662      	cpsie	i
    1b0a:	e009      	b.n	1b20 <TL_AudioOutputI2S_OA_F32::update()+0xec>
        } else {
            audio_block_t *tmp = block_right_1st;
            block_right_1st = block_right_2nd;
    1b0c:	4a0a      	ldr	r2, [pc, #40]	; (1b38 <TL_AudioOutputI2S_OA_F32::update()+0x104>)
    1b0e:	6013      	str	r3, [r2, #0]
            block_right_2nd = blockI16;
    1b10:	4b0b      	ldr	r3, [pc, #44]	; (1b40 <TL_AudioOutputI2S_OA_F32::update()+0x10c>)
    1b12:	601c      	str	r4, [r3, #0]
            block_right_offset = 0;
    1b14:	2200      	movs	r2, #0
    1b16:	4b09      	ldr	r3, [pc, #36]	; (1b3c <TL_AudioOutputI2S_OA_F32::update()+0x108>)
    1b18:	801a      	strh	r2, [r3, #0]
            __enable_irq();
    1b1a:	b662      	cpsie	i
            AudioStream::release(tmp);
    1b1c:	f002 f8a2 	bl	3c64 <AudioStream::release(audio_block_struct*)>
        }
    }
    AudioStream::release(blockI16);
    1b20:	4620      	mov	r0, r4
    1b22:	f002 f89f 	bl	3c64 <AudioStream::release(audio_block_struct*)>
    1b26:	bd70      	pop	{r4, r5, r6, pc}
    1b28:	47000000 	.word	0x47000000
    1b2c:	20001394 	.word	0x20001394
    1b30:	2000138c 	.word	0x2000138c
    1b34:	2000137c 	.word	0x2000137c
    1b38:	20001380 	.word	0x20001380
    1b3c:	20001398 	.word	0x20001398
    1b40:	20001390 	.word	0x20001390

00001b44 <__static_initialization_and_destruction_0(int, int)>:
    I2S1_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
            | I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    I2S1_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));

#endif
}
    1b44:	2801      	cmp	r0, #1
    1b46:	d10a      	bne.n	1b5e <__static_initialization_and_destruction_0(int, int)+0x1a>
    1b48:	b508      	push	{r3, lr}
    1b4a:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1b4e:	4299      	cmp	r1, r3
    1b50:	d104      	bne.n	1b5c <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * TL_AudioOutputI2S_OA_F32::block_left_2nd = NULL;
audio_block_t * TL_AudioOutputI2S_OA_F32::block_right_2nd = NULL;
uint16_t  TL_AudioOutputI2S_OA_F32::block_left_offset = 0;
uint16_t  TL_AudioOutputI2S_OA_F32::block_right_offset = 0;
bool TL_AudioOutputI2S_OA_F32::update_responsibility = false;
DMAChannel TL_AudioOutputI2S_OA_F32::dma(false);
    1b52:	4a03      	ldr	r2, [pc, #12]	; (1b60 <__static_initialization_and_destruction_0(int, int)+0x1c>)
    1b54:	4903      	ldr	r1, [pc, #12]	; (1b64 <__static_initialization_and_destruction_0(int, int)+0x20>)
    1b56:	4804      	ldr	r0, [pc, #16]	; (1b68 <__static_initialization_and_destruction_0(int, int)+0x24>)
    1b58:	f002 fa66 	bl	4028 <__aeabi_atexit>
    1b5c:	bd08      	pop	{r3, pc}
    1b5e:	4770      	bx	lr
    1b60:	20000640 	.word	0x20000640
    1b64:	00000365 	.word	0x00000365
    1b68:	20001384 	.word	0x20001384

00001b6c <TL_AudioOutputI2S_OA_F32::config_i2s()>:
#endif
#endif
#endif

void TL_AudioOutputI2S_OA_F32::config_i2s(void)
{
    1b6c:	b538      	push	{r3, r4, r5, lr}
    CORE_PIN9_CONFIG  = PORT_PCR_MUX(6); // pin  9, PTC3, I2S0_TX_BCLK
    CORE_PIN11_CONFIG = PORT_PCR_MUX(6); // pin 11, PTC6, I2S0_MCLK

#elif defined(__IMXRT1062__)

    CCM_CCGR5 |= CCM_CCGR5_SAI1(CCM_CCGR_ON);
    1b6e:	4a28      	ldr	r2, [pc, #160]	; (1c10 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa4>)
    1b70:	6fd3      	ldr	r3, [r2, #124]	; 0x7c
    1b72:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
    1b76:	67d3      	str	r3, [r2, #124]	; 0x7c

    // if either transmitter or receiver is enabled, do nothing
    if (I2S1_TCSR & I2S_TCSR_TE) return;
    1b78:	4b26      	ldr	r3, [pc, #152]	; (1c14 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa8>)
    1b7a:	689b      	ldr	r3, [r3, #8]
    1b7c:	2b00      	cmp	r3, #0
    1b7e:	db46      	blt.n	1c0e <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa2>
    if (I2S1_RCSR & I2S_RCSR_RE) return;
    1b80:	4b24      	ldr	r3, [pc, #144]	; (1c14 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa8>)
    1b82:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
    1b86:	2b00      	cmp	r3, #0
    1b88:	db41      	blt.n	1c0e <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa2>

    double C = ((double)fs * 256 * n1 * n2) / 24000000;
    int c0 = C;
    int c2 = 10000;
    int c1 = C * c2 - (c0 * c2);
    set_audioClock(c0, c1, c2);
    1b8a:	2300      	movs	r3, #0
    1b8c:	f242 7210 	movw	r2, #10000	; 0x2710
    1b90:	f44f 610c 	mov.w	r1, #2240	; 0x8c0
    1b94:	201c      	movs	r0, #28
    1b96:	f002 ff33 	bl	4a00 <___Z14set_audioClockilmb_veneer>

    // clear SAI1_CLK register locations
    CCM_CSCMR1 = (CCM_CSCMR1 & ~(CCM_CSCMR1_SAI1_CLK_SEL_MASK))
    1b9a:	4a1d      	ldr	r2, [pc, #116]	; (1c10 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xa4>)
    1b9c:	69d3      	ldr	r3, [r2, #28]
    1b9e:	f423 6340 	bic.w	r3, r3, #3072	; 0xc00
           | CCM_CSCMR1_SAI1_CLK_SEL(2); // &0x03 // (0,1,2): PLL3PFD0, PLL5, PLL4
    1ba2:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
    1ba6:	61d3      	str	r3, [r2, #28]
    CCM_CS1CDR = (CCM_CS1CDR & ~(CCM_CS1CDR_SAI1_CLK_PRED_MASK | CCM_CS1CDR_SAI1_CLK_PODF_MASK))
    1ba8:	6a91      	ldr	r1, [r2, #40]	; 0x28
    1baa:	4b1b      	ldr	r3, [pc, #108]	; (1c18 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xac>)
    1bac:	400b      	ands	r3, r1
           | CCM_CS1CDR_SAI1_CLK_PRED(n1-1) // &0x07
           | CCM_CS1CDR_SAI1_CLK_PODF(n2-1); // &0x3f
    1bae:	f043 03ce 	orr.w	r3, r3, #206	; 0xce
    1bb2:	6293      	str	r3, [r2, #40]	; 0x28

    // Select MCLK
    IOMUXC_GPR_GPR1 = (IOMUXC_GPR_GPR1
    1bb4:	f5a2 22a0 	sub.w	r2, r2, #327680	; 0x50000
    1bb8:	6851      	ldr	r1, [r2, #4]
        & ~(IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL_MASK))
        | (IOMUXC_GPR_GPR1_SAI1_MCLK_DIR | IOMUXC_GPR_GPR1_SAI1_MCLK1_SEL(0));
    1bba:	4b18      	ldr	r3, [pc, #96]	; (1c1c <TL_AudioOutputI2S_OA_F32::config_i2s()+0xb0>)
    1bbc:	400b      	ands	r3, r1
    1bbe:	f443 2300 	orr.w	r3, r3, #524288	; 0x80000
    1bc2:	6053      	str	r3, [r2, #4]

    CORE_PIN23_CONFIG = 3;  //1:MCLK
    1bc4:	4b16      	ldr	r3, [pc, #88]	; (1c20 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xb4>)
    1bc6:	2203      	movs	r2, #3
    1bc8:	f8c3 2120 	str.w	r2, [r3, #288]	; 0x120
    CORE_PIN21_CONFIG = 3;  //1:RX_BCLK
    1bcc:	f8c3 2128 	str.w	r2, [r3, #296]	; 0x128
    CORE_PIN20_CONFIG = 3;  //1:RX_SYNC
    1bd0:	f8c3 2124 	str.w	r2, [r3, #292]	; 0x124

    int rsync = 0;
    int tsync = 1;

    I2S1_TMR = 0;
    1bd4:	f503 13c6 	add.w	r3, r3, #1622016	; 0x18c000
    1bd8:	2500      	movs	r5, #0
    1bda:	661d      	str	r5, [r3, #96]	; 0x60
    //I2S1_TCSR = (1<<25); //Reset
    I2S1_TCR1 = I2S_TCR1_RFW(1);
    1bdc:	2401      	movs	r4, #1
    1bde:	60dc      	str	r4, [r3, #12]
    I2S1_TCR2 = I2S_TCR2_SYNC(tsync) | I2S_TCR2_BCP // sync=0; tx is async;
            | (I2S_TCR2_BCD | I2S_TCR2_DIV((1)) | I2S_TCR2_MSEL(1));
    1be0:	4a10      	ldr	r2, [pc, #64]	; (1c24 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xb8>)
    1be2:	611a      	str	r2, [r3, #16]
    I2S1_TCR3 = I2S_TCR3_TCE;
    1be4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    1be8:	6158      	str	r0, [r3, #20]
    I2S1_TCR4 = I2S_TCR4_FRSZ((2-1)) | I2S_TCR4_SYWD((32-1)) | I2S_TCR4_MF
            | I2S_TCR4_FSD | I2S_TCR4_FSE | I2S_TCR4_FSP;
    1bea:	490f      	ldr	r1, [pc, #60]	; (1c28 <TL_AudioOutputI2S_OA_F32::config_i2s()+0xbc>)
    1bec:	6199      	str	r1, [r3, #24]
    I2S1_TCR5 = I2S_TCR5_WNW((32-1)) | I2S_TCR5_W0W((32-1)) | I2S_TCR5_FBT((32-1));
    1bee:	4a0f      	ldr	r2, [pc, #60]	; (1c2c <TL_AudioOutputI2S_OA_F32::config_i2s()+0xc0>)
    1bf0:	61da      	str	r2, [r3, #28]

    I2S1_RMR = 0;
    1bf2:	f8c3 50e0 	str.w	r5, [r3, #224]	; 0xe0
    //I2S1_RCSR = (1<<25); //Reset
    I2S1_RCR1 = I2S_RCR1_RFW(1);
    1bf6:	f8c3 408c 	str.w	r4, [r3, #140]	; 0x8c
    I2S1_RCR2 = I2S_RCR2_SYNC(rsync) | I2S_RCR2_BCP  // sync=0; rx is async;
            | (I2S_RCR2_BCD | I2S_RCR2_DIV((1)) | I2S_RCR2_MSEL(1));
    1bfa:	f104 64e0 	add.w	r4, r4, #117440512	; 0x7000000
    1bfe:	f8c3 4090 	str.w	r4, [r3, #144]	; 0x90
    I2S1_RCR3 = I2S_RCR3_RCE;
    1c02:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94
    I2S1_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
            | I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    1c06:	f8c3 1098 	str.w	r1, [r3, #152]	; 0x98
    I2S1_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));
    1c0a:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
    1c0e:	bd38      	pop	{r3, r4, r5, pc}
    1c10:	400fc000 	.word	0x400fc000
    1c14:	40384000 	.word	0x40384000
    1c18:	fffffe00 	.word	0xfffffe00
    1c1c:	fff7fff8 	.word	0xfff7fff8
    1c20:	401f8000 	.word	0x401f8000
    1c24:	47000001 	.word	0x47000001
    1c28:	00011f1b 	.word	0x00011f1b
    1c2c:	1f1f1f00 	.word	0x1f1f1f00

00001c30 <TL_AudioOutputI2S_OA_F32::begin()>:
#if defined(__IMXRT1062__)
#include "utility/imxrt_hw.h"
#endif

void TL_AudioOutputI2S_OA_F32::begin(void)
{
    1c30:	b538      	push	{r3, r4, r5, lr}
    dma.begin(true); // Allocate the DMA channel first
    1c32:	4c28      	ldr	r4, [pc, #160]	; (1cd4 <TL_AudioOutputI2S_OA_F32::begin()+0xa4>)
    1c34:	2101      	movs	r1, #1
    1c36:	4620      	mov	r0, r4
    1c38:	f002 f858 	bl	3cec <DMAChannel::begin(bool)>
    block_left_1st = NULL;
    1c3c:	2500      	movs	r5, #0
    1c3e:	4b26      	ldr	r3, [pc, #152]	; (1cd8 <TL_AudioOutputI2S_OA_F32::begin()+0xa8>)
    1c40:	601d      	str	r5, [r3, #0]
    block_right_1st = NULL;
    1c42:	4b26      	ldr	r3, [pc, #152]	; (1cdc <TL_AudioOutputI2S_OA_F32::begin()+0xac>)
    1c44:	601d      	str	r5, [r3, #0]
    config_i2s();
    1c46:	f7ff ff91 	bl	1b6c <TL_AudioOutputI2S_OA_F32::config_i2s()>

    I2S0_TCSR = I2S_TCSR_SR;
    I2S0_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;

#elif defined(__IMXRT1062__)
    CORE_PIN7_CONFIG  = 3;  //1:TX_DATA0
    1c4a:	2203      	movs	r2, #3
    1c4c:	4b24      	ldr	r3, [pc, #144]	; (1ce0 <TL_AudioOutputI2S_OA_F32::begin()+0xb0>)
    1c4e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    dma.TCD->SADDR = i2s_tx_buffer;                // Serial.println("A1062 begin");
    1c52:	6823      	ldr	r3, [r4, #0]
    1c54:	4a23      	ldr	r2, [pc, #140]	; (1ce4 <TL_AudioOutputI2S_OA_F32::begin()+0xb4>)
    1c56:	601a      	str	r2, [r3, #0]
    dma.TCD->SOFF = 2;
    1c58:	6823      	ldr	r3, [r4, #0]
    1c5a:	2202      	movs	r2, #2
    1c5c:	809a      	strh	r2, [r3, #4]
    dma.TCD->ATTR = DMA_TCD_ATTR_SSIZE(1) | DMA_TCD_ATTR_DSIZE(1);
    1c5e:	f240 1101 	movw	r1, #257	; 0x101
    1c62:	80d9      	strh	r1, [r3, #6]
    dma.TCD->NBYTES_MLNO = 2;
    1c64:	609a      	str	r2, [r3, #8]
    dma.TCD->SLAST = -sizeof(i2s_tx_buffer);
    1c66:	f2a2 2202 	subw	r2, r2, #514	; 0x202
    1c6a:	60da      	str	r2, [r3, #12]
    dma.TCD->DOFF = 0;
    1c6c:	829d      	strh	r5, [r3, #20]
    dma.TCD->CITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
    1c6e:	f44f 7280 	mov.w	r2, #256	; 0x100
    1c72:	82da      	strh	r2, [r3, #22]
    dma.TCD->DLASTSGA = 0;
    1c74:	619d      	str	r5, [r3, #24]
    dma.TCD->BITER_ELINKNO = sizeof(i2s_tx_buffer) / 2;
    1c76:	83da      	strh	r2, [r3, #30]
    dma.TCD->CSR = DMA_TCD_CSR_INTHALF | DMA_TCD_CSR_INTMAJOR;
    1c78:	2206      	movs	r2, #6
    1c7a:	839a      	strh	r2, [r3, #28]
    dma.TCD->DADDR = (void *)((uint32_t)&I2S1_TDR0 + 2);
    1c7c:	4a1a      	ldr	r2, [pc, #104]	; (1ce8 <TL_AudioOutputI2S_OA_F32::begin()+0xb8>)
    1c7e:	611a      	str	r2, [r3, #16]
	// trigger moves a single data unit, which is typically 8, 16 or
	// 32 bits.  If a channel is configured for 200 transfers

	// Use a hardware trigger to make the DMA channel run
	void triggerAtHardwareEvent(uint8_t source) {
		volatile uint32_t *mux = &DMAMUX_CHCFG0 + channel;
    1c80:	7922      	ldrb	r2, [r4, #4]
    1c82:	4b1a      	ldr	r3, [pc, #104]	; (1cec <TL_AudioOutputI2S_OA_F32::begin()+0xbc>)
		//mux = (volatile uint32_t *)&(DMAMUX_CHCFG0) + channel;
		*mux = 0;
    1c84:	f843 5022 	str.w	r5, [r3, r2, lsl #2]
		*mux = (source & 0x7F) | DMAMUX_CHCFG_ENBL;
    1c88:	4919      	ldr	r1, [pc, #100]	; (1cf0 <TL_AudioOutputI2S_OA_F32::begin()+0xc0>)
    1c8a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
	/***************************************/
	/**    Enable / Disable               **/
	/***************************************/

	void enable(void) {
		DMA_SERQ = channel;
    1c8e:	7922      	ldrb	r2, [r4, #4]
    1c90:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
    1c94:	76da      	strb	r2, [r3, #27]
    dma.triggerAtHardwareEvent(DMAMUX_SOURCE_SAI1_TX);
    dma.enable();

    I2S1_RCSR |= I2S_RCSR_RE | I2S_RCSR_BCE;
    1c96:	f503 1327 	add.w	r3, r3, #2736128	; 0x29c000
    1c9a:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
    1c9e:	f042 4210 	orr.w	r2, r2, #2415919104	; 0x90000000
    1ca2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    I2S1_TCSR = I2S_TCSR_TE | I2S_TCSR_BCE | I2S_TCSR_FRDE;
    1ca6:	4a13      	ldr	r2, [pc, #76]	; (1cf4 <TL_AudioOutputI2S_OA_F32::begin()+0xc4>)
    1ca8:	609a      	str	r2, [r3, #8]
#endif
    update_responsibility = update_setup();
    1caa:	f002 f803 	bl	3cb4 <AudioStream::update_setup()>
    1cae:	4b12      	ldr	r3, [pc, #72]	; (1cf8 <TL_AudioOutputI2S_OA_F32::begin()+0xc8>)
    1cb0:	7018      	strb	r0, [r3, #0]

	// An interrupt routine can be run when the DMA channel completes
	// the entire transfer, and also optionally when half of the
	// transfer is completed.
	void attachInterrupt(void (*isr)(void)) {
		_VectorsRam[channel + IRQ_DMA_CH0 + 16] = isr;
    1cb2:	7923      	ldrb	r3, [r4, #4]
    1cb4:	f103 0110 	add.w	r1, r3, #16
    1cb8:	4810      	ldr	r0, [pc, #64]	; (1cfc <TL_AudioOutputI2S_OA_F32::begin()+0xcc>)
    1cba:	4a11      	ldr	r2, [pc, #68]	; (1d00 <TL_AudioOutputI2S_OA_F32::begin()+0xd0>)
    1cbc:	f842 0021 	str.w	r0, [r2, r1, lsl #2]
		NVIC_ENABLE_IRQ(IRQ_DMA_CH0 + channel);
    1cc0:	1159      	asrs	r1, r3, #5
    1cc2:	f003 031f 	and.w	r3, r3, #31
    1cc6:	2201      	movs	r2, #1
    1cc8:	fa02 f303 	lsl.w	r3, r2, r3
    1ccc:	4a0d      	ldr	r2, [pc, #52]	; (1d04 <TL_AudioOutputI2S_OA_F32::begin()+0xd4>)
    1cce:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    1cd2:	bd38      	pop	{r3, r4, r5, pc}
    1cd4:	20001384 	.word	0x20001384
    1cd8:	20001394 	.word	0x20001394
    1cdc:	20001380 	.word	0x20001380
    1ce0:	401f8000 	.word	0x401f8000
    1ce4:	20200a40 	.word	0x20200a40
    1ce8:	40384022 	.word	0x40384022
    1cec:	400ec000 	.word	0x400ec000
    1cf0:	80000014 	.word	0x80000014
    1cf4:	90000001 	.word	0x90000001
    1cf8:	2000138e 	.word	0x2000138e
    1cfc:	00001905 	.word	0x00001905
    1d00:	20001800 	.word	0x20001800
    1d04:	e000e100 	.word	0xe000e100

00001d08 <_GLOBAL__sub_I__ZN24TL_AudioOutputI2S_OA_F3214block_left_1stE>:
    I2S1_RCR4 = I2S_RCR4_FRSZ((2-1)) | I2S_RCR4_SYWD((32-1)) | I2S_RCR4_MF
            | I2S_RCR4_FSE | I2S_RCR4_FSP | I2S_RCR4_FSD;
    I2S1_RCR5 = I2S_RCR5_WNW((32-1)) | I2S_RCR5_W0W((32-1)) | I2S_RCR5_FBT((32-1));

#endif
}
    1d08:	b508      	push	{r3, lr}
    1d0a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    1d0e:	2001      	movs	r0, #1
    1d10:	f7ff ff18 	bl	1b44 <__static_initialization_and_destruction_0(int, int)>
    1d14:	bd08      	pop	{r3, pc}
    1d16:	bf00      	nop

00001d18 <allocate_f32_memory(int)>:
uint8_t AudioStream_F32::f32_memory_used_max = 0;

audio_block_f32_t* allocate_f32_memory(const int num) {
	static bool firstTime=true;
	static audio_block_f32_t *data_f32;
	if (firstTime == true) {
    1d18:	4b16      	ldr	r3, [pc, #88]	; (1d74 <allocate_f32_memory(int)+0x5c>)
    1d1a:	781b      	ldrb	r3, [r3, #0]
    1d1c:	b33b      	cbz	r3, 1d6e <allocate_f32_memory(int)+0x56>
uint32_t AudioStream_F32::f32_memory_pool_available_mask[6];

uint8_t AudioStream_F32::f32_memory_used = 0;
uint8_t AudioStream_F32::f32_memory_used_max = 0;

audio_block_f32_t* allocate_f32_memory(const int num) {
    1d1e:	b510      	push	{r4, lr}
	static bool firstTime=true;
	static audio_block_f32_t *data_f32;
	if (firstTime == true) {
		firstTime = false;
    1d20:	2200      	movs	r2, #0
    1d22:	4b14      	ldr	r3, [pc, #80]	; (1d74 <allocate_f32_memory(int)+0x5c>)
    1d24:	701a      	strb	r2, [r3, #0]
		data_f32 = new audio_block_f32_t[num];
    1d26:	f5b0 1f76 	cmp.w	r0, #4030464	; 0x3d8000
    1d2a:	d804      	bhi.n	1d36 <allocate_f32_memory(int)+0x1e>
    1d2c:	f44f 7305 	mov.w	r3, #532	; 0x214
    1d30:	fb03 f300 	mul.w	r3, r3, r0
    1d34:	e001      	b.n	1d3a <allocate_f32_memory(int)+0x22>
    1d36:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
    1d3a:	4604      	mov	r4, r0
    1d3c:	4618      	mov	r0, r3
    1d3e:	f002 f8ad 	bl	3e9c <operator new[](unsigned int)>
    1d42:	1e62      	subs	r2, r4, #1
    1d44:	4603      	mov	r3, r0
    1d46:	f1b2 3fff 	cmp.w	r2, #4294967295	; 0xffffffff
    1d4a:	d00b      	beq.n	1d64 <allocate_f32_memory(int)+0x4c>
//modeled on the existing teensy audio block struct, which uses Int16
//https://github.com/PaulStoffregen/cores/blob/268848cdb0121f26b7ef6b82b4fb54abbe465427/teensy3/AudioStream.h
// Added id, per Tympan.  Should not disturb existing programs.  Bob Larkin June 2020
class audio_block_f32_t {
	public:
		audio_block_f32_t(void) {};
    1d4c:	2180      	movs	r1, #128	; 0x80
    1d4e:	f8c3 1204 	str.w	r1, [r3, #516]	; 0x204
    1d52:	f8c3 1208 	str.w	r1, [r3, #520]	; 0x208
    1d56:	4908      	ldr	r1, [pc, #32]	; (1d78 <allocate_f32_memory(int)+0x60>)
    1d58:	f8c3 120c 	str.w	r1, [r3, #524]	; 0x20c
    1d5c:	f503 7305 	add.w	r3, r3, #532	; 0x214
    1d60:	3a01      	subs	r2, #1
    1d62:	e7f0      	b.n	1d46 <allocate_f32_memory(int)+0x2e>
    1d64:	4b05      	ldr	r3, [pc, #20]	; (1d7c <allocate_f32_memory(int)+0x64>)
    1d66:	6018      	str	r0, [r3, #0]
	}
	return data_f32;
}
    1d68:	4b04      	ldr	r3, [pc, #16]	; (1d7c <allocate_f32_memory(int)+0x64>)
    1d6a:	6818      	ldr	r0, [r3, #0]
    1d6c:	bd10      	pop	{r4, pc}
    1d6e:	4b03      	ldr	r3, [pc, #12]	; (1d7c <allocate_f32_memory(int)+0x64>)
    1d70:	6818      	ldr	r0, [r3, #0]
    1d72:	4770      	bx	lr
    1d74:	20000698 	.word	0x20000698
    1d78:	472c4400 	.word	0x472c4400
    1d7c:	200013b4 	.word	0x200013b4

00001d80 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)>:
}

// Set up the pool of audio data blocks
// placing them all onto the free list
void AudioStream_F32::initialize_f32_memory(audio_block_f32_t *data, unsigned int num)
{
    1d80:	b470      	push	{r4, r5, r6}
  unsigned int i;

  //Serial.println("AudioStream_F32 initialize_memory");
  //delay(10);
  if (num > 192) num = 192;
    1d82:	29c0      	cmp	r1, #192	; 0xc0
    1d84:	d900      	bls.n	1d88 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x8>
    1d86:	21c0      	movs	r1, #192	; 0xc0
  __disable_irq();
    1d88:	b672      	cpsid	i
  f32_memory_pool = data;
    1d8a:	4b14      	ldr	r3, [pc, #80]	; (1ddc <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x5c>)
    1d8c:	6018      	str	r0, [r3, #0]
  for (i=0; i < 6; i++) {
    1d8e:	2300      	movs	r3, #0
    1d90:	2b05      	cmp	r3, #5
    1d92:	d805      	bhi.n	1da0 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x20>
    f32_memory_pool_available_mask[i] = 0;
    1d94:	2400      	movs	r4, #0
    1d96:	4a12      	ldr	r2, [pc, #72]	; (1de0 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x60>)
    1d98:	f842 4023 	str.w	r4, [r2, r3, lsl #2]
  //Serial.println("AudioStream_F32 initialize_memory");
  //delay(10);
  if (num > 192) num = 192;
  __disable_irq();
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    1d9c:	3301      	adds	r3, #1
    1d9e:	e7f7      	b.n	1d90 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x10>
    1da0:	2200      	movs	r2, #0
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
    1da2:	4291      	cmp	r1, r2
    1da4:	d90c      	bls.n	1dc0 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x40>
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
    1da6:	0955      	lsrs	r5, r2, #5
    1da8:	f002 041f 	and.w	r4, r2, #31
    1dac:	2301      	movs	r3, #1
    1dae:	40a3      	lsls	r3, r4
    1db0:	4c0b      	ldr	r4, [pc, #44]	; (1de0 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x60>)
    1db2:	f854 6025 	ldr.w	r6, [r4, r5, lsl #2]
    1db6:	4333      	orrs	r3, r6
    1db8:	f844 3025 	str.w	r3, [r4, r5, lsl #2]
  __disable_irq();
  f32_memory_pool = data;
  for (i=0; i < 6; i++) {
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
    1dbc:	3201      	adds	r2, #1
    1dbe:	e7f0      	b.n	1da2 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x22>
    1dc0:	2300      	movs	r3, #0
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
  }
  for (i=0; i < num; i++) {
    1dc2:	4299      	cmp	r1, r3
    1dc4:	d906      	bls.n	1dd4 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x54>
    data[i].memory_pool_index = i;
    1dc6:	f44f 7205 	mov.w	r2, #532	; 0x214
    1dca:	fb02 0203 	mla	r2, r2, r3, r0
    1dce:	7053      	strb	r3, [r2, #1]
    f32_memory_pool_available_mask[i] = 0;
  }
  for (i=0; i < num; i++) {
    f32_memory_pool_available_mask[i >> 5] |= (1 << (i & 0x1F));
  }
  for (i=0; i < num; i++) {
    1dd0:	3301      	adds	r3, #1
    1dd2:	e7f6      	b.n	1dc2 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)+0x42>
    data[i].memory_pool_index = i;
  }
  __enable_irq();
    1dd4:	b662      	cpsie	i

} // end initialize_memory
    1dd6:	bc70      	pop	{r4, r5, r6}
    1dd8:	4770      	bx	lr
    1dda:	bf00      	nop
    1ddc:	200013bc 	.word	0x200013bc
    1de0:	2000139c 	.word	0x2000139c

00001de4 <AudioMemory_F32(int)>:
		firstTime = false;
		data_f32 = new audio_block_f32_t[num];
	}
	return data_f32;
}
void AudioMemory_F32(const int num) {
    1de4:	b510      	push	{r4, lr}
    1de6:	4604      	mov	r4, r0
	audio_block_f32_t *data_f32 = allocate_f32_memory(num);
    1de8:	f7ff ff96 	bl	1d18 <allocate_f32_memory(int)>
	if (data_f32 != NULL) AudioStream_F32::initialize_f32_memory(data_f32, num);
    1dec:	b110      	cbz	r0, 1df4 <AudioMemory_F32(int)+0x10>
    1dee:	4621      	mov	r1, r4
    1df0:	f7ff ffc6 	bl	1d80 <AudioStream_F32::initialize_f32_memory(audio_block_f32_t*, unsigned int)>
    1df4:	bd10      	pop	{r4, pc}
    1df6:	bf00      	nop

00001df8 <AudioStream_F32::allocate_f32()>:
} // end initialize_memory

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_f32_t * AudioStream_F32::allocate_f32(void)
{
    1df8:	b410      	push	{r4}
  uint32_t *p;
  audio_block_f32_t *block;
  uint8_t used;

  p = f32_memory_pool_available_mask;
  __disable_irq();
    1dfa:	b672      	cpsid	i
  do {
    avail = *p; if (avail) break;
    1dfc:	4b20      	ldr	r3, [pc, #128]	; (1e80 <AudioStream_F32::allocate_f32()+0x88>)
    1dfe:	6819      	ldr	r1, [r3, #0]
    1e00:	b961      	cbnz	r1, 1e1c <AudioStream_F32::allocate_f32()+0x24>
    p++; avail = *p; if (avail) break;
    1e02:	6859      	ldr	r1, [r3, #4]
    1e04:	b961      	cbnz	r1, 1e20 <AudioStream_F32::allocate_f32()+0x28>
    p++; avail = *p; if (avail) break;
    1e06:	6899      	ldr	r1, [r3, #8]
    1e08:	b961      	cbnz	r1, 1e24 <AudioStream_F32::allocate_f32()+0x2c>
    p++; avail = *p; if (avail) break;
    1e0a:	68d9      	ldr	r1, [r3, #12]
    1e0c:	b961      	cbnz	r1, 1e28 <AudioStream_F32::allocate_f32()+0x30>
    p++; avail = *p; if (avail) break;
    1e0e:	6919      	ldr	r1, [r3, #16]
    1e10:	b961      	cbnz	r1, 1e2c <AudioStream_F32::allocate_f32()+0x34>
    p++; avail = *p; if (avail) break;
    1e12:	6959      	ldr	r1, [r3, #20]
    1e14:	b961      	cbnz	r1, 1e30 <AudioStream_F32::allocate_f32()+0x38>
    __enable_irq();
    1e16:	b662      	cpsie	i
    //Serial.println("alloc_f32:null");
    return NULL;
    1e18:	2000      	movs	r0, #0
    1e1a:	e02e      	b.n	1e7a <AudioStream_F32::allocate_f32()+0x82>
  uint32_t n, index, avail;
  uint32_t *p;
  audio_block_f32_t *block;
  uint8_t used;

  p = f32_memory_pool_available_mask;
    1e1c:	4b18      	ldr	r3, [pc, #96]	; (1e80 <AudioStream_F32::allocate_f32()+0x88>)
    1e1e:	e008      	b.n	1e32 <AudioStream_F32::allocate_f32()+0x3a>
  __disable_irq();
  do {
    avail = *p; if (avail) break;
    p++; avail = *p; if (avail) break;
    1e20:	4b18      	ldr	r3, [pc, #96]	; (1e84 <AudioStream_F32::allocate_f32()+0x8c>)
    1e22:	e006      	b.n	1e32 <AudioStream_F32::allocate_f32()+0x3a>
    p++; avail = *p; if (avail) break;
    1e24:	4b18      	ldr	r3, [pc, #96]	; (1e88 <AudioStream_F32::allocate_f32()+0x90>)
    1e26:	e004      	b.n	1e32 <AudioStream_F32::allocate_f32()+0x3a>
    p++; avail = *p; if (avail) break;
    1e28:	4b18      	ldr	r3, [pc, #96]	; (1e8c <AudioStream_F32::allocate_f32()+0x94>)
    1e2a:	e002      	b.n	1e32 <AudioStream_F32::allocate_f32()+0x3a>
    p++; avail = *p; if (avail) break;
    1e2c:	4b18      	ldr	r3, [pc, #96]	; (1e90 <AudioStream_F32::allocate_f32()+0x98>)
    1e2e:	e000      	b.n	1e32 <AudioStream_F32::allocate_f32()+0x3a>
    p++; avail = *p; if (avail) break;
    1e30:	4b18      	ldr	r3, [pc, #96]	; (1e94 <AudioStream_F32::allocate_f32()+0x9c>)
    __enable_irq();
    //Serial.println("alloc_f32:null");
    return NULL;
  } while (0);
  n = __builtin_clz(avail);
    1e32:	fab1 f281 	clz	r2, r1
  *p = avail & ~(0x80000000 >> n);
    1e36:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
    1e3a:	40d0      	lsrs	r0, r2
    1e3c:	ea21 0100 	bic.w	r1, r1, r0
    1e40:	6019      	str	r1, [r3, #0]
  used = f32_memory_used + 1;
    1e42:	4815      	ldr	r0, [pc, #84]	; (1e98 <AudioStream_F32::allocate_f32()+0xa0>)
    1e44:	7801      	ldrb	r1, [r0, #0]
    1e46:	3101      	adds	r1, #1
    1e48:	b2c9      	uxtb	r1, r1
  f32_memory_used = used;
    1e4a:	7001      	strb	r1, [r0, #0]
  __enable_irq();
    1e4c:	b662      	cpsie	i
  index = p - f32_memory_pool_available_mask;
    1e4e:	480c      	ldr	r0, [pc, #48]	; (1e80 <AudioStream_F32::allocate_f32()+0x88>)
    1e50:	1a1b      	subs	r3, r3, r0
    1e52:	109b      	asrs	r3, r3, #2
  block = f32_memory_pool + ((index << 5) + (31 - n));
    1e54:	4811      	ldr	r0, [pc, #68]	; (1e9c <AudioStream_F32::allocate_f32()+0xa4>)
    1e56:	6804      	ldr	r4, [r0, #0]
    1e58:	ebc2 1243 	rsb	r2, r2, r3, lsl #5
    1e5c:	f244 036c 	movw	r3, #16492	; 0x406c
    1e60:	f44f 7005 	mov.w	r0, #532	; 0x214
    1e64:	fb00 3302 	mla	r3, r0, r2, r3
    1e68:	18e0      	adds	r0, r4, r3
  block->ref_count = 1;
    1e6a:	2201      	movs	r2, #1
    1e6c:	54e2      	strb	r2, [r4, r3]
  if (used > f32_memory_used_max) f32_memory_used_max = used;
    1e6e:	4b0c      	ldr	r3, [pc, #48]	; (1ea0 <AudioStream_F32::allocate_f32()+0xa8>)
    1e70:	781b      	ldrb	r3, [r3, #0]
    1e72:	4299      	cmp	r1, r3
    1e74:	d901      	bls.n	1e7a <AudioStream_F32::allocate_f32()+0x82>
    1e76:	4b0a      	ldr	r3, [pc, #40]	; (1ea0 <AudioStream_F32::allocate_f32()+0xa8>)
    1e78:	7019      	strb	r1, [r3, #0]
  //Serial.print("alloc_f32:");
  //Serial.println((uint32_t)block, HEX);
  return block;
}
    1e7a:	f85d 4b04 	ldr.w	r4, [sp], #4
    1e7e:	4770      	bx	lr
    1e80:	2000139c 	.word	0x2000139c
    1e84:	200013a0 	.word	0x200013a0
    1e88:	200013a4 	.word	0x200013a4
    1e8c:	200013a8 	.word	0x200013a8
    1e90:	200013ac 	.word	0x200013ac
    1e94:	200013b0 	.word	0x200013b0
    1e98:	200013b8 	.word	0x200013b8
    1e9c:	200013bc 	.word	0x200013bc
    1ea0:	200013b9 	.word	0x200013b9

00001ea4 <AudioStream_F32::release(audio_block_f32_t*)>:
// Release ownership of a data block.  If no
// other streams have ownership, the block is
// returned to the free pool
void AudioStream_F32::release(audio_block_f32_t *block)
{
  uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
    1ea4:	7843      	ldrb	r3, [r0, #1]
    1ea6:	43da      	mvns	r2, r3
    1ea8:	f002 011f 	and.w	r1, r2, #31
    1eac:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    1eb0:	40ca      	lsrs	r2, r1
  uint32_t index = block->memory_pool_index >> 5;
    1eb2:	115b      	asrs	r3, r3, #5

  __disable_irq();
    1eb4:	b672      	cpsid	i
  if (block->ref_count > 1) {
    1eb6:	7801      	ldrb	r1, [r0, #0]
    1eb8:	2901      	cmp	r1, #1
    1eba:	d902      	bls.n	1ec2 <AudioStream_F32::release(audio_block_f32_t*)+0x1e>
    block->ref_count--;
    1ebc:	3901      	subs	r1, #1
    1ebe:	7001      	strb	r1, [r0, #0]
    1ec0:	e009      	b.n	1ed6 <AudioStream_F32::release(audio_block_f32_t*)+0x32>
  } else {
    //Serial.print("release_f32:");
    //Serial.println((uint32_t)block, HEX);
    f32_memory_pool_available_mask[index] |= mask;
    1ec2:	4906      	ldr	r1, [pc, #24]	; (1edc <AudioStream_F32::release(audio_block_f32_t*)+0x38>)
    1ec4:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    1ec8:	4302      	orrs	r2, r0
    1eca:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    f32_memory_used--;
    1ece:	4a04      	ldr	r2, [pc, #16]	; (1ee0 <AudioStream_F32::release(audio_block_f32_t*)+0x3c>)
    1ed0:	7813      	ldrb	r3, [r2, #0]
    1ed2:	3b01      	subs	r3, #1
    1ed4:	7013      	strb	r3, [r2, #0]
  }
  __enable_irq();
    1ed6:	b662      	cpsie	i
    1ed8:	4770      	bx	lr
    1eda:	bf00      	nop
    1edc:	2000139c 	.word	0x2000139c
    1ee0:	200013b8 	.word	0x200013b8

00001ee4 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>:
// owned by this object.  Normally, a block must be released
// by the caller after it's transmitted.  This allows the
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream_F32::transmit(audio_block_f32_t *block, unsigned char index)
{
    1ee4:	b430      	push	{r4, r5}
  //Serial.print("AudioStream_F32: transmit().  start...index = ");Serial.println(index);
  for (AudioConnection_F32 *c = destination_list_f32; c != NULL; c = c->next_dest) {
    1ee6:	69c3      	ldr	r3, [r0, #28]
    1ee8:	b17b      	cbz	r3, 1f0a <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x26>
  	  //Serial.print("  : loop1, c->src_index = ");Serial.println(c->src_index);
    if (c->src_index == index) {
    1eea:	7a18      	ldrb	r0, [r3, #8]
    1eec:	4290      	cmp	r0, r2
    1eee:	d10a      	bne.n	1f06 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x22>
    	//Serial.println("  : if1");
      if (c->dst.inputQueue_f32[c->dest_index] == NULL) {
    1ef0:	6858      	ldr	r0, [r3, #4]
    1ef2:	6a00      	ldr	r0, [r0, #32]
    1ef4:	7a5c      	ldrb	r4, [r3, #9]
    1ef6:	f850 5024 	ldr.w	r5, [r0, r4, lsl #2]
    1efa:	b925      	cbnz	r5, 1f06 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x22>
      	  //Serial.println("  : if2");
        c->dst.inputQueue_f32[c->dest_index] = block;
    1efc:	f840 1024 	str.w	r1, [r0, r4, lsl #2]
        block->ref_count++;
    1f00:	7808      	ldrb	r0, [r1, #0]
    1f02:	3001      	adds	r0, #1
    1f04:	7008      	strb	r0, [r1, #0]
// caller to transmit to same block to more than 1 output,
// and then release it once after all transmit calls.
void AudioStream_F32::transmit(audio_block_f32_t *block, unsigned char index)
{
  //Serial.print("AudioStream_F32: transmit().  start...index = ");Serial.println(index);
  for (AudioConnection_F32 *c = destination_list_f32; c != NULL; c = c->next_dest) {
    1f06:	68db      	ldr	r3, [r3, #12]
    1f08:	e7ee      	b.n	1ee8 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)+0x4>
          //Serial.print("  : block->ref_count = "); Serial.println(block->ref_count);
      }
    }
  } 
  //Serial.println("AudioStream_F32: transmit(). finished.");
}
    1f0a:	bc30      	pop	{r4, r5}
    1f0c:	4770      	bx	lr
    1f0e:	bf00      	nop

00001f10 <AudioStream_F32::receiveReadOnly_f32(unsigned int)>:
// may be shared with other streams, so it must not be written
audio_block_f32_t * AudioStream_F32::receiveReadOnly_f32(unsigned int index)
{
  audio_block_f32_t *in;

  if (index >= num_inputs_f32) return NULL;
    1f10:	7e03      	ldrb	r3, [r0, #24]
    1f12:	428b      	cmp	r3, r1
    1f14:	d906      	bls.n	1f24 <AudioStream_F32::receiveReadOnly_f32(unsigned int)+0x14>
  in = inputQueue_f32[index];
    1f16:	6a03      	ldr	r3, [r0, #32]
    1f18:	f853 0021 	ldr.w	r0, [r3, r1, lsl #2]
  inputQueue_f32[index] = NULL;
    1f1c:	2200      	movs	r2, #0
    1f1e:	f843 2021 	str.w	r2, [r3, r1, lsl #2]
  return in;
    1f22:	4770      	bx	lr
// may be shared with other streams, so it must not be written
audio_block_f32_t * AudioStream_F32::receiveReadOnly_f32(unsigned int index)
{
  audio_block_f32_t *in;

  if (index >= num_inputs_f32) return NULL;
    1f24:	2000      	movs	r0, #0
  in = inputQueue_f32[index];
  inputQueue_f32[index] = NULL;
  return in;
}
    1f26:	4770      	bx	lr

00001f28 <AudioConnection_F32::connect()>:
}

void AudioConnection_F32::connect(void) {
  AudioConnection_F32 *p;
  
  if (dest_index > dst.num_inputs_f32) return;
    1f28:	7a42      	ldrb	r2, [r0, #9]
    1f2a:	6843      	ldr	r3, [r0, #4]
    1f2c:	7e1b      	ldrb	r3, [r3, #24]
    1f2e:	429a      	cmp	r2, r3
    1f30:	d810      	bhi.n	1f54 <AudioConnection_F32::connect()+0x2c>
  __disable_irq();
    1f32:	b672      	cpsid	i
  p = src.destination_list_f32;
    1f34:	6803      	ldr	r3, [r0, #0]
    1f36:	69da      	ldr	r2, [r3, #28]
  if (p == NULL) {
    1f38:	b912      	cbnz	r2, 1f40 <AudioConnection_F32::connect()+0x18>
    src.destination_list_f32 = this;
    1f3a:	61d8      	str	r0, [r3, #28]
    1f3c:	e004      	b.n	1f48 <AudioConnection_F32::connect()+0x20>
  } else {
    while (p->next_dest) p = p->next_dest;
    1f3e:	461a      	mov	r2, r3
    1f40:	68d3      	ldr	r3, [r2, #12]
    1f42:	2b00      	cmp	r3, #0
    1f44:	d1fb      	bne.n	1f3e <AudioConnection_F32::connect()+0x16>
    p->next_dest = this;
    1f46:	60d0      	str	r0, [r2, #12]
  }
  src.active = true;
    1f48:	6802      	ldr	r2, [r0, #0]
    1f4a:	2301      	movs	r3, #1
    1f4c:	7213      	strb	r3, [r2, #8]
  dst.active = true;
    1f4e:	6842      	ldr	r2, [r0, #4]
    1f50:	7213      	strb	r3, [r2, #8]
  __enable_irq();
    1f52:	b662      	cpsie	i
    1f54:	4770      	bx	lr
    1f56:	bf00      	nop

00001f58 <__static_initialization_and_destruction_0(int, int)>:
    I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
        | I2S_RCR4_FSE | I2S_RCR4_FSP;
    I2S1_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

#endif
}
    1f58:	2801      	cmp	r0, #1
    1f5a:	d10a      	bne.n	1f72 <__static_initialization_and_destruction_0(int, int)+0x1a>
    1f5c:	b508      	push	{r3, lr}
    1f5e:	f64f 73ff 	movw	r3, #65535	; 0xffff
    1f62:	4299      	cmp	r1, r3
    1f64:	d104      	bne.n	1f70 <__static_initialization_and_destruction_0(int, int)+0x18>
audio_block_t * AudioOutputI2S_OA_F32::block_left_2nd = NULL;
audio_block_t * AudioOutputI2S_OA_F32::block_right_2nd = NULL;
uint16_t  AudioOutputI2S_OA_F32::block_left_offset = 0;
uint16_t  AudioOutputI2S_OA_F32::block_right_offset = 0;
bool AudioOutputI2S_OA_F32::update_responsibility = false;
DMAChannel AudioOutputI2S_OA_F32::dma(false);
    1f66:	4a03      	ldr	r2, [pc, #12]	; (1f74 <__static_initialization_and_destruction_0(int, int)+0x1c>)
    1f68:	4903      	ldr	r1, [pc, #12]	; (1f78 <__static_initialization_and_destruction_0(int, int)+0x20>)
    1f6a:	4804      	ldr	r0, [pc, #16]	; (1f7c <__static_initialization_and_destruction_0(int, int)+0x24>)
    1f6c:	f002 f85c 	bl	4028 <__aeabi_atexit>
    1f70:	bd08      	pop	{r3, pc}
    1f72:	4770      	bx	lr
    1f74:	20000640 	.word	0x20000640
    1f78:	00000365 	.word	0x00000365
    1f7c:	200013c0 	.word	0x200013c0

00001f80 <_GLOBAL__sub_I__ZN21AudioOutputI2S_OA_F3214block_left_1stE>:
    I2S1_RCR4 = I2S_RCR4_FRSZ(1) | I2S_RCR4_SYWD(31) | I2S_RCR4_MF
        | I2S_RCR4_FSE | I2S_RCR4_FSP;
    I2S1_RCR5 = I2S_RCR5_WNW(31) | I2S_RCR5_W0W(31) | I2S_RCR5_FBT(31);

#endif
}
    1f80:	b508      	push	{r3, lr}
    1f82:	f64f 71ff 	movw	r1, #65535	; 0xffff
    1f86:	2001      	movs	r0, #1
    1f88:	f7ff ffe6 	bl	1f58 <__static_initialization_and_destruction_0(int, int)>
    1f8c:	bd08      	pop	{r3, pc}
    1f8e:	bf00      	nop

00001f90 <AudioSynthWaveformSine_F32::update()>:
extern "C" {
  extern const int16_t AudioWaveformSine[257];
}

void AudioSynthWaveformSine_F32::update(void)
{
    1f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	audio_block_f32_t *block;
	uint32_t i, ph, inc, index, scale;
	int32_t val1, val2;
	static uint32_t block_length = 0;
	
	if (enabled) {
    1f92:	f890 3038 	ldrb.w	r3, [r0, #56]	; 0x38
    1f96:	f013 0fff 	tst.w	r3, #255	; 0xff
    1f9a:	d043      	beq.n	2024 <AudioSynthWaveformSine_F32::update()+0x94>
    1f9c:	4604      	mov	r4, r0
		if (magnitude) {
    1f9e:	6b03      	ldr	r3, [r0, #48]	; 0x30
    1fa0:	b3cb      	cbz	r3, 2016 <AudioSynthWaveformSine_F32::update()+0x86>
			block = allocate_f32();
    1fa2:	f7ff ff29 	bl	1df8 <AudioStream_F32::allocate_f32()>
			if (block) {
    1fa6:	4605      	mov	r5, r0
    1fa8:	b3a8      	cbz	r0, 2016 <AudioSynthWaveformSine_F32::update()+0x86>
				block_length = (uint32_t)block->length;
    1faa:	f8d0 e208 	ldr.w	lr, [r0, #520]	; 0x208
    1fae:	4b1e      	ldr	r3, [pc, #120]	; (2028 <AudioSynthWaveformSine_F32::update()+0x98>)
    1fb0:	f8c3 e000 	str.w	lr, [r3]
				ph = phase_accumulator;
    1fb4:	6aa1      	ldr	r1, [r4, #40]	; 0x28
				inc = phase_increment;
    1fb6:	f8d4 c02c 	ldr.w	ip, [r4, #44]	; 0x2c
				for (i=0; i < block_length; i++) {
    1fba:	2000      	movs	r0, #0
    1fbc:	4570      	cmp	r0, lr
    1fbe:	d220      	bcs.n	2002 <AudioSynthWaveformSine_F32::update()+0x72>
					index = ph >> 24;
    1fc0:	0e0a      	lsrs	r2, r1, #24
					val1 = AudioWaveformSine[index];
    1fc2:	4e1a      	ldr	r6, [pc, #104]	; (202c <AudioSynthWaveformSine_F32::update()+0x9c>)
    1fc4:	f936 3012 	ldrsh.w	r3, [r6, r2, lsl #1]
					val2 = AudioWaveformSine[index+1];
    1fc8:	3201      	adds	r2, #1
    1fca:	f936 2012 	ldrsh.w	r2, [r6, r2, lsl #1]
					scale = (ph >> 8) & 0xFFFF;
    1fce:	f3c1 270f 	ubfx	r7, r1, #8, #16
					val2 *= scale;
					val1 *= 0x10000 - scale;
    1fd2:	f5c7 3680 	rsb	r6, r7, #65536	; 0x10000
    1fd6:	fb06 f303 	mul.w	r3, r6, r3
	#if (defined(KINETISK) || defined(__IMXRT1062__) )
					block->data[i] = (float) multiply_32x32_rshift32(val1 + val2, magnitude);
    1fda:	fb07 3302 	mla	r3, r7, r2, r3
    1fde:	6b22      	ldr	r2, [r4, #48]	; 0x30
static inline int32_t multiply_32x32_rshift32(int32_t a, int32_t b) __attribute__((always_inline, unused));
static inline int32_t multiply_32x32_rshift32(int32_t a, int32_t b)
{
#if defined (__ARM_ARCH_7EM__)
	int32_t out;
	asm volatile("smmul %0, %1, %2" : "=r" (out) : "r" (a), "r" (b));
    1fe0:	fb53 f302 	smmul	r3, r3, r2
    1fe4:	ee07 3a90 	vmov	s15, r3
    1fe8:	eef8 7ae7 	vcvt.f32.s32	s15, s15
    1fec:	eb05 0380 	add.w	r3, r5, r0, lsl #2
	#elif defined(KINETISL)
					block->data[i] = (float) ((((val1 + val2) >> 16) * magnitude) >> 16);
	#endif
					ph += inc;					
    1ff0:	4461      	add	r1, ip
					block->data[i] = block->data[i] / 32767.0f; // scale to float
    1ff2:	eddf 6a0f 	vldr	s13, [pc, #60]	; 2030 <AudioSynthWaveformSine_F32::update()+0xa0>
    1ff6:	ee87 7aa6 	vdiv.f32	s14, s15, s13
    1ffa:	ed83 7a01 	vstr	s14, [r3, #4]
			block = allocate_f32();
			if (block) {
				block_length = (uint32_t)block->length;
				ph = phase_accumulator;
				inc = phase_increment;
				for (i=0; i < block_length; i++) {
    1ffe:	3001      	adds	r0, #1
    2000:	e7dc      	b.n	1fbc <AudioSynthWaveformSine_F32::update()+0x2c>
					block->data[i] = (float) ((((val1 + val2) >> 16) * magnitude) >> 16);
	#endif
					ph += inc;					
					block->data[i] = block->data[i] / 32767.0f; // scale to float
				}
				phase_accumulator = ph;
    2002:	62a1      	str	r1, [r4, #40]	; 0x28
		
				AudioStream_F32::transmit(block);
    2004:	2200      	movs	r2, #0
    2006:	4629      	mov	r1, r5
    2008:	4620      	mov	r0, r4
    200a:	f7ff ff6b 	bl	1ee4 <AudioStream_F32::transmit(audio_block_f32_t*, unsigned char)>
				AudioStream_F32::release(block);
    200e:	4628      	mov	r0, r5
    2010:	f7ff ff48 	bl	1ea4 <AudioStream_F32::release(audio_block_f32_t*)>
				return;
    2014:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
		}
		phase_accumulator += phase_increment * block_length;
    2016:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
    2018:	4a03      	ldr	r2, [pc, #12]	; (2028 <AudioSynthWaveformSine_F32::update()+0x98>)
    201a:	6811      	ldr	r1, [r2, #0]
    201c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
    201e:	fb01 2303 	mla	r3, r1, r3, r2
    2022:	62a3      	str	r3, [r4, #40]	; 0x28
    2024:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    2026:	bf00      	nop
    2028:	200013c8 	.word	0x200013c8
    202c:	20000050 	.word	0x20000050
    2030:	46fffe00 	.word	0x46fffe00

00002034 <TwoWire::available()>:
	}
	uint8_t requestFrom(uint8_t addr, uint8_t qty, uint32_t iaddr, uint8_t n, uint8_t stop);
	virtual size_t write(uint8_t data);
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
    2034:	f890 203b 	ldrb.w	r2, [r0, #59]	; 0x3b
    2038:	f890 003a 	ldrb.w	r0, [r0, #58]	; 0x3a
	}
    203c:	1a10      	subs	r0, r2, r0
    203e:	4770      	bx	lr

00002040 <TwoWire::read()>:
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2040:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
    2044:	f890 203b 	ldrb.w	r2, [r0, #59]	; 0x3b
    2048:	4293      	cmp	r3, r2
    204a:	d205      	bcs.n	2058 <TwoWire::read()+0x18>
		return rxBuffer[rxBufferIndex++];
    204c:	1c5a      	adds	r2, r3, #1
    204e:	f880 203a 	strb.w	r2, [r0, #58]	; 0x3a
    2052:	4403      	add	r3, r0
    2054:	7e98      	ldrb	r0, [r3, #26]
    2056:	4770      	bx	lr
	virtual size_t write(const uint8_t *data, size_t quantity);
	virtual int available(void) {
		return rxBufferLength - rxBufferIndex;
	}
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2058:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex++];
	}
    205c:	4770      	bx	lr
    205e:	bf00      	nop

00002060 <TwoWire::peek()>:
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2060:	f890 303a 	ldrb.w	r3, [r0, #58]	; 0x3a
    2064:	f890 203b 	ldrb.w	r2, [r0, #59]	; 0x3b
    2068:	4293      	cmp	r3, r2
    206a:	d202      	bcs.n	2072 <TwoWire::peek()+0x12>
		return rxBuffer[rxBufferIndex];
    206c:	4403      	add	r3, r0
    206e:	7e98      	ldrb	r0, [r3, #26]
    2070:	4770      	bx	lr
	virtual int read(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
		return rxBuffer[rxBufferIndex++];
	}
	virtual int peek(void) {
		if (rxBufferIndex >= rxBufferLength) return -1;
    2072:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
		return rxBuffer[rxBufferIndex];
	}
    2076:	4770      	bx	lr

00002078 <TwoWire::flush()>:
	virtual void flush(void) {
    2078:	4770      	bx	lr
    207a:	bf00      	nop

0000207c <TwoWire::write(unsigned char)>:
	return ret;
}

size_t TwoWire::write(uint8_t data)
{
	if (transmitting || slave_mode) {
    207c:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
    2080:	b17b      	cbz	r3, 20a2 <TwoWire::write(unsigned char)+0x26>
		if (txBufferLength >= BUFFER_LENGTH+1) {
    2082:	f890 305f 	ldrb.w	r3, [r0, #95]	; 0x5f
    2086:	2b20      	cmp	r3, #32
    2088:	d903      	bls.n	2092 <TwoWire::write(unsigned char)+0x16>
    208a:	2301      	movs	r3, #1
    208c:	7103      	strb	r3, [r0, #4]
			setWriteError();
			return 0;
    208e:	2000      	movs	r0, #0
    2090:	4770      	bx	lr
		}
		txBuffer[txBufferLength++] = data;
    2092:	1c5a      	adds	r2, r3, #1
    2094:	f880 205f 	strb.w	r2, [r0, #95]	; 0x5f
    2098:	4418      	add	r0, r3
    209a:	f880 103d 	strb.w	r1, [r0, #61]	; 0x3d
		return 1;
    209e:	2001      	movs	r0, #1
    20a0:	4770      	bx	lr
	}
	return 0;
    20a2:	2000      	movs	r0, #0
}
    20a4:	4770      	bx	lr
    20a6:	bf00      	nop

000020a8 <TwoWire::write(unsigned char const*, unsigned int)>:

size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
    20a8:	b538      	push	{r3, r4, r5, lr}
	if (transmitting || slave_mode) {
    20aa:	f8b0 3060 	ldrh.w	r3, [r0, #96]	; 0x60
    20ae:	b1bb      	cbz	r3, 20e0 <TwoWire::write(unsigned char const*, unsigned int)+0x38>
    20b0:	4605      	mov	r5, r0
    20b2:	4614      	mov	r4, r2
		size_t avail = BUFFER_LENGTH+1 - txBufferLength;
    20b4:	f890 305f 	ldrb.w	r3, [r0, #95]	; 0x5f
    20b8:	f1c3 0221 	rsb	r2, r3, #33	; 0x21
		if (quantity > avail) {
    20bc:	42a2      	cmp	r2, r4
    20be:	d202      	bcs.n	20c6 <TwoWire::write(unsigned char const*, unsigned int)+0x1e>
    20c0:	2001      	movs	r0, #1
    20c2:	7128      	strb	r0, [r5, #4]
			quantity = avail;
    20c4:	4614      	mov	r4, r2
			setWriteError();
		}
		memcpy(txBuffer + txBufferLength, data, quantity);
    20c6:	f105 003d 	add.w	r0, r5, #61	; 0x3d
    20ca:	4622      	mov	r2, r4
    20cc:	4418      	add	r0, r3
    20ce:	f000 fa03 	bl	24d8 <memcpy>
		txBufferLength += quantity;
    20d2:	f895 305f 	ldrb.w	r3, [r5, #95]	; 0x5f
    20d6:	4423      	add	r3, r4
    20d8:	f885 305f 	strb.w	r3, [r5, #95]	; 0x5f
		return quantity;
    20dc:	4620      	mov	r0, r4
    20de:	bd38      	pop	{r3, r4, r5, pc}
	}
	return 0;
    20e0:	2000      	movs	r0, #0
}
    20e2:	bd38      	pop	{r3, r4, r5, pc}

000020e4 <TwoWire::force_clock()>:
	}
	scl_pin_index_ = newindex;
}

bool TwoWire::force_clock()
{
    20e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	bool ret = false;
	uint32_t sda_pin = hardware.sda_pins[sda_pin_index_].pin;
    20e8:	6943      	ldr	r3, [r0, #20]
    20ea:	7e02      	ldrb	r2, [r0, #24]
    20ec:	eb03 1202 	add.w	r2, r3, r2, lsl #4
    20f0:	7a16      	ldrb	r6, [r2, #8]
	uint32_t scl_pin = hardware.scl_pins[scl_pin_index_].pin;
    20f2:	7e42      	ldrb	r2, [r0, #25]
    20f4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    20f8:	f893 4028 	ldrb.w	r4, [r3, #40]	; 0x28
	uint32_t sda_mask = digitalPinToBitMask(sda_pin);
    20fc:	4b48      	ldr	r3, [pc, #288]	; (2220 <TwoWire::force_clock()+0x13c>)
    20fe:	ea4f 1e06 	mov.w	lr, r6, lsl #4
    2102:	eb03 010e 	add.w	r1, r3, lr
    2106:	68cf      	ldr	r7, [r1, #12]
	uint32_t scl_mask = digitalPinToBitMask(scl_pin);
    2108:	0122      	lsls	r2, r4, #4
    210a:	eb03 0802 	add.w	r8, r3, r2
    210e:	f8d8 500c 	ldr.w	r5, [r8, #12]
	// take control of pins with GPIO
	*portConfigRegister(sda_pin) = 5 | 0x10;
    2112:	6849      	ldr	r1, [r1, #4]
    2114:	f04f 0c15 	mov.w	ip, #21
    2118:	f8c1 c000 	str.w	ip, [r1]
	*portSetRegister(sda_pin) = sda_mask;
    211c:	f853 100e 	ldr.w	r1, [r3, lr]
    2120:	f8c1 7084 	str.w	r7, [r1, #132]	; 0x84
	*portModeRegister(sda_pin) |= sda_mask;
    2124:	f853 e00e 	ldr.w	lr, [r3, lr]
    2128:	f8de 1004 	ldr.w	r1, [lr, #4]
    212c:	4339      	orrs	r1, r7
    212e:	f8ce 1004 	str.w	r1, [lr, #4]
	*portConfigRegister(scl_pin) = 5 | 0x10;
    2132:	f8d8 1004 	ldr.w	r1, [r8, #4]
    2136:	f8c1 c000 	str.w	ip, [r1]
	*portSetRegister(scl_pin) = scl_mask;
    213a:	5899      	ldr	r1, [r3, r2]
    213c:	f8c1 5084 	str.w	r5, [r1, #132]	; 0x84
	*portModeRegister(scl_pin) |= scl_mask;
    2140:	589a      	ldr	r2, [r3, r2]
    2142:	6853      	ldr	r3, [r2, #4]
    2144:	432b      	orrs	r3, r5
    2146:	6053      	str	r3, [r2, #4]
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    2148:	4b36      	ldr	r3, [pc, #216]	; (2224 <TwoWire::force_clock()+0x140>)
    214a:	6819      	ldr	r1, [r3, #0]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    214c:	4b36      	ldr	r3, [pc, #216]	; (2228 <TwoWire::force_clock()+0x144>)
    214e:	681b      	ldr	r3, [r3, #0]
    2150:	4a36      	ldr	r2, [pc, #216]	; (222c <TwoWire::force_clock()+0x148>)
    2152:	fba2 2303 	umull	r2, r3, r2, r3
    2156:	0c9b      	lsrs	r3, r3, #18
    2158:	eb03 0383 	add.w	r3, r3, r3, lsl #2
    215c:	005a      	lsls	r2, r3, #1
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    215e:	4b31      	ldr	r3, [pc, #196]	; (2224 <TwoWire::force_clock()+0x140>)
    2160:	681b      	ldr	r3, [r3, #0]
    2162:	1a5b      	subs	r3, r3, r1
    2164:	429a      	cmp	r2, r3
    2166:	d8fa      	bhi.n	215e <TwoWire::force_clock()+0x7a>
    2168:	2100      	movs	r1, #0
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    216a:	2908      	cmp	r1, #8
    216c:	dc3e      	bgt.n	21ec <TwoWire::force_clock()+0x108>
		if ((*portInputRegister(sda_pin) & sda_mask)
    216e:	0133      	lsls	r3, r6, #4
    2170:	4a2b      	ldr	r2, [pc, #172]	; (2220 <TwoWire::force_clock()+0x13c>)
    2172:	58d3      	ldr	r3, [r2, r3]
    2174:	689b      	ldr	r3, [r3, #8]
		  && (*portInputRegister(scl_pin) & scl_mask)) {
    2176:	421f      	tst	r7, r3
    2178:	d006      	beq.n	2188 <TwoWire::force_clock()+0xa4>
    217a:	0123      	lsls	r3, r4, #4
    217c:	58d3      	ldr	r3, [r2, r3]
    217e:	689b      	ldr	r3, [r3, #8]
    2180:	421d      	tst	r5, r3
    2182:	d103      	bne.n	218c <TwoWire::force_clock()+0xa8>
    2184:	2300      	movs	r3, #0
    2186:	e002      	b.n	218e <TwoWire::force_clock()+0xaa>
    2188:	2300      	movs	r3, #0
    218a:	e000      	b.n	218e <TwoWire::force_clock()+0xaa>
    218c:	2301      	movs	r3, #1
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
    218e:	bb7b      	cbnz	r3, 21f0 <TwoWire::force_clock()+0x10c>
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
			break;
		}
		*portClearRegister(scl_pin) = scl_mask;
    2190:	0123      	lsls	r3, r4, #4
    2192:	4a23      	ldr	r2, [pc, #140]	; (2220 <TwoWire::force_clock()+0x13c>)
    2194:	58d3      	ldr	r3, [r2, r3]
    2196:	f8c3 5088 	str.w	r5, [r3, #136]	; 0x88
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    219a:	4b22      	ldr	r3, [pc, #136]	; (2224 <TwoWire::force_clock()+0x140>)
    219c:	f8d3 e000 	ldr.w	lr, [r3]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    21a0:	4b21      	ldr	r3, [pc, #132]	; (2228 <TwoWire::force_clock()+0x144>)
    21a2:	681b      	ldr	r3, [r3, #0]
    21a4:	4a21      	ldr	r2, [pc, #132]	; (222c <TwoWire::force_clock()+0x148>)
    21a6:	fba2 3203 	umull	r3, r2, r2, r3
    21aa:	0c92      	lsrs	r2, r2, #18
    21ac:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    21b0:	4b1c      	ldr	r3, [pc, #112]	; (2224 <TwoWire::force_clock()+0x140>)
    21b2:	681b      	ldr	r3, [r3, #0]
    21b4:	ebce 0303 	rsb	r3, lr, r3
    21b8:	429a      	cmp	r2, r3
    21ba:	d8f9      	bhi.n	21b0 <TwoWire::force_clock()+0xcc>
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
    21bc:	0123      	lsls	r3, r4, #4
    21be:	4a18      	ldr	r2, [pc, #96]	; (2220 <TwoWire::force_clock()+0x13c>)
    21c0:	58d3      	ldr	r3, [r2, r3]
    21c2:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
uint32_t micros(void);

static inline void delayMicroseconds(uint32_t) __attribute__((always_inline, unused));
static inline void delayMicroseconds(uint32_t usec)
{
	uint32_t begin = ARM_DWT_CYCCNT;
    21c6:	4b17      	ldr	r3, [pc, #92]	; (2224 <TwoWire::force_clock()+0x140>)
    21c8:	f8d3 e000 	ldr.w	lr, [r3]
	uint32_t cycles = F_CPU_ACTUAL / 1000000 * usec;
    21cc:	4b16      	ldr	r3, [pc, #88]	; (2228 <TwoWire::force_clock()+0x144>)
    21ce:	681b      	ldr	r3, [r3, #0]
    21d0:	4a16      	ldr	r2, [pc, #88]	; (222c <TwoWire::force_clock()+0x148>)
    21d2:	fba2 3203 	umull	r3, r2, r2, r3
    21d6:	0c92      	lsrs	r2, r2, #18
    21d8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
	// TODO: check if cycles is large, do a wait with yield calls until it's smaller
	while (ARM_DWT_CYCCNT - begin < cycles) ; // wait
    21dc:	4b11      	ldr	r3, [pc, #68]	; (2224 <TwoWire::force_clock()+0x140>)
    21de:	681b      	ldr	r3, [r3, #0]
    21e0:	ebce 0303 	rsb	r3, lr, r3
    21e4:	429a      	cmp	r2, r3
    21e6:	d8f9      	bhi.n	21dc <TwoWire::force_clock()+0xf8>
	*portModeRegister(sda_pin) |= sda_mask;
	*portConfigRegister(scl_pin) = 5 | 0x10;
	*portSetRegister(scl_pin) = scl_mask;
	*portModeRegister(scl_pin) |= scl_mask;
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
    21e8:	3101      	adds	r1, #1
    21ea:	e7be      	b.n	216a <TwoWire::force_clock()+0x86>
	scl_pin_index_ = newindex;
}

bool TwoWire::force_clock()
{
	bool ret = false;
    21ec:	2100      	movs	r1, #0
    21ee:	e000      	b.n	21f2 <TwoWire::force_clock()+0x10e>
	delayMicroseconds(10);
	for (int i=0; i < 9; i++) {
		if ((*portInputRegister(sda_pin) & sda_mask)
		  && (*portInputRegister(scl_pin) & scl_mask)) {
			// success, both pins are high
			ret = true;
    21f0:	2101      	movs	r1, #1
		delayMicroseconds(5);
		*portSetRegister(scl_pin) = scl_mask;
		delayMicroseconds(5);
	}
	// return control of pins to I2C
	*(portConfigRegister(sda_pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    21f2:	4b0b      	ldr	r3, [pc, #44]	; (2220 <TwoWire::force_clock()+0x13c>)
    21f4:	eb03 1606 	add.w	r6, r3, r6, lsl #4
    21f8:	6875      	ldr	r5, [r6, #4]
    21fa:	6942      	ldr	r2, [r0, #20]
    21fc:	7e06      	ldrb	r6, [r0, #24]
    21fe:	eb02 1206 	add.w	r2, r2, r6, lsl #4
    2202:	68d2      	ldr	r2, [r2, #12]
    2204:	602a      	str	r2, [r5, #0]
	*(portConfigRegister(scl_pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    2206:	eb03 1304 	add.w	r3, r3, r4, lsl #4
    220a:	685a      	ldr	r2, [r3, #4]
    220c:	6943      	ldr	r3, [r0, #20]
    220e:	7e40      	ldrb	r0, [r0, #25]
    2210:	eb03 1300 	add.w	r3, r3, r0, lsl #4
    2214:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    2216:	6013      	str	r3, [r2, #0]
	return ret;
}
    2218:	4608      	mov	r0, r1
    221a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    221e:	bf00      	nop
    2220:	20000324 	.word	0x20000324
    2224:	e0001004 	.word	0xe0001004
    2228:	20000710 	.word	0x20000710
    222c:	431bde83 	.word	0x431bde83

00002230 <TwoWire::wait_idle()>:
//   01   EPF = End Packet Flag
//      2 RDF = Receive Data Flag
//      1 TDF = Transmit Data Flag

bool TwoWire::wait_idle()
{
    2230:	b510      	push	{r4, lr}
    2232:	4604      	mov	r4, r0
extern volatile uint32_t systick_millis_count;

static inline uint32_t millis(void) __attribute__((always_inline, unused));
static inline uint32_t millis(void)
{
	return systick_millis_count;
    2234:	4b0d      	ldr	r3, [pc, #52]	; (226c <TwoWire::wait_idle()+0x3c>)
    2236:	681a      	ldr	r2, [r3, #0]
	elapsedMillis timeout = 0;
	while (1) {
		uint32_t status = port->MSR; // pg 2899 & 2892
    2238:	6923      	ldr	r3, [r4, #16]
    223a:	695b      	ldr	r3, [r3, #20]
		if (!(status & LPI2C_MSR_BBF)) break; // bus is available
    223c:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
    2240:	d00c      	beq.n	225c <TwoWire::wait_idle()+0x2c>
		if (status & LPI2C_MSR_MBF) break; // we already have bus control
    2242:	f013 7f80 	tst.w	r3, #16777216	; 0x1000000
    2246:	d109      	bne.n	225c <TwoWire::wait_idle()+0x2c>
    2248:	4b08      	ldr	r3, [pc, #32]	; (226c <TwoWire::wait_idle()+0x3c>)
    224a:	681b      	ldr	r3, [r3, #0]
	unsigned long ms;
public:
	elapsedMillis(void) { ms = millis(); }
	elapsedMillis(unsigned long val) { ms = millis() - val; }
	elapsedMillis(const elapsedMillis &orig) { ms = orig.ms; }
	operator unsigned long () const { return millis() - ms; }
    224c:	1a9b      	subs	r3, r3, r2
		if (timeout > 16) {
    224e:	2b10      	cmp	r3, #16
    2250:	d9f2      	bls.n	2238 <TwoWire::wait_idle()+0x8>
			//Serial.printf("timeout waiting for idle, MSR = %x\n", status);
			if (force_clock()) break;
    2252:	4620      	mov	r0, r4
    2254:	f7ff ff46 	bl	20e4 <TwoWire::force_clock()>
    2258:	4603      	mov	r3, r0
    225a:	b120      	cbz	r0, 2266 <TwoWire::wait_idle()+0x36>
			//Serial.printf("unable to get control of I2C bus\n");
			return false;
		}
	}
	port->MSR = 0x00007F00; // clear all prior flags
    225c:	6923      	ldr	r3, [r4, #16]
    225e:	f44f 42fe 	mov.w	r2, #32512	; 0x7f00
    2262:	615a      	str	r2, [r3, #20]
	return true;
    2264:	2301      	movs	r3, #1
}
    2266:	4618      	mov	r0, r3
    2268:	bd10      	pop	{r4, pc}
    226a:	bf00      	nop
    226c:	200013d4 	.word	0x200013d4

00002270 <TwoWire::endTransmission(unsigned char)>:


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
    2270:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t tx_len = txBufferLength;
    2274:	f890 605f 	ldrb.w	r6, [r0, #95]	; 0x5f
	if (!tx_len) return 4; // no address for transmit
    2278:	2e00      	cmp	r6, #0
    227a:	d06e      	beq.n	235a <TwoWire::endTransmission(unsigned char)+0xea>
    227c:	460f      	mov	r7, r1
    227e:	4605      	mov	r5, r0
	if (!wait_idle()) return 4;
    2280:	f7ff ffd6 	bl	2230 <TwoWire::wait_idle()>
    2284:	4680      	mov	r8, r0
    2286:	2800      	cmp	r0, #0
    2288:	d06a      	beq.n	2360 <TwoWire::endTransmission(unsigned char)+0xf0>
    228a:	4b3a      	ldr	r3, [pc, #232]	; (2374 <TwoWire::endTransmission(unsigned char)+0x104>)
    228c:	f8d3 9000 	ldr.w	r9, [r3]
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
    2290:	2400      	movs	r4, #0
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
    2292:	42b4      	cmp	r4, r6
    2294:	d820      	bhi.n	22d8 <TwoWire::endTransmission(unsigned char)+0x68>
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
    2296:	692b      	ldr	r3, [r5, #16]
    2298:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
    229a:	f003 0307 	and.w	r3, r3, #7
			while (fifo_used < 4) {
    229e:	2b03      	cmp	r3, #3
    22a0:	d81a      	bhi.n	22d8 <TwoWire::endTransmission(unsigned char)+0x68>
				if (tx_index == 0) {
    22a2:	b93c      	cbnz	r4, 22b4 <TwoWire::endTransmission(unsigned char)+0x44>
					port->MTDR = LPI2C_MTDR_CMD_START | txBuffer[0];
    22a4:	6929      	ldr	r1, [r5, #16]
    22a6:	f895 203d 	ldrb.w	r2, [r5, #61]	; 0x3d
    22aa:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
    22ae:	660a      	str	r2, [r1, #96]	; 0x60
					tx_index = 1;
    22b0:	2401      	movs	r4, #1
    22b2:	e00f      	b.n	22d4 <TwoWire::endTransmission(unsigned char)+0x64>
				} else if (tx_index < tx_len) {
    22b4:	42b4      	cmp	r4, r6
    22b6:	d206      	bcs.n	22c6 <TwoWire::endTransmission(unsigned char)+0x56>
					port->MTDR = LPI2C_MTDR_CMD_TRANSMIT | txBuffer[tx_index++];
    22b8:	692a      	ldr	r2, [r5, #16]
    22ba:	1929      	adds	r1, r5, r4
    22bc:	f891 103d 	ldrb.w	r1, [r1, #61]	; 0x3d
    22c0:	6611      	str	r1, [r2, #96]	; 0x60
    22c2:	3401      	adds	r4, #1
    22c4:	e006      	b.n	22d4 <TwoWire::endTransmission(unsigned char)+0x64>
				} else {
					if (sendStop) port->MTDR = LPI2C_MTDR_CMD_STOP;
    22c6:	b11f      	cbz	r7, 22d0 <TwoWire::endTransmission(unsigned char)+0x60>
    22c8:	692b      	ldr	r3, [r5, #16]
    22ca:	f44f 7200 	mov.w	r2, #512	; 0x200
    22ce:	661a      	str	r2, [r3, #96]	; 0x60
					tx_index++;
    22d0:	3401      	adds	r4, #1
					break;
    22d2:	e001      	b.n	22d8 <TwoWire::endTransmission(unsigned char)+0x68>
				}
				fifo_used++;
    22d4:	3301      	adds	r3, #1
	elapsedMillis timeout = 0;
	while (1) {
		// transmit stuff, if we haven't already
		if (tx_index <= tx_len) {
			uint32_t fifo_used = port->MFSR & 0x07; // pg 2914
			while (fifo_used < 4) {
    22d6:	e7e2      	b.n	229e <TwoWire::endTransmission(unsigned char)+0x2e>
				}
				fifo_used++;
			}
		}
		// monitor status
		uint32_t status = port->MSR; // pg 2884 & 2891
    22d8:	692a      	ldr	r2, [r5, #16]
    22da:	6953      	ldr	r3, [r2, #20]
		if (status & LPI2C_MSR_ALF) {
    22dc:	f413 6f00 	tst.w	r3, #2048	; 0x800
    22e0:	d006      	beq.n	22f0 <TwoWire::endTransmission(unsigned char)+0x80>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    22e2:	6913      	ldr	r3, [r2, #16]
    22e4:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    22e8:	6113      	str	r3, [r2, #16]
			return 4; // we lost bus arbitration to another master
    22ea:	2004      	movs	r0, #4
    22ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
		if (status & LPI2C_MSR_NDF) {
    22f0:	f413 6f80 	tst.w	r3, #1024	; 0x400
    22f4:	d00a      	beq.n	230c <TwoWire::endTransmission(unsigned char)+0x9c>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    22f6:	6913      	ldr	r3, [r2, #16]
    22f8:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    22fc:	6113      	str	r3, [r2, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP;
    22fe:	692b      	ldr	r3, [r5, #16]
    2300:	f44f 7200 	mov.w	r2, #512	; 0x200
    2304:	661a      	str	r2, [r3, #96]	; 0x60
			return 2; // NACK (assume address, TODO: how to tell address from data)
    2306:	2002      	movs	r0, #2
    2308:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
		if ((status & LPI2C_MSR_PLTF) || timeout > 50) {
    230c:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    2310:	d107      	bne.n	2322 <TwoWire::endTransmission(unsigned char)+0xb2>
    2312:	4918      	ldr	r1, [pc, #96]	; (2374 <TwoWire::endTransmission(unsigned char)+0x104>)
    2314:	6809      	ldr	r1, [r1, #0]
    2316:	ebc9 0101 	rsb	r1, r9, r1
    231a:	2932      	cmp	r1, #50	; 0x32
    231c:	d803      	bhi.n	2326 <TwoWire::endTransmission(unsigned char)+0xb6>
    231e:	2100      	movs	r1, #0
    2320:	e002      	b.n	2328 <TwoWire::endTransmission(unsigned char)+0xb8>
    2322:	4641      	mov	r1, r8
    2324:	e000      	b.n	2328 <TwoWire::endTransmission(unsigned char)+0xb8>
    2326:	4641      	mov	r1, r8
    2328:	b151      	cbz	r1, 2340 <TwoWire::endTransmission(unsigned char)+0xd0>
			port->MCR |= LPI2C_MCR_RTF | LPI2C_MCR_RRF; // clear FIFOs
    232a:	6913      	ldr	r3, [r2, #16]
    232c:	f443 7340 	orr.w	r3, r3, #768	; 0x300
    2330:	6113      	str	r3, [r2, #16]
			port->MTDR = LPI2C_MTDR_CMD_STOP; // try to send a stop
    2332:	692b      	ldr	r3, [r5, #16]
    2334:	f44f 7200 	mov.w	r2, #512	; 0x200
    2338:	661a      	str	r2, [r3, #96]	; 0x60
			return 4; // clock stretched too long or generic timeout
    233a:	2004      	movs	r0, #4
    233c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
    2340:	42b4      	cmp	r4, r6
    2342:	d907      	bls.n	2354 <TwoWire::endTransmission(unsigned char)+0xe4>
			uint32_t tx_fifo = port->MFSR & 0x07;
    2344:	6dd2      	ldr	r2, [r2, #92]	; 0x5c
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
    2346:	f012 0f07 	tst.w	r2, #7
    234a:	d103      	bne.n	2354 <TwoWire::endTransmission(unsigned char)+0xe4>
    234c:	f413 7f00 	tst.w	r3, #512	; 0x200
    2350:	d109      	bne.n	2366 <TwoWire::endTransmission(unsigned char)+0xf6>
    2352:	b15f      	cbz	r7, 236c <TwoWire::endTransmission(unsigned char)+0xfc>
				return 0;
			}
		}
		yield();
    2354:	f001 fdca 	bl	3eec <yield>
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
	if (!wait_idle()) return 4;
	uint32_t tx_index = 0; // 0=start, 1=addr, 2-(N-1)=data, N=stop
	elapsedMillis timeout = 0;
	while (1) {
    2358:	e79b      	b.n	2292 <TwoWire::endTransmission(unsigned char)+0x22>


uint8_t TwoWire::endTransmission(uint8_t sendStop)
{
	uint32_t tx_len = txBufferLength;
	if (!tx_len) return 4; // no address for transmit
    235a:	2004      	movs	r0, #4
    235c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if (!wait_idle()) return 4;
    2360:	2004      	movs	r0, #4
    2362:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		}
		// are we done yet?
		if (tx_index > tx_len) {
			uint32_t tx_fifo = port->MFSR & 0x07;
			if (tx_fifo == 0 && ((status & LPI2C_MSR_SDF) || !sendStop)) {
				return 0;
    2366:	2000      	movs	r0, #0
    2368:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    236c:	2000      	movs	r0, #0
			}
		}
		yield();
	}
}
    236e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    2372:	bf00      	nop
    2374:	200013d4 	.word	0x200013d4

00002378 <TwoWire::setClock(unsigned long)>:
#define CLOCK_STRETCH_TIMEOUT 15000


void TwoWire::setClock(uint32_t frequency)
{
	port->MCR = 0;
    2378:	6903      	ldr	r3, [r0, #16]
    237a:	2200      	movs	r2, #0
    237c:	611a      	str	r2, [r3, #16]
	if (frequency < 400000) {
    237e:	4b1d      	ldr	r3, [pc, #116]	; (23f4 <TwoWire::setClock(unsigned long)+0x7c>)
    2380:	4299      	cmp	r1, r3
    2382:	d80d      	bhi.n	23a0 <TwoWire::setClock(unsigned long)+0x28>
		// 100 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(55) | LPI2C_MCCR0_CLKLO(59) |
    2384:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCCR0_DATAVD(25) | LPI2C_MCCR0_SETHOLD(40);
    2386:	4a1c      	ldr	r2, [pc, #112]	; (23f8 <TwoWire::setClock(unsigned long)+0x80>)
    2388:	649a      	str	r2, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(1);
    238a:	6903      	ldr	r3, [r0, #16]
    238c:	2201      	movs	r2, #1
    238e:	625a      	str	r2, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(5) | LPI2C_MCFGR2_FILTSCL(5) |
    2390:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCFGR2_BUSIDLE(3000); // idle timeout 250 us
    2392:	4a1a      	ldr	r2, [pc, #104]	; (23fc <TwoWire::setClock(unsigned long)+0x84>)
    2394:	629a      	str	r2, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 12 / 256 + 1);
    2396:	6903      	ldr	r3, [r0, #16]
    2398:	f44f 3230 	mov.w	r2, #180224	; 0x2c000
    239c:	62da      	str	r2, [r3, #44]	; 0x2c
    239e:	e01b      	b.n	23d8 <TwoWire::setClock(unsigned long)+0x60>
	} else if (frequency < 1000000) {
    23a0:	4b17      	ldr	r3, [pc, #92]	; (2400 <TwoWire::setClock(unsigned long)+0x88>)
    23a2:	4299      	cmp	r1, r3
    23a4:	d80c      	bhi.n	23c0 <TwoWire::setClock(unsigned long)+0x48>
		// 400 kHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(26) | LPI2C_MCCR0_CLKLO(28) |
    23a6:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCCR0_DATAVD(12) | LPI2C_MCCR0_SETHOLD(18);
    23a8:	4a16      	ldr	r2, [pc, #88]	; (2404 <TwoWire::setClock(unsigned long)+0x8c>)
    23aa:	649a      	str	r2, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
    23ac:	6903      	ldr	r3, [r0, #16]
    23ae:	2200      	movs	r2, #0
    23b0:	625a      	str	r2, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(2) | LPI2C_MCFGR2_FILTSCL(2) |
    23b2:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCFGR2_BUSIDLE(3600); // idle timeout 150 us
    23b4:	4a14      	ldr	r2, [pc, #80]	; (2408 <TwoWire::setClock(unsigned long)+0x90>)
    23b6:	629a      	str	r2, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
    23b8:	6903      	ldr	r3, [r0, #16]
    23ba:	4a14      	ldr	r2, [pc, #80]	; (240c <TwoWire::setClock(unsigned long)+0x94>)
    23bc:	62da      	str	r2, [r3, #44]	; 0x2c
    23be:	e00b      	b.n	23d8 <TwoWire::setClock(unsigned long)+0x60>
	} else {
		// 1 MHz
		port->MCCR0 = LPI2C_MCCR0_CLKHI(9) | LPI2C_MCCR0_CLKLO(10) |
    23c0:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCCR0_DATAVD(4) | LPI2C_MCCR0_SETHOLD(7);
    23c2:	4a13      	ldr	r2, [pc, #76]	; (2410 <TwoWire::setClock(unsigned long)+0x98>)
    23c4:	649a      	str	r2, [r3, #72]	; 0x48
		port->MCFGR1 = LPI2C_MCFGR1_PRESCALE(0);
    23c6:	6903      	ldr	r3, [r0, #16]
    23c8:	2200      	movs	r2, #0
    23ca:	625a      	str	r2, [r3, #36]	; 0x24
		port->MCFGR2 = LPI2C_MCFGR2_FILTSDA(1) | LPI2C_MCFGR2_FILTSCL(1) |
    23cc:	6903      	ldr	r3, [r0, #16]
			LPI2C_MCFGR2_BUSIDLE(2400); // idle timeout 100 us
    23ce:	4a11      	ldr	r2, [pc, #68]	; (2414 <TwoWire::setClock(unsigned long)+0x9c>)
    23d0:	629a      	str	r2, [r3, #40]	; 0x28
		port->MCFGR3 = LPI2C_MCFGR3_PINLOW(CLOCK_STRETCH_TIMEOUT * 24 / 256 + 1);
    23d2:	6903      	ldr	r3, [r0, #16]
    23d4:	4a0d      	ldr	r2, [pc, #52]	; (240c <TwoWire::setClock(unsigned long)+0x94>)
    23d6:	62da      	str	r2, [r3, #44]	; 0x2c
	}
	port->MCCR1 = port->MCCR0;
    23d8:	6903      	ldr	r3, [r0, #16]
    23da:	6c9a      	ldr	r2, [r3, #72]	; 0x48
    23dc:	651a      	str	r2, [r3, #80]	; 0x50
	port->MCFGR0 = 0;
    23de:	6903      	ldr	r3, [r0, #16]
    23e0:	2200      	movs	r2, #0
    23e2:	621a      	str	r2, [r3, #32]
	port->MFCR = LPI2C_MFCR_RXWATER(1) | LPI2C_MFCR_TXWATER(1);
    23e4:	6903      	ldr	r3, [r0, #16]
    23e6:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    23ea:	659a      	str	r2, [r3, #88]	; 0x58
	port->MCR = LPI2C_MCR_MEN;
    23ec:	6903      	ldr	r3, [r0, #16]
    23ee:	2201      	movs	r2, #1
    23f0:	611a      	str	r2, [r3, #16]
    23f2:	4770      	bx	lr
    23f4:	00061a7f 	.word	0x00061a7f
    23f8:	1928373b 	.word	0x1928373b
    23fc:	05050bb8 	.word	0x05050bb8
    2400:	000f423f 	.word	0x000f423f
    2404:	0c121a1c 	.word	0x0c121a1c
    2408:	02020e10 	.word	0x02020e10
    240c:	00057f00 	.word	0x00057f00
    2410:	0407090a 	.word	0x0407090a
    2414:	01010960 	.word	0x01010960

00002418 <TwoWire::begin()>:
//#include "debug/printf.h"

#define PINCONFIG (IOMUXC_PAD_ODE | IOMUXC_PAD_SRE | IOMUXC_PAD_DSE(4) | IOMUXC_PAD_SPEED(1) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3))

void TwoWire::begin(void)
{
    2418:	b538      	push	{r3, r4, r5, lr}
    241a:	4604      	mov	r4, r0
	// use 24 MHz clock
	CCM_CSCDR2 = (CCM_CSCDR2 & ~CCM_CSCDR2_LPI2C_CLK_PODF(63)) | CCM_CSCDR2_LPI2C_CLK_SEL;
    241c:	4a2b      	ldr	r2, [pc, #172]	; (24cc <TwoWire::begin()+0xb4>)
    241e:	6b93      	ldr	r3, [r2, #56]	; 0x38
    2420:	f423 037c 	bic.w	r3, r3, #16515072	; 0xfc0000
    2424:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
    2428:	6393      	str	r3, [r2, #56]	; 0x38
	hardware.clock_gate_register |= hardware.clock_gate_mask;
    242a:	6941      	ldr	r1, [r0, #20]
    242c:	680a      	ldr	r2, [r1, #0]
    242e:	6815      	ldr	r5, [r2, #0]
    2430:	684b      	ldr	r3, [r1, #4]
    2432:	432b      	orrs	r3, r5
    2434:	6013      	str	r3, [r2, #0]
	port->MCR = LPI2C_MCR_RST;
    2436:	6903      	ldr	r3, [r0, #16]
    2438:	2202      	movs	r2, #2
    243a:	611a      	str	r2, [r3, #16]
	setClock(100000);
    243c:	4924      	ldr	r1, [pc, #144]	; (24d0 <TwoWire::begin()+0xb8>)
    243e:	f7ff ff9b 	bl	2378 <TwoWire::setClock(unsigned long)>

	// Setup SDA register
	*(portControlRegister(hardware.sda_pins[sda_pin_index_].pin)) = PINCONFIG;
    2442:	6963      	ldr	r3, [r4, #20]
    2444:	7e22      	ldrb	r2, [r4, #24]
    2446:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    244a:	7a1b      	ldrb	r3, [r3, #8]
    244c:	4a21      	ldr	r2, [pc, #132]	; (24d4 <TwoWire::begin()+0xbc>)
    244e:	eb02 1303 	add.w	r3, r2, r3, lsl #4
    2452:	689b      	ldr	r3, [r3, #8]
    2454:	f64f 0161 	movw	r1, #63585	; 0xf861
    2458:	6019      	str	r1, [r3, #0]
	*(portConfigRegister(hardware.sda_pins[sda_pin_index_].pin)) = hardware.sda_pins[sda_pin_index_].mux_val;
    245a:	6963      	ldr	r3, [r4, #20]
    245c:	7e21      	ldrb	r1, [r4, #24]
    245e:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    2462:	7a19      	ldrb	r1, [r3, #8]
    2464:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    2468:	6852      	ldr	r2, [r2, #4]
    246a:	68db      	ldr	r3, [r3, #12]
    246c:	6013      	str	r3, [r2, #0]
	if (hardware.sda_pins[sda_pin_index_].select_input_register) {
    246e:	6963      	ldr	r3, [r4, #20]
    2470:	7e22      	ldrb	r2, [r4, #24]
    2472:	1c51      	adds	r1, r2, #1
    2474:	0109      	lsls	r1, r1, #4
    2476:	5859      	ldr	r1, [r3, r1]
    2478:	b121      	cbz	r1, 2484 <TwoWire::begin()+0x6c>
		*(hardware.sda_pins[sda_pin_index_].select_input_register) =  hardware.sda_pins[sda_pin_index_].select_val;
    247a:	3201      	adds	r2, #1
    247c:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    2480:	685b      	ldr	r3, [r3, #4]
    2482:	600b      	str	r3, [r1, #0]
	}

	// setup SCL register
	*(portControlRegister(hardware.scl_pins[scl_pin_index_].pin)) = PINCONFIG;
    2484:	6963      	ldr	r3, [r4, #20]
    2486:	7e62      	ldrb	r2, [r4, #25]
    2488:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    248c:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
    2490:	4a10      	ldr	r2, [pc, #64]	; (24d4 <TwoWire::begin()+0xbc>)
    2492:	eb02 1303 	add.w	r3, r2, r3, lsl #4
    2496:	689b      	ldr	r3, [r3, #8]
    2498:	f64f 0161 	movw	r1, #63585	; 0xf861
    249c:	6019      	str	r1, [r3, #0]
	*(portConfigRegister(hardware.scl_pins[scl_pin_index_].pin)) = hardware.scl_pins[scl_pin_index_].mux_val;
    249e:	6963      	ldr	r3, [r4, #20]
    24a0:	7e61      	ldrb	r1, [r4, #25]
    24a2:	eb03 1301 	add.w	r3, r3, r1, lsl #4
    24a6:	f893 1028 	ldrb.w	r1, [r3, #40]	; 0x28
    24aa:	eb02 1201 	add.w	r2, r2, r1, lsl #4
    24ae:	6852      	ldr	r2, [r2, #4]
    24b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
    24b2:	6013      	str	r3, [r2, #0]
	if (hardware.scl_pins[scl_pin_index_].select_input_register) {
    24b4:	6963      	ldr	r3, [r4, #20]
    24b6:	7e62      	ldrb	r2, [r4, #25]
    24b8:	1cd1      	adds	r1, r2, #3
    24ba:	0109      	lsls	r1, r1, #4
    24bc:	5859      	ldr	r1, [r3, r1]
    24be:	b121      	cbz	r1, 24ca <TwoWire::begin()+0xb2>
		*(hardware.scl_pins[scl_pin_index_].select_input_register) =  hardware.scl_pins[scl_pin_index_].select_val;
    24c0:	3203      	adds	r2, #3
    24c2:	eb03 1302 	add.w	r3, r3, r2, lsl #4
    24c6:	685b      	ldr	r3, [r3, #4]
    24c8:	600b      	str	r3, [r1, #0]
    24ca:	bd38      	pop	{r3, r4, r5, pc}
    24cc:	400fc000 	.word	0x400fc000
    24d0:	000186a0 	.word	0x000186a0
    24d4:	20000324 	.word	0x20000324

000024d8 <memcpy>:
	@ r1: src
	@ r2: len
#ifdef __ARM_FEATURE_UNALIGNED
	/* In case of UNALIGNED access supported, ip is not used in
	   function body.  */
	mov	ip, r0
    24d8:	4684      	mov	ip, r0
#else
	push	{r0}
#endif
	orr	r3, r1, r0
    24da:	ea41 0300 	orr.w	r3, r1, r0
	ands	r3, r3, #3
    24de:	f013 0303 	ands.w	r3, r3, #3
	bne	.Lmisaligned_copy
    24e2:	d16d      	bne.n	25c0 <memcpy+0xe8>

.Lbig_block:
	subs	r2, __OPT_BIG_BLOCK_SIZE
    24e4:	3a40      	subs	r2, #64	; 0x40
	blo	.Lmid_block
    24e6:	d341      	bcc.n	256c <memcpy+0x94>
.Lbig_block_loop:
	BEGIN_UNROLL_BIG_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    24e8:	f851 3b04 	ldr.w	r3, [r1], #4
    24ec:	f840 3b04 	str.w	r3, [r0], #4
    24f0:	f851 3b04 	ldr.w	r3, [r1], #4
    24f4:	f840 3b04 	str.w	r3, [r0], #4
    24f8:	f851 3b04 	ldr.w	r3, [r1], #4
    24fc:	f840 3b04 	str.w	r3, [r0], #4
    2500:	f851 3b04 	ldr.w	r3, [r1], #4
    2504:	f840 3b04 	str.w	r3, [r0], #4
    2508:	f851 3b04 	ldr.w	r3, [r1], #4
    250c:	f840 3b04 	str.w	r3, [r0], #4
    2510:	f851 3b04 	ldr.w	r3, [r1], #4
    2514:	f840 3b04 	str.w	r3, [r0], #4
    2518:	f851 3b04 	ldr.w	r3, [r1], #4
    251c:	f840 3b04 	str.w	r3, [r0], #4
    2520:	f851 3b04 	ldr.w	r3, [r1], #4
    2524:	f840 3b04 	str.w	r3, [r0], #4
    2528:	f851 3b04 	ldr.w	r3, [r1], #4
    252c:	f840 3b04 	str.w	r3, [r0], #4
    2530:	f851 3b04 	ldr.w	r3, [r1], #4
    2534:	f840 3b04 	str.w	r3, [r0], #4
    2538:	f851 3b04 	ldr.w	r3, [r1], #4
    253c:	f840 3b04 	str.w	r3, [r0], #4
    2540:	f851 3b04 	ldr.w	r3, [r1], #4
    2544:	f840 3b04 	str.w	r3, [r0], #4
    2548:	f851 3b04 	ldr.w	r3, [r1], #4
    254c:	f840 3b04 	str.w	r3, [r0], #4
    2550:	f851 3b04 	ldr.w	r3, [r1], #4
    2554:	f840 3b04 	str.w	r3, [r0], #4
    2558:	f851 3b04 	ldr.w	r3, [r1], #4
    255c:	f840 3b04 	str.w	r3, [r0], #4
    2560:	f851 3b04 	ldr.w	r3, [r1], #4
    2564:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds	r0, __OPT_BIG_BLOCK_SIZE
	adds	r1, __OPT_BIG_BLOCK_SIZE
#endif
	subs	r2, __OPT_BIG_BLOCK_SIZE
    2568:	3a40      	subs	r2, #64	; 0x40
	bhs .Lbig_block_loop
    256a:	d2bd      	bcs.n	24e8 <memcpy+0x10>

.Lmid_block:
	adds	r2, __OPT_BIG_BLOCK_SIZE - __OPT_MID_BLOCK_SIZE
    256c:	3230      	adds	r2, #48	; 0x30
	blo	.Lcopy_word_by_word
    256e:	d311      	bcc.n	2594 <memcpy+0xbc>
.Lmid_block_loop:
	BEGIN_UNROLL_MID_BLOCK
#ifdef __ARM_ARCH_7EM__
	ldr	r3, [r1], #4
	str	r3, [r0], #4
	END_UNROLL
    2570:	f851 3b04 	ldr.w	r3, [r1], #4
    2574:	f840 3b04 	str.w	r3, [r0], #4
    2578:	f851 3b04 	ldr.w	r3, [r1], #4
    257c:	f840 3b04 	str.w	r3, [r0], #4
    2580:	f851 3b04 	ldr.w	r3, [r1], #4
    2584:	f840 3b04 	str.w	r3, [r0], #4
    2588:	f851 3b04 	ldr.w	r3, [r1], #4
    258c:	f840 3b04 	str.w	r3, [r0], #4
	str	r3, [r0, \offset]
	END_UNROLL
	adds    r0, __OPT_MID_BLOCK_SIZE
	adds    r1, __OPT_MID_BLOCK_SIZE
#endif
	subs	r2, __OPT_MID_BLOCK_SIZE
    2590:	3a10      	subs	r2, #16
	bhs	.Lmid_block_loop
    2592:	d2ed      	bcs.n	2570 <memcpy+0x98>

.Lcopy_word_by_word:
	adds	r2, __OPT_MID_BLOCK_SIZE - 4
    2594:	320c      	adds	r2, #12
	blo	.Lcopy_less_than_4
    2596:	d305      	bcc.n	25a4 <memcpy+0xcc>

	/* Kernel loop for small block copy */
	.align 2
.Lcopy_word_by_word_loop:
	ldr	r3, [r1], #4
    2598:	f851 3b04 	ldr.w	r3, [r1], #4
	str	r3, [r0], #4
    259c:	f840 3b04 	str.w	r3, [r0], #4
	subs	r2, #4
    25a0:	3a04      	subs	r2, #4
	bhs	.Lcopy_word_by_word_loop
    25a2:	d2f9      	bcs.n	2598 <memcpy+0xc0>

.Lcopy_less_than_4:
	adds	r2, #4
    25a4:	3204      	adds	r2, #4
	beq	.Ldone
    25a6:	d008      	beq.n	25ba <memcpy+0xe2>

	lsls	r2, r2, #31
    25a8:	07d2      	lsls	r2, r2, #31
	itt ne
    25aa:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    25ac:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    25b0:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc	.Ldone
    25b4:	d301      	bcc.n	25ba <memcpy+0xe2>
#ifdef __ARM_FEATURE_UNALIGNED
	ldrh	r3, [r1]
    25b6:	880b      	ldrh	r3, [r1, #0]
	strh	r3, [r0]
    25b8:	8003      	strh	r3, [r0, #0]
	strb	r3, [r0, #1]
#endif /* __ARM_FEATURE_UNALIGNED */

.Ldone:
#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    25ba:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    25bc:	4770      	bx	lr
    25be:	bf00      	nop
#define Ldst_aligned Lbig_block

	/* Copy word by word using LDR when alignment can be done in hardware,
	i.e., SCTLR.A is set, supporting unaligned access in LDR and STR.  */

	cmp	r2, #8
    25c0:	2a08      	cmp	r2, #8
	blo	.Lbyte_copy
    25c2:	d313      	bcc.n	25ec <memcpy+0x114>

	/* if src is aligned, just go to the big block loop.  */
	lsls	r3, r1, #30
    25c4:	078b      	lsls	r3, r1, #30
	beq	.Ldst_aligned
    25c6:	d08d      	beq.n	24e4 <memcpy+0xc>
	handling of aligned src and misaligned dst need more overhead than
	otherwise.  By doing this the worst case is when initial src is aligned,
	additional up to 4 byte additional copy will executed, which is
	acceptable.  */

	ands	r3, r0, #3
    25c8:	f010 0303 	ands.w	r3, r0, #3
	beq	.Ldst_aligned
    25cc:	d08a      	beq.n	24e4 <memcpy+0xc>

	rsb	r3, #4
    25ce:	f1c3 0304 	rsb	r3, r3, #4
	subs	r2, r3
    25d2:	1ad2      	subs	r2, r2, r3

	lsls    r3, r3, #31
    25d4:	07db      	lsls	r3, r3, #31
	itt ne
    25d6:	bf1c      	itt	ne
	ldrbne  r3, [r1], #1
    25d8:	f811 3b01 	ldrbne.w	r3, [r1], #1
	strbne  r3, [r0], #1
    25dc:	f800 3b01 	strbne.w	r3, [r0], #1

	bcc .Ldst_aligned
    25e0:	d380      	bcc.n	24e4 <memcpy+0xc>

#ifdef __ARM_FEATURE_UNALIGNED
	ldrh    r3, [r1], #2
    25e2:	f831 3b02 	ldrh.w	r3, [r1], #2
	strh    r3, [r0], #2
    25e6:	f820 3b02 	strh.w	r3, [r0], #2
	b	.Ldst_aligned
    25ea:	e77b      	b.n	24e4 <memcpy+0xc>
	pop	{r4, r5}

#endif /* __ARM_FEATURE_UNALIGNED */

.Lbyte_copy:
	subs	r2, #4
    25ec:	3a04      	subs	r2, #4
	blo	.Lcopy_less_than_4
    25ee:	d3d9      	bcc.n	25a4 <memcpy+0xcc>

.Lbyte_copy_loop:
	subs    r2, #1
    25f0:	3a01      	subs	r2, #1
	ldrb    r3, [r1], #1
    25f2:	f811 3b01 	ldrb.w	r3, [r1], #1
	strb    r3, [r0], #1
    25f6:	f800 3b01 	strb.w	r3, [r0], #1
	bhs	.Lbyte_copy_loop
    25fa:	d2f9      	bcs.n	25f0 <memcpy+0x118>

	ldrb	r3, [r1]
    25fc:	780b      	ldrb	r3, [r1, #0]
	strb	r3, [r0]
    25fe:	7003      	strb	r3, [r0, #0]
	ldrb	r3, [r1, #1]
    2600:	784b      	ldrb	r3, [r1, #1]
	strb	r3, [r0, #1]
    2602:	7043      	strb	r3, [r0, #1]
	ldrb	r3, [r1, #2]
    2604:	788b      	ldrb	r3, [r1, #2]
	strb	r3, [r0, #2]
    2606:	7083      	strb	r3, [r0, #2]

#ifdef __ARM_FEATURE_UNALIGNED
	mov	r0, ip
    2608:	4660      	mov	r0, ip
#else
	pop	{r0}
#endif
	bx	lr
    260a:	4770      	bx	lr

0000260c <set_arm_clock>:
//  CCM_CBCMR  PERIPH2_CLK_SEL
//  CCM_CBCDR  AHB_PODF
//  CCM_CBCDR  SEMC_PODF

uint32_t set_arm_clock(uint32_t frequency)
{
    260c:	b5f0      	push	{r4, r5, r6, r7, lr}
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
    260e:	4b8b      	ldr	r3, [pc, #556]	; (283c <set_arm_clock+0x230>)
    2610:	695f      	ldr	r7, [r3, #20]
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
    2612:	699a      	ldr	r2, [r3, #24]
	uint32_t dcdc = DCDC_REG3;
    2614:	f5a3 23f8 	sub.w	r3, r3, #507904	; 0x7c000
    2618:	68de      	ldr	r6, [r3, #12]

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
	if (frequency > 528000000) {
    261a:	4b89      	ldr	r3, [pc, #548]	; (2840 <set_arm_clock+0x234>)
    261c:	4298      	cmp	r0, r3
    261e:	d913      	bls.n	2648 <set_arm_clock+0x3c>
		voltage = 1250; // 1.25V
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
    2620:	4b88      	ldr	r3, [pc, #544]	; (2844 <set_arm_clock+0x238>)
    2622:	4298      	cmp	r0, r3
    2624:	d916      	bls.n	2654 <set_arm_clock+0x48>
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
    2626:	4b88      	ldr	r3, [pc, #544]	; (2848 <set_arm_clock+0x23c>)
    2628:	4403      	add	r3, r0
    262a:	0a1b      	lsrs	r3, r3, #8
    262c:	4d87      	ldr	r5, [pc, #540]	; (284c <set_arm_clock+0x240>)
    262e:	fba5 3503 	umull	r3, r5, r5, r3
    2632:	09ed      	lsrs	r5, r5, #7
    2634:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    2638:	eb05 0585 	add.w	r5, r5, r5, lsl #2
    263c:	f205 45e2 	addw	r5, r5, #1250	; 0x4e2
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
    2640:	f5b5 6fc5 	cmp.w	r5, #1576	; 0x628
    2644:	d209      	bcs.n	265a <set_arm_clock+0x4e>
    2646:	e00d      	b.n	2664 <set_arm_clock+0x58>
		}
#endif
	} else if (frequency <= 24000000) {
    2648:	4b81      	ldr	r3, [pc, #516]	; (2850 <set_arm_clock+0x244>)
    264a:	4298      	cmp	r0, r3
    264c:	d908      	bls.n	2660 <set_arm_clock+0x54>
	uint32_t cbcdr = CCM_CBCDR; // pg 1021
	uint32_t cbcmr = CCM_CBCMR; // pg 1023
	uint32_t dcdc = DCDC_REG3;

	// compute required voltage
	uint32_t voltage = 1150; // default = 1.15V
    264e:	f240 457e 	movw	r5, #1150	; 0x47e
    2652:	e007      	b.n	2664 <set_arm_clock+0x58>
	if (frequency > 528000000) {
		voltage = 1250; // 1.25V
    2654:	f240 45e2 	movw	r5, #1250	; 0x4e2
    2658:	e004      	b.n	2664 <set_arm_clock+0x58>
#if defined(OVERCLOCK_STEPSIZE) && defined(OVERCLOCK_MAX_VOLT)
		if (frequency > 600000000) {
			voltage += ((frequency - 600000000) / OVERCLOCK_STEPSIZE) * 25;
			if (voltage > OVERCLOCK_MAX_VOLT) voltage = OVERCLOCK_MAX_VOLT;
    265a:	f240 6527 	movw	r5, #1575	; 0x627
    265e:	e001      	b.n	2664 <set_arm_clock+0x58>
		}
#endif
	} else if (frequency <= 24000000) {
		voltage = 950; // 0.95
    2660:	f240 35b6 	movw	r5, #950	; 0x3b6
	}

	// if voltage needs to increase, do it before switch clock speed
	CCM_CCGR6 |= CCM_CCGR6_DCDC(CCM_CCGR_ON);
    2664:	4975      	ldr	r1, [pc, #468]	; (283c <set_arm_clock+0x230>)
    2666:	f8d1 3080 	ldr.w	r3, [r1, #128]	; 0x80
    266a:	f043 03c0 	orr.w	r3, r3, #192	; 0xc0
    266e:	f8c1 3080 	str.w	r3, [r1, #128]	; 0x80
	if ((dcdc & DCDC_REG3_TRG_MASK) < DCDC_REG3_TRG((voltage - 800) / 25)) {
    2672:	f006 031f 	and.w	r3, r6, #31
    2676:	f5a5 7548 	sub.w	r5, r5, #800	; 0x320
    267a:	4976      	ldr	r1, [pc, #472]	; (2854 <set_arm_clock+0x248>)
    267c:	fba1 1505 	umull	r1, r5, r1, r5
    2680:	f3c5 05c4 	ubfx	r5, r5, #3, #5
    2684:	42ab      	cmp	r3, r5
    2686:	d207      	bcs.n	2698 <set_arm_clock+0x8c>
		printf("Increasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    2688:	f365 0604 	bfi	r6, r5, #0, #5
		DCDC_REG3 = dcdc;
    268c:	4b72      	ldr	r3, [pc, #456]	; (2858 <set_arm_clock+0x24c>)
    268e:	60de      	str	r6, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2690:	4b71      	ldr	r3, [pc, #452]	; (2858 <set_arm_clock+0x24c>)
    2692:	681b      	ldr	r3, [r3, #0]
    2694:	2b00      	cmp	r3, #0
    2696:	dafb      	bge.n	2690 <set_arm_clock+0x84>
	}

	if (!(cbcdr & CCM_CBCDR_PERIPH_CLK_SEL)) {
    2698:	f017 7f00 	tst.w	r7, #33554432	; 0x2000000
    269c:	d12e      	bne.n	26fc <set_arm_clock+0xf0>
		printf("need to switch to alternate clock during reconfigure of ARM PLL\n");
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
    269e:	4b6f      	ldr	r3, [pc, #444]	; (285c <set_arm_clock+0x250>)
    26a0:	6919      	ldr	r1, [r3, #16]
    26a2:	4b6f      	ldr	r3, [pc, #444]	; (2860 <set_arm_clock+0x254>)
    26a4:	438b      	bics	r3, r1
    26a6:	d102      	bne.n	26ae <set_arm_clock+0xa2>
			printf("USB PLL is running, so we can use 120 MHz\n");
			sel = 0;
			div = 3; // divide down to 120 MHz, so IPG is ok even if IPG_PODF=0
    26a8:	2403      	movs	r4, #3
		const uint32_t need1s = CCM_ANALOG_PLL_USB1_ENABLE | CCM_ANALOG_PLL_USB1_POWER |
			CCM_ANALOG_PLL_USB1_LOCK | CCM_ANALOG_PLL_USB1_EN_USB_CLKS;
		uint32_t sel, div;
		if ((CCM_ANALOG_PLL_USB1 & need1s) == need1s) {
			printf("USB PLL is running, so we can use 120 MHz\n");
			sel = 0;
    26aa:	2300      	movs	r3, #0
    26ac:	e001      	b.n	26b2 <set_arm_clock+0xa6>
			div = 3; // divide down to 120 MHz, so IPG is ok even if IPG_PODF=0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
			div = 0;
    26ae:	2400      	movs	r4, #0
			printf("USB PLL is running, so we can use 120 MHz\n");
			sel = 0;
			div = 3; // divide down to 120 MHz, so IPG is ok even if IPG_PODF=0
		} else {
			printf("USB PLL is off, use 24 MHz crystal\n");
			sel = 1;
    26b0:	2301      	movs	r3, #1
			div = 0;
		}
		if ((cbcdr & CCM_CBCDR_PERIPH_CLK2_PODF_MASK) != CCM_CBCDR_PERIPH_CLK2_PODF(div)) {
    26b2:	06e4      	lsls	r4, r4, #27
    26b4:	ea87 0104 	eor.w	r1, r7, r4
    26b8:	f011 5f60 	tst.w	r1, #939524096	; 0x38000000
    26bc:	d005      	beq.n	26ca <set_arm_clock+0xbe>
			// PERIPH_CLK2 divider needs to be changed
			cbcdr &= ~CCM_CBCDR_PERIPH_CLK2_PODF_MASK;
    26be:	f027 5160 	bic.w	r1, r7, #939524096	; 0x38000000
			cbcdr |= CCM_CBCDR_PERIPH_CLK2_PODF(div);
    26c2:	ea44 0701 	orr.w	r7, r4, r1
			CCM_CBCDR = cbcdr;
    26c6:	495d      	ldr	r1, [pc, #372]	; (283c <set_arm_clock+0x230>)
    26c8:	614f      	str	r7, [r1, #20]
		}
		if ((cbcmr & CCM_CBCMR_PERIPH_CLK2_SEL_MASK) != CCM_CBCMR_PERIPH_CLK2_SEL(sel)) {
    26ca:	031b      	lsls	r3, r3, #12
    26cc:	ea82 0103 	eor.w	r1, r2, r3
    26d0:	f411 5f40 	tst.w	r1, #12288	; 0x3000
    26d4:	d009      	beq.n	26ea <set_arm_clock+0xde>
			// PERIPH_CLK2 source select needs to be changed
			cbcmr &= ~CCM_CBCMR_PERIPH_CLK2_SEL_MASK;
    26d6:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
			cbcmr |= CCM_CBCMR_PERIPH_CLK2_SEL(sel);
    26da:	431a      	orrs	r2, r3
			CCM_CBCMR = cbcmr;
    26dc:	4b57      	ldr	r3, [pc, #348]	; (283c <set_arm_clock+0x230>)
    26de:	619a      	str	r2, [r3, #24]
			while (CCM_CDHIPR & CCM_CDHIPR_PERIPH2_CLK_SEL_BUSY) ; // wait
    26e0:	4b56      	ldr	r3, [pc, #344]	; (283c <set_arm_clock+0x230>)
    26e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    26e4:	f013 0f08 	tst.w	r3, #8
    26e8:	d1fa      	bne.n	26e0 <set_arm_clock+0xd4>
		}
		// switch over to PERIPH_CLK2
		cbcdr |= CCM_CBCDR_PERIPH_CLK_SEL;
    26ea:	f047 7700 	orr.w	r7, r7, #33554432	; 0x2000000
		CCM_CBCDR = cbcdr;
    26ee:	4b53      	ldr	r3, [pc, #332]	; (283c <set_arm_clock+0x230>)
    26f0:	615f      	str	r7, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    26f2:	4b52      	ldr	r3, [pc, #328]	; (283c <set_arm_clock+0x230>)
    26f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    26f6:	f013 0f20 	tst.w	r3, #32
    26fa:	d1fa      	bne.n	26f2 <set_arm_clock+0xe6>

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
    26fc:	2101      	movs	r1, #1
	}

	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
    26fe:	460a      	mov	r2, r1
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    2700:	e007      	b.n	2712 <set_arm_clock+0x106>
		if (div_arm < 8) {
    2702:	2a07      	cmp	r2, #7
    2704:	d801      	bhi.n	270a <set_arm_clock+0xfe>
			div_arm = div_arm + 1;
    2706:	3201      	adds	r2, #1
    2708:	e003      	b.n	2712 <set_arm_clock+0x106>
		} else {
			if (div_ahb < 5) {
    270a:	2904      	cmp	r1, #4
    270c:	d808      	bhi.n	2720 <set_arm_clock+0x114>
				div_ahb = div_ahb + 1;
    270e:	3101      	adds	r1, #1
				div_arm = 1;
    2710:	2201      	movs	r2, #1
	// TODO: check if PLL2 running, can 352, 396 or 528 can work? (no need for ARM PLL)

	// DIV_SELECT: 54-108 = official range 648 to 1296 in 12 MHz steps
	uint32_t div_arm = 1;
	uint32_t div_ahb = 1;
	while (frequency * div_arm * div_ahb < 648000000) {
    2712:	fb00 f302 	mul.w	r3, r0, r2
    2716:	fb03 f301 	mul.w	r3, r3, r1
    271a:	4c52      	ldr	r4, [pc, #328]	; (2864 <set_arm_clock+0x258>)
    271c:	42a3      	cmp	r3, r4
    271e:	d9f0      	bls.n	2702 <set_arm_clock+0xf6>
			} else {
				break;
			}
		}
	}
	uint32_t mult = (frequency * div_arm * div_ahb + 6000000) / 12000000;
    2720:	4851      	ldr	r0, [pc, #324]	; (2868 <set_arm_clock+0x25c>)
    2722:	4418      	add	r0, r3
    2724:	4b51      	ldr	r3, [pc, #324]	; (286c <set_arm_clock+0x260>)
    2726:	fba3 0300 	umull	r0, r3, r3, r0
    272a:	0d1b      	lsrs	r3, r3, #20
	if (mult > 108) mult = 108;
    272c:	2b6c      	cmp	r3, #108	; 0x6c
    272e:	d900      	bls.n	2732 <set_arm_clock+0x126>
    2730:	236c      	movs	r3, #108	; 0x6c
	if (mult < 54) mult = 54;
    2732:	2b35      	cmp	r3, #53	; 0x35
    2734:	d800      	bhi.n	2738 <set_arm_clock+0x12c>
    2736:	2336      	movs	r3, #54	; 0x36
	printf("Freq: 12 MHz * %u / %u / %u\n", mult, div_arm, div_ahb);
	frequency = mult * 12000000 / div_arm / div_ahb;
    2738:	484d      	ldr	r0, [pc, #308]	; (2870 <set_arm_clock+0x264>)
    273a:	fb00 f003 	mul.w	r0, r0, r3
    273e:	fbb0 f0f2 	udiv	r0, r0, r2
    2742:	fbb0 f0f1 	udiv	r0, r0, r1

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    2746:	4c45      	ldr	r4, [pc, #276]	; (285c <set_arm_clock+0x250>)
    2748:	6824      	ldr	r4, [r4, #0]
    274a:	f8df e144 	ldr.w	lr, [pc, #324]	; 2890 <set_arm_clock+0x284>
    274e:	ea04 0e0e 	and.w	lr, r4, lr
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
    2752:	f003 037f 	and.w	r3, r3, #127	; 0x7f
    2756:	4c47      	ldr	r4, [pc, #284]	; (2874 <set_arm_clock+0x268>)
    2758:	431c      	orrs	r4, r3

	printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	const uint32_t arm_pll_mask = CCM_ANALOG_PLL_ARM_LOCK | CCM_ANALOG_PLL_ARM_BYPASS |
		CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_POWERDOWN |
		CCM_ANALOG_PLL_ARM_DIV_SELECT_MASK;
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
    275a:	45a6      	cmp	lr, r4
    275c:	d00b      	beq.n	2776 <set_arm_clock+0x16a>
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
    275e:	4c3f      	ldr	r4, [pc, #252]	; (285c <set_arm_clock+0x250>)
    2760:	f44f 5e80 	mov.w	lr, #4096	; 0x1000
    2764:	f8c4 e000 	str.w	lr, [r4]
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
    2768:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
	if ((CCM_ANALOG_PLL_ARM & arm_pll_mask) != (CCM_ANALOG_PLL_ARM_LOCK
	  | CCM_ANALOG_PLL_ARM_ENABLE | CCM_ANALOG_PLL_ARM_DIV_SELECT(mult))) {
		printf("ARM PLL needs reconfigure\n");
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_POWERDOWN;
		// TODO: delay needed?
		CCM_ANALOG_PLL_ARM = CCM_ANALOG_PLL_ARM_ENABLE
    276c:	6023      	str	r3, [r4, #0]
			| CCM_ANALOG_PLL_ARM_DIV_SELECT(mult);
		while (!(CCM_ANALOG_PLL_ARM & CCM_ANALOG_PLL_ARM_LOCK)) ; // wait for lock
    276e:	4b3b      	ldr	r3, [pc, #236]	; (285c <set_arm_clock+0x250>)
    2770:	681b      	ldr	r3, [r3, #0]
    2772:	2b00      	cmp	r3, #0
    2774:	dafb      	bge.n	276e <set_arm_clock+0x162>
		printf("ARM PLL=%x\n", CCM_ANALOG_PLL_ARM);
	} else {
		printf("ARM PLL already running at required frequency\n");
	}

	if ((CCM_CACRR & CCM_CACRR_ARM_PODF_MASK) != (div_arm - 1)) {
    2776:	4b31      	ldr	r3, [pc, #196]	; (283c <set_arm_clock+0x230>)
    2778:	691b      	ldr	r3, [r3, #16]
    277a:	f003 0307 	and.w	r3, r3, #7
    277e:	3a01      	subs	r2, #1
    2780:	4293      	cmp	r3, r2
    2782:	d008      	beq.n	2796 <set_arm_clock+0x18a>
		CCM_CACRR = CCM_CACRR_ARM_PODF(div_arm - 1);
    2784:	f002 0207 	and.w	r2, r2, #7
    2788:	4b2c      	ldr	r3, [pc, #176]	; (283c <set_arm_clock+0x230>)
    278a:	611a      	str	r2, [r3, #16]
		while (CCM_CDHIPR & CCM_CDHIPR_ARM_PODF_BUSY) ; // wait
    278c:	4b2b      	ldr	r3, [pc, #172]	; (283c <set_arm_clock+0x230>)
    278e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    2790:	f413 3f80 	tst.w	r3, #65536	; 0x10000
    2794:	d1fa      	bne.n	278c <set_arm_clock+0x180>
	}

	if ((cbcdr & CCM_CBCDR_AHB_PODF_MASK) != CCM_CBCDR_AHB_PODF(div_ahb - 1)) {
    2796:	3901      	subs	r1, #1
    2798:	0289      	lsls	r1, r1, #10
    279a:	ea87 0301 	eor.w	r3, r7, r1
    279e:	f413 5fe0 	tst.w	r3, #7168	; 0x1c00
    27a2:	d00b      	beq.n	27bc <set_arm_clock+0x1b0>
		cbcdr &= ~CCM_CBCDR_AHB_PODF_MASK;
    27a4:	f427 57e0 	bic.w	r7, r7, #7168	; 0x1c00
		cbcdr |= CCM_CBCDR_AHB_PODF(div_ahb - 1);
    27a8:	f401 51e0 	and.w	r1, r1, #7168	; 0x1c00
    27ac:	430f      	orrs	r7, r1
		CCM_CBCDR = cbcdr;
    27ae:	4b23      	ldr	r3, [pc, #140]	; (283c <set_arm_clock+0x230>)
    27b0:	615f      	str	r7, [r3, #20]
		while (CCM_CDHIPR & CCM_CDHIPR_AHB_PODF_BUSY); // wait
    27b2:	4b22      	ldr	r3, [pc, #136]	; (283c <set_arm_clock+0x230>)
    27b4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    27b6:	f013 0f02 	tst.w	r3, #2
    27ba:	d1fa      	bne.n	27b2 <set_arm_clock+0x1a6>
	}

	uint32_t div_ipg = (frequency + 149999999) / 150000000;
    27bc:	4a2e      	ldr	r2, [pc, #184]	; (2878 <set_arm_clock+0x26c>)
    27be:	4402      	add	r2, r0
    27c0:	09d2      	lsrs	r2, r2, #7
    27c2:	4b2e      	ldr	r3, [pc, #184]	; (287c <set_arm_clock+0x270>)
    27c4:	fba3 3202 	umull	r3, r2, r3, r2
    27c8:	0b12      	lsrs	r2, r2, #12
	if (div_ipg > 4) div_ipg = 4;
    27ca:	2a04      	cmp	r2, #4
    27cc:	d900      	bls.n	27d0 <set_arm_clock+0x1c4>
    27ce:	2204      	movs	r2, #4
	if ((cbcdr & CCM_CBCDR_IPG_PODF_MASK) != (CCM_CBCDR_IPG_PODF(div_ipg - 1))) {
    27d0:	1e53      	subs	r3, r2, #1
    27d2:	021b      	lsls	r3, r3, #8
    27d4:	ea87 0103 	eor.w	r1, r7, r3
    27d8:	f411 7f40 	tst.w	r1, #768	; 0x300
    27dc:	d006      	beq.n	27ec <set_arm_clock+0x1e0>
		cbcdr &= ~CCM_CBCDR_IPG_PODF_MASK;
    27de:	f427 7140 	bic.w	r1, r7, #768	; 0x300
		cbcdr |= CCM_CBCDR_IPG_PODF(div_ipg - 1);
    27e2:	f403 7340 	and.w	r3, r3, #768	; 0x300
    27e6:	4319      	orrs	r1, r3
		// TODO: how to safely change IPG_PODF ??
		CCM_CBCDR = cbcdr;
    27e8:	4b14      	ldr	r3, [pc, #80]	; (283c <set_arm_clock+0x230>)
    27ea:	6159      	str	r1, [r3, #20]
	}

	//cbcdr &= ~CCM_CBCDR_PERIPH_CLK_SEL;
	//CCM_CBCDR = cbcdr;  // why does this not work at 24 MHz?
	CCM_CBCDR &= ~CCM_CBCDR_PERIPH_CLK_SEL;
    27ec:	4913      	ldr	r1, [pc, #76]	; (283c <set_arm_clock+0x230>)
    27ee:	694b      	ldr	r3, [r1, #20]
    27f0:	f023 7300 	bic.w	r3, r3, #33554432	; 0x2000000
    27f4:	614b      	str	r3, [r1, #20]
	while (CCM_CDHIPR & CCM_CDHIPR_PERIPH_CLK_SEL_BUSY) ; // wait
    27f6:	4b11      	ldr	r3, [pc, #68]	; (283c <set_arm_clock+0x230>)
    27f8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
    27fa:	f013 0f20 	tst.w	r3, #32
    27fe:	d1fa      	bne.n	27f6 <set_arm_clock+0x1ea>

	F_CPU_ACTUAL = frequency;
    2800:	4b1f      	ldr	r3, [pc, #124]	; (2880 <set_arm_clock+0x274>)
    2802:	6018      	str	r0, [r3, #0]
	F_BUS_ACTUAL = frequency / div_ipg;
    2804:	fbb0 f2f2 	udiv	r2, r0, r2
    2808:	4b1e      	ldr	r3, [pc, #120]	; (2884 <set_arm_clock+0x278>)
    280a:	601a      	str	r2, [r3, #0]
	scale_cpu_cycles_to_microseconds = 0xFFFFFFFFu / (uint32_t)(frequency / 1000000u);
    280c:	4b1e      	ldr	r3, [pc, #120]	; (2888 <set_arm_clock+0x27c>)
    280e:	fba3 2300 	umull	r2, r3, r3, r0
    2812:	0c9b      	lsrs	r3, r3, #18
    2814:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    2818:	fbb2 f3f3 	udiv	r3, r2, r3
    281c:	4a1b      	ldr	r2, [pc, #108]	; (288c <set_arm_clock+0x280>)
    281e:	6013      	str	r3, [r2, #0]

	printf("New Frequency: ARM=%u, IPG=%u\n", frequency, frequency / div_ipg);

	// if voltage needs to decrease, do it after switch clock speed
	if ((dcdc & DCDC_REG3_TRG_MASK) > DCDC_REG3_TRG((voltage - 800) / 25)) {
    2820:	f006 031f 	and.w	r3, r6, #31
    2824:	429d      	cmp	r5, r3
    2826:	d208      	bcs.n	283a <set_arm_clock+0x22e>
		printf("Decreasing voltage to %u mV\n", voltage);
		dcdc &= ~DCDC_REG3_TRG_MASK;
    2828:	f026 061f 	bic.w	r6, r6, #31
		dcdc |= DCDC_REG3_TRG((voltage - 800) / 25);
    282c:	4335      	orrs	r5, r6
		DCDC_REG3 = dcdc;
    282e:	4b0a      	ldr	r3, [pc, #40]	; (2858 <set_arm_clock+0x24c>)
    2830:	60dd      	str	r5, [r3, #12]
		while (!(DCDC_REG0 & DCDC_REG0_STS_DC_OK)) ; // wait voltage settling
    2832:	4b09      	ldr	r3, [pc, #36]	; (2858 <set_arm_clock+0x24c>)
    2834:	681b      	ldr	r3, [r3, #0]
    2836:	2b00      	cmp	r3, #0
    2838:	dafb      	bge.n	2832 <set_arm_clock+0x226>
	}

	return frequency;
}
    283a:	bdf0      	pop	{r4, r5, r6, r7, pc}
    283c:	400fc000 	.word	0x400fc000
    2840:	1f78a400 	.word	0x1f78a400
    2844:	23c34600 	.word	0x23c34600
    2848:	dc3cba00 	.word	0xdc3cba00
    284c:	004cb223 	.word	0x004cb223
    2850:	016e3600 	.word	0x016e3600
    2854:	51eb851f 	.word	0x51eb851f
    2858:	40080000 	.word	0x40080000
    285c:	400d8000 	.word	0x400d8000
    2860:	80003040 	.word	0x80003040
    2864:	269fb1ff 	.word	0x269fb1ff
    2868:	005b8d80 	.word	0x005b8d80
    286c:	165e9f81 	.word	0x165e9f81
    2870:	00b71b00 	.word	0x00b71b00
    2874:	80002000 	.word	0x80002000
    2878:	08f0d17f 	.word	0x08f0d17f
    287c:	00e5109f 	.word	0x00e5109f
    2880:	20000710 	.word	0x20000710
    2884:	2000070c 	.word	0x2000070c
    2888:	431bde83 	.word	0x431bde83
    288c:	200013d0 	.word	0x200013d0
    2890:	8001307f 	.word	0x8001307f

00002894 <micros>:
	}
	// TODO...
}

uint32_t micros(void)
{
    2894:	b410      	push	{r4}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
{
    uint32_t result;

   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
    2896:	4b10      	ldr	r3, [pc, #64]	; (28d8 <micros+0x44>)
    2898:	e853 2f00 	ldrex	r2, [r3]
	uint32_t smc, scc;
	do {
		__LDREXW(&systick_safe_read);
		smc = systick_millis_count;
    289c:	4a0f      	ldr	r2, [pc, #60]	; (28dc <micros+0x48>)
    289e:	6814      	ldr	r4, [r2, #0]
		scc = systick_cycle_count;
    28a0:	4a0f      	ldr	r2, [pc, #60]	; (28e0 <micros+0x4c>)
    28a2:	6810      	ldr	r0, [r2, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
{
   uint32_t result;

   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
    28a4:	2101      	movs	r1, #1
    28a6:	e843 1200 	strex	r2, r1, [r3]
	} while ( __STREXW(1, &systick_safe_read));
    28aa:	2a00      	cmp	r2, #0
    28ac:	d1f3      	bne.n	2896 <micros+0x2>
	uint32_t cyccnt = ARM_DWT_CYCCNT;
    28ae:	4b0d      	ldr	r3, [pc, #52]	; (28e4 <micros+0x50>)
    28b0:	681b      	ldr	r3, [r3, #0]
	asm volatile("" : : : "memory");
	uint32_t ccdelta = cyccnt - scc;
    28b2:	1a18      	subs	r0, r3, r0
	uint32_t frac = ((uint64_t)ccdelta * scale_cpu_cycles_to_microseconds) >> 32;
    28b4:	4b0c      	ldr	r3, [pc, #48]	; (28e8 <micros+0x54>)
    28b6:	681b      	ldr	r3, [r3, #0]
    28b8:	fba3 0100 	umull	r0, r1, r3, r0
    28bc:	460a      	mov	r2, r1
	if (frac > 1000) frac = 1000;
    28be:	f5b1 7f7a 	cmp.w	r1, #1000	; 0x3e8
    28c2:	d901      	bls.n	28c8 <micros+0x34>
    28c4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
	uint32_t usec = 1000*smc + frac;
	return usec;
}
    28c8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
    28cc:	fb00 2004 	mla	r0, r0, r4, r2
    28d0:	f85d 4b04 	ldr.w	r4, [sp], #4
    28d4:	4770      	bx	lr
    28d6:	bf00      	nop
    28d8:	200016e8 	.word	0x200016e8
    28dc:	200013d4 	.word	0x200013d4
    28e0:	200013cc 	.word	0x200013cc
    28e4:	e0001004 	.word	0xe0001004
    28e8:	200013d0 	.word	0x200013d0

000028ec <delay>:

void delay(uint32_t msec)
{
	uint32_t start;

	if (msec == 0) return;
    28ec:	b198      	cbz	r0, 2916 <delay+0x2a>
{

}*/

void delay(uint32_t msec)
{
    28ee:	b538      	push	{r3, r4, r5, lr}
    28f0:	4605      	mov	r5, r0
	uint32_t start;

	if (msec == 0) return;
	start = micros();
    28f2:	f7ff ffcf 	bl	2894 <micros>
    28f6:	4604      	mov	r4, r0
    28f8:	e003      	b.n	2902 <delay+0x16>
	while (1) {
		while ((micros() - start) >= 1000) {
			if (--msec == 0) return;
    28fa:	3d01      	subs	r5, #1
    28fc:	d00a      	beq.n	2914 <delay+0x28>
			start += 1000;
    28fe:	f504 747a 	add.w	r4, r4, #1000	; 0x3e8
	uint32_t start;

	if (msec == 0) return;
	start = micros();
	while (1) {
		while ((micros() - start) >= 1000) {
    2902:	f7ff ffc7 	bl	2894 <micros>
    2906:	1b00      	subs	r0, r0, r4
    2908:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
    290c:	d2f5      	bcs.n	28fa <delay+0xe>
			if (--msec == 0) return;
			start += 1000;
		}
		yield();
    290e:	f001 faed 	bl	3eec <yield>
	}
    2912:	e7f6      	b.n	2902 <delay+0x16>
    2914:	bd38      	pop	{r3, r4, r5, pc}
    2916:	4770      	bx	lr

00002918 <digitalWrite>:
void digitalWrite(uint8_t pin, uint8_t val)
{
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
    2918:	2827      	cmp	r0, #39	; 0x27
    291a:	d819      	bhi.n	2950 <digitalWrite+0x38>
	{&CORE_PIN54_PORTREG, &CORE_PIN54_CONFIG, &CORE_PIN54_PADCONFIG, CORE_PIN54_BITMASK},
#endif
};

void digitalWrite(uint8_t pin, uint8_t val)
{
    291c:	b410      	push	{r4}
	const struct digital_pin_bitband_and_config_table_struct *p;
	uint32_t pinmode, mask;

	if (pin >= CORE_NUM_DIGITAL) return;
	p = digital_pin_to_info_PGM + pin;
    291e:	0100      	lsls	r0, r0, #4
    2920:	4b0c      	ldr	r3, [pc, #48]	; (2954 <digitalWrite+0x3c>)
    2922:	181a      	adds	r2, r3, r0
	pinmode = *(p->reg + 1);
    2924:	581b      	ldr	r3, [r3, r0]
    2926:	685c      	ldr	r4, [r3, #4]
	mask = p->mask;
    2928:	68d0      	ldr	r0, [r2, #12]
	if (pinmode & mask) {
    292a:	4204      	tst	r4, r0
    292c:	d006      	beq.n	293c <digitalWrite+0x24>
		// pin is configured for output mode
		if (val) {
    292e:	b111      	cbz	r1, 2936 <digitalWrite+0x1e>
			*(p->reg + 0x21) = mask; // set register
    2930:	f8c3 0084 	str.w	r0, [r3, #132]	; 0x84
    2934:	e00a      	b.n	294c <digitalWrite+0x34>
		} else {
			*(p->reg + 0x22) = mask; // clear register
    2936:	f8c3 0088 	str.w	r0, [r3, #136]	; 0x88
    293a:	e007      	b.n	294c <digitalWrite+0x34>
		}
	} else {
		// pin is configured for input mode
		// value controls PULLUP/PULLDOWN resistors
		if (val) {
    293c:	b119      	cbz	r1, 2946 <digitalWrite+0x2e>
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(3) | IOMUXC_PAD_HYS;
    293e:	6893      	ldr	r3, [r2, #8]
    2940:	4a05      	ldr	r2, [pc, #20]	; (2958 <digitalWrite+0x40>)
    2942:	601a      	str	r2, [r3, #0]
    2944:	e002      	b.n	294c <digitalWrite+0x34>
		} else {
			*(p->pad) = IOMUXC_PAD_DSE(7) | IOMUXC_PAD_PKE | IOMUXC_PAD_PUE | IOMUXC_PAD_PUS(0) | IOMUXC_PAD_HYS;
    2946:	6893      	ldr	r3, [r2, #8]
    2948:	4a04      	ldr	r2, [pc, #16]	; (295c <digitalWrite+0x44>)
    294a:	601a      	str	r2, [r3, #0]
		}
	}
}
    294c:	f85d 4b04 	ldr.w	r4, [sp], #4
    2950:	4770      	bx	lr
    2952:	bf00      	nop
    2954:	20000324 	.word	0x20000324
    2958:	0001f038 	.word	0x0001f038
    295c:	00013038 	.word	0x00013038

00002960 <flexpwm_init>:
		quadtimerFrequency(qtimer, info->module & 0x03, frequency);
	}
}

void flexpwm_init(IMXRT_FLEXPWM_t *p)
{
    2960:	b410      	push	{r4}
	int i;

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
    2962:	f44f 4370 	mov.w	r3, #61440	; 0xf000
    2966:	f8a0 318c 	strh.w	r3, [r0, #396]	; 0x18c
	p->FSTS0 = 0x000F; // clear fault status
    296a:	230f      	movs	r3, #15
    296c:	f8a0 318e 	strh.w	r3, [r0, #398]	; 0x18e
	p->FFILT0 = 0;
    2970:	2100      	movs	r1, #0
    2972:	f8a0 1190 	strh.w	r1, [r0, #400]	; 0x190
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
    2976:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    297a:	b29b      	uxth	r3, r3
    297c:	f043 03f0 	orr.w	r3, r3, #240	; 0xf0
    2980:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	for (i=0; i < 4; i++) {
    2984:	e016      	b.n	29b4 <flexpwm_init+0x54>
		p->SM[i].CTRL2 = FLEXPWM_SMCTRL2_INDEP | FLEXPWM_SMCTRL2_WAITEN
    2986:	004a      	lsls	r2, r1, #1
    2988:	440a      	add	r2, r1
    298a:	0153      	lsls	r3, r2, #5
    298c:	4403      	add	r3, r0
    298e:	f44f 4260 	mov.w	r2, #57344	; 0xe000
    2992:	809a      	strh	r2, [r3, #4]
			| FLEXPWM_SMCTRL2_DBGEN;
		p->SM[i].CTRL = FLEXPWM_SMCTRL_FULL;
    2994:	f44f 6280 	mov.w	r2, #1024	; 0x400
    2998:	80da      	strh	r2, [r3, #6]
		p->SM[i].OCTRL = 0;
    299a:	2200      	movs	r2, #0
    299c:	845a      	strh	r2, [r3, #34]	; 0x22
		p->SM[i].DTCNT0 = 0;
    299e:	861a      	strh	r2, [r3, #48]	; 0x30
		p->SM[i].INIT = 0;
    29a0:	805a      	strh	r2, [r3, #2]
		p->SM[i].VAL0 = 0;
    29a2:	815a      	strh	r2, [r3, #10]
		p->SM[i].VAL1 = 33464;
    29a4:	f248 24b8 	movw	r4, #33464	; 0x82b8
    29a8:	81dc      	strh	r4, [r3, #14]
		p->SM[i].VAL2 = 0;
    29aa:	825a      	strh	r2, [r3, #18]
		p->SM[i].VAL3 = 0;
    29ac:	82da      	strh	r2, [r3, #22]
		p->SM[i].VAL4 = 0;
    29ae:	835a      	strh	r2, [r3, #26]
		p->SM[i].VAL5 = 0;
    29b0:	83da      	strh	r2, [r3, #30]

	p->FCTRL0 = FLEXPWM_FCTRL0_FLVL(15); // logic high = fault
	p->FSTS0 = 0x000F; // clear fault status
	p->FFILT0 = 0;
	p->MCTRL |= FLEXPWM_MCTRL_CLDOK(15);
	for (i=0; i < 4; i++) {
    29b2:	3101      	adds	r1, #1
    29b4:	2903      	cmp	r1, #3
    29b6:	dde6      	ble.n	2986 <flexpwm_init+0x26>
		p->SM[i].VAL2 = 0;
		p->SM[i].VAL3 = 0;
		p->SM[i].VAL4 = 0;
		p->SM[i].VAL5 = 0;
	}
	p->MCTRL |= FLEXPWM_MCTRL_LDOK(15);
    29b8:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    29bc:	b29b      	uxth	r3, r3
    29be:	f043 030f 	orr.w	r3, r3, #15
    29c2:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
	p->MCTRL |= FLEXPWM_MCTRL_RUN(15);
    29c6:	f8b0 3188 	ldrh.w	r3, [r0, #392]	; 0x188
    29ca:	b29b      	uxth	r3, r3
    29cc:	f443 6370 	orr.w	r3, r3, #3840	; 0xf00
    29d0:	f8a0 3188 	strh.w	r3, [r0, #392]	; 0x188
}
    29d4:	f85d 4b04 	ldr.w	r4, [sp], #4
    29d8:	4770      	bx	lr
    29da:	bf00      	nop

000029dc <quadtimer_init>:

void quadtimer_init(IMXRT_TMR_t *p)
{
    29dc:	b430      	push	{r4, r5}
	int i;

	for (i=0; i < 4; i++) {
    29de:	2100      	movs	r1, #0
    29e0:	e012      	b.n	2a08 <quadtimer_init+0x2c>
		p->CH[i].CTRL = 0; // stop timer
    29e2:	014c      	lsls	r4, r1, #5
    29e4:	1903      	adds	r3, r0, r4
    29e6:	2200      	movs	r2, #0
    29e8:	819a      	strh	r2, [r3, #12]
		p->CH[i].CNTR = 0;
    29ea:	815a      	strh	r2, [r3, #10]
		p->CH[i].SCTRL = TMR_SCTRL_OEN | TMR_SCTRL_OPS | TMR_SCTRL_VAL | TMR_SCTRL_FORCE;
    29ec:	250f      	movs	r5, #15
    29ee:	81dd      	strh	r5, [r3, #14]
		p->CH[i].CSCTRL = TMR_CSCTRL_CL1(1) | TMR_CSCTRL_ALT_LOAD;
    29f0:	f241 0501 	movw	r5, #4097	; 0x1001
    29f4:	829d      	strh	r5, [r3, #20]
		// COMP must be less than LOAD - otherwise output is always low
		p->CH[i].LOAD = 24000;   // low time  (65537 - x) - 
    29f6:	f645 55c0 	movw	r5, #24000	; 0x5dc0
    29fa:	80dd      	strh	r5, [r3, #6]
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
    29fc:	5302      	strh	r2, [r0, r4]
		p->CH[i].CMPLD1 = 0;
    29fe:	821a      	strh	r2, [r3, #16]
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
    2a00:	f243 0226 	movw	r2, #12326	; 0x3026
    2a04:	819a      	strh	r2, [r3, #12]

void quadtimer_init(IMXRT_TMR_t *p)
{
	int i;

	for (i=0; i < 4; i++) {
    2a06:	3101      	adds	r1, #1
    2a08:	2903      	cmp	r1, #3
    2a0a:	ddea      	ble.n	29e2 <quadtimer_init+0x6>
		p->CH[i].COMP1 = 0;  // high time (0 = always low, max = LOAD-1)
		p->CH[i].CMPLD1 = 0;
		p->CH[i].CTRL = TMR_CTRL_CM(1) | TMR_CTRL_PCS(8) |
			TMR_CTRL_LENGTH | TMR_CTRL_OUTMODE(6);
	}
}
    2a0c:	bc30      	pop	{r4, r5}
    2a0e:	4770      	bx	lr

00002a10 <pwm_init>:

void pwm_init(void)
{
    2a10:	b508      	push	{r3, lr}
	//printf("pwm init\n");
	CCM_CCGR4 |= CCM_CCGR4_PWM1(CCM_CCGR_ON) | CCM_CCGR4_PWM2(CCM_CCGR_ON) |
    2a12:	4b10      	ldr	r3, [pc, #64]	; (2a54 <pwm_init+0x44>)
    2a14:	6f9a      	ldr	r2, [r3, #120]	; 0x78
    2a16:	f442 027f 	orr.w	r2, r2, #16711680	; 0xff0000
    2a1a:	679a      	str	r2, [r3, #120]	; 0x78
		CCM_CCGR4_PWM3(CCM_CCGR_ON) | CCM_CCGR4_PWM4(CCM_CCGR_ON);
	CCM_CCGR6 |= CCM_CCGR6_QTIMER1(CCM_CCGR_ON) | CCM_CCGR6_QTIMER2(CCM_CCGR_ON) |
    2a1c:	f8d3 1080 	ldr.w	r1, [r3, #128]	; 0x80
    2a20:	4a0d      	ldr	r2, [pc, #52]	; (2a58 <pwm_init+0x48>)
    2a22:	430a      	orrs	r2, r1
    2a24:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
		CCM_CCGR6_QTIMER3(CCM_CCGR_ON) | CCM_CCGR6_QTIMER4(CCM_CCGR_ON);
	flexpwm_init(&IMXRT_FLEXPWM1);
    2a28:	480c      	ldr	r0, [pc, #48]	; (2a5c <pwm_init+0x4c>)
    2a2a:	f7ff ff99 	bl	2960 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM2);
    2a2e:	480c      	ldr	r0, [pc, #48]	; (2a60 <pwm_init+0x50>)
    2a30:	f7ff ff96 	bl	2960 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM3);
    2a34:	480b      	ldr	r0, [pc, #44]	; (2a64 <pwm_init+0x54>)
    2a36:	f7ff ff93 	bl	2960 <flexpwm_init>
	flexpwm_init(&IMXRT_FLEXPWM4);
    2a3a:	480b      	ldr	r0, [pc, #44]	; (2a68 <pwm_init+0x58>)
    2a3c:	f7ff ff90 	bl	2960 <flexpwm_init>
	quadtimer_init(&IMXRT_TMR1);
    2a40:	480a      	ldr	r0, [pc, #40]	; (2a6c <pwm_init+0x5c>)
    2a42:	f7ff ffcb 	bl	29dc <quadtimer_init>
	quadtimer_init(&IMXRT_TMR2);
    2a46:	480a      	ldr	r0, [pc, #40]	; (2a70 <pwm_init+0x60>)
    2a48:	f7ff ffc8 	bl	29dc <quadtimer_init>
	quadtimer_init(&IMXRT_TMR3);
    2a4c:	4809      	ldr	r0, [pc, #36]	; (2a74 <pwm_init+0x64>)
    2a4e:	f7ff ffc5 	bl	29dc <quadtimer_init>
    2a52:	bd08      	pop	{r3, pc}
    2a54:	400fc000 	.word	0x400fc000
    2a58:	fc030000 	.word	0xfc030000
    2a5c:	403dc000 	.word	0x403dc000
    2a60:	403e0000 	.word	0x403e0000
    2a64:	403e4000 	.word	0x403e4000
    2a68:	403e8000 	.word	0x403e8000
    2a6c:	401dc000 	.word	0x401dc000
    2a70:	401e0000 	.word	0x401e0000
    2a74:	401e4000 	.word	0x401e4000

00002a78 <configure_systick>:
#define SYSTICK_EXT_FREQ 100000

extern volatile uint32_t systick_cycle_count;
static void configure_systick(void)
{
	_VectorsRam[14] = pendablesrvreq_isr;
    2a78:	4b10      	ldr	r3, [pc, #64]	; (2abc <configure_systick+0x44>)
    2a7a:	4a11      	ldr	r2, [pc, #68]	; (2ac0 <configure_systick+0x48>)
    2a7c:	639a      	str	r2, [r3, #56]	; 0x38
	_VectorsRam[15] = systick_isr;
    2a7e:	4a11      	ldr	r2, [pc, #68]	; (2ac4 <configure_systick+0x4c>)
    2a80:	63da      	str	r2, [r3, #60]	; 0x3c
	SYST_RVR = (SYSTICK_EXT_FREQ / 1000) - 1;
    2a82:	2263      	movs	r2, #99	; 0x63
    2a84:	4b10      	ldr	r3, [pc, #64]	; (2ac8 <configure_systick+0x50>)
    2a86:	601a      	str	r2, [r3, #0]
	SYST_CVR = 0;
    2a88:	2200      	movs	r2, #0
    2a8a:	3304      	adds	r3, #4
    2a8c:	601a      	str	r2, [r3, #0]
	SYST_CSR = SYST_CSR_TICKINT | SYST_CSR_ENABLE;
    2a8e:	2203      	movs	r2, #3
    2a90:	3b08      	subs	r3, #8
    2a92:	601a      	str	r2, [r3, #0]
	SCB_SHPR3 = 0x20200000;  // Systick, pendablesrvreq_isr = priority 32;
    2a94:	4a0d      	ldr	r2, [pc, #52]	; (2acc <configure_systick+0x54>)
    2a96:	f503 6351 	add.w	r3, r3, #3344	; 0xd10
    2a9a:	601a      	str	r2, [r3, #0]
	ARM_DEMCR |= ARM_DEMCR_TRCENA;
    2a9c:	4a0c      	ldr	r2, [pc, #48]	; (2ad0 <configure_systick+0x58>)
    2a9e:	6813      	ldr	r3, [r2, #0]
    2aa0:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    2aa4:	6013      	str	r3, [r2, #0]
	ARM_DWT_CTRL |= ARM_DWT_CTRL_CYCCNTENA; // turn on cycle counter
    2aa6:	4a0b      	ldr	r2, [pc, #44]	; (2ad4 <configure_systick+0x5c>)
    2aa8:	6813      	ldr	r3, [r2, #0]
    2aaa:	f043 0301 	orr.w	r3, r3, #1
    2aae:	6013      	str	r3, [r2, #0]
	systick_cycle_count = ARM_DWT_CYCCNT; // compiled 0, corrected w/1st systick
    2ab0:	4b09      	ldr	r3, [pc, #36]	; (2ad8 <configure_systick+0x60>)
    2ab2:	681a      	ldr	r2, [r3, #0]
    2ab4:	4b09      	ldr	r3, [pc, #36]	; (2adc <configure_systick+0x64>)
    2ab6:	601a      	str	r2, [r3, #0]
    2ab8:	4770      	bx	lr
    2aba:	bf00      	nop
    2abc:	20001800 	.word	0x20001800
    2ac0:	00003e19 	.word	0x00003e19
    2ac4:	00003e21 	.word	0x00003e21
    2ac8:	e000e014 	.word	0xe000e014
    2acc:	20200000 	.word	0x20200000
    2ad0:	e000edfc 	.word	0xe000edfc
    2ad4:	e0001000 	.word	0xe0001000
    2ad8:	e0001004 	.word	0xe0001004
    2adc:	200013cc 	.word	0x200013cc

00002ae0 <unused_interrupt_vector>:
//  R0
// Code from :: https://community.nxp.com/thread/389002
__attribute__((naked))
void unused_interrupt_vector(void)
{
  __asm( ".syntax unified\n"
    2ae0:	2004      	movs	r0, #4
    2ae2:	4671      	mov	r1, lr
    2ae4:	4208      	tst	r0, r1
    2ae6:	d003      	beq.n	2af0 <_MSP>
    2ae8:	f3ef 8009 	mrs	r0, PSP
    2aec:	f000 b808 	b.w	2b00 <HardFault_HandlerC>

00002af0 <_MSP>:
    2af0:	f3ef 8008 	mrs	r0, MSP
    2af4:	f000 b804 	b.w	2b00 <HardFault_HandlerC>

00002af8 <startup_default_early_hook>:
extern void __libc_init_array(void); // C++ standard library

uint8_t external_psram_size = 0;

extern int main (void);
void startup_default_early_hook(void) {}
    2af8:	4770      	bx	lr
    2afa:	bf00      	nop

00002afc <startup_default_late_hook>:
void startup_early_hook(void)		__attribute__ ((weak, alias("startup_default_early_hook")));
void startup_default_late_hook(void) {}
    2afc:	4770      	bx	lr
    2afe:	bf00      	nop

00002b00 <HardFault_HandlerC>:
         ".syntax divided\n") ;
}

__attribute__((weak))
void HardFault_HandlerC(unsigned int *hardfault_args)
{
    2b00:	b500      	push	{lr}
    2b02:	b083      	sub	sp, #12
  printf(" _AFSR ::  %x\n", _AFSR);
  printf(" _BFAR ::  %x\n", _BFAR);
  printf(" _MMAR ::  %x\n", _MMAR);
#endif

  IOMUXC_SW_MUX_CTL_PAD_GPIO_B0_03 = 5; // pin 13
    2b04:	4b1b      	ldr	r3, [pc, #108]	; (2b74 <HardFault_HandlerC+0x74>)
    2b06:	2205      	movs	r2, #5
    2b08:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
  IOMUXC_SW_PAD_CTL_PAD_GPIO_B0_03 = IOMUXC_PAD_DSE(7);
    2b0c:	2238      	movs	r2, #56	; 0x38
    2b0e:	f8c3 2338 	str.w	r2, [r3, #824]	; 0x338
  GPIO2_GDIR |= (1 << 3);
    2b12:	f5a3 3370 	sub.w	r3, r3, #245760	; 0x3c000
    2b16:	685a      	ldr	r2, [r3, #4]
    2b18:	f042 0208 	orr.w	r2, r2, #8
    2b1c:	605a      	str	r2, [r3, #4]
  GPIO2_DR_SET = (1 << 3);
    2b1e:	2208      	movs	r2, #8
    2b20:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
  GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2b24:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88

  if ( F_CPU_ACTUAL >= 600000000 )
    2b28:	4b13      	ldr	r3, [pc, #76]	; (2b78 <HardFault_HandlerC+0x78>)
    2b2a:	681a      	ldr	r2, [r3, #0]
    2b2c:	4b13      	ldr	r3, [pc, #76]	; (2b7c <HardFault_HandlerC+0x7c>)
    2b2e:	429a      	cmp	r2, r3
    2b30:	d902      	bls.n	2b38 <HardFault_HandlerC+0x38>
    set_arm_clock(300000000);
    2b32:	4813      	ldr	r0, [pc, #76]	; (2b80 <HardFault_HandlerC+0x80>)
    2b34:	f7ff fd6a 	bl	260c <set_arm_clock>

  while (1)
  {
    GPIO2_DR_SET = (1 << 3); //digitalWrite(13, HIGH);
    2b38:	2208      	movs	r2, #8
    2b3a:	4b12      	ldr	r3, [pc, #72]	; (2b84 <HardFault_HandlerC+0x84>)
    2b3c:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    // digitalWrite(13, HIGH);
    for (nn = 0; nn < 2000000/2; nn++) ;
    2b40:	2300      	movs	r3, #0
    2b42:	9301      	str	r3, [sp, #4]
    2b44:	e002      	b.n	2b4c <HardFault_HandlerC+0x4c>
    2b46:	9b01      	ldr	r3, [sp, #4]
    2b48:	3301      	adds	r3, #1
    2b4a:	9301      	str	r3, [sp, #4]
    2b4c:	9a01      	ldr	r2, [sp, #4]
    2b4e:	4b0e      	ldr	r3, [pc, #56]	; (2b88 <HardFault_HandlerC+0x88>)
    2b50:	429a      	cmp	r2, r3
    2b52:	d9f8      	bls.n	2b46 <HardFault_HandlerC+0x46>
    GPIO2_DR_CLEAR = (1 << 3); //digitalWrite(13, LOW);
    2b54:	2208      	movs	r2, #8
    2b56:	4b0b      	ldr	r3, [pc, #44]	; (2b84 <HardFault_HandlerC+0x84>)
    2b58:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    // digitalWrite(13, LOW);
    for (nn = 0; nn < 18000000/2; nn++) ;
    2b5c:	2300      	movs	r3, #0
    2b5e:	9301      	str	r3, [sp, #4]
    2b60:	e002      	b.n	2b68 <HardFault_HandlerC+0x68>
    2b62:	9b01      	ldr	r3, [sp, #4]
    2b64:	3301      	adds	r3, #1
    2b66:	9301      	str	r3, [sp, #4]
    2b68:	9a01      	ldr	r2, [sp, #4]
    2b6a:	4b08      	ldr	r3, [pc, #32]	; (2b8c <HardFault_HandlerC+0x8c>)
    2b6c:	429a      	cmp	r2, r3
    2b6e:	d9f8      	bls.n	2b62 <HardFault_HandlerC+0x62>
    2b70:	e7e2      	b.n	2b38 <HardFault_HandlerC+0x38>
    2b72:	bf00      	nop
    2b74:	401f8000 	.word	0x401f8000
    2b78:	20000710 	.word	0x20000710
    2b7c:	23c345ff 	.word	0x23c345ff
    2b80:	11e1a300 	.word	0x11e1a300
    2b84:	401bc000 	.word	0x401bc000
    2b88:	000f423f 	.word	0x000f423f
    2b8c:	0089543f 	.word	0x0089543f

00002b90 <_sbrk>:
extern unsigned long _heap_end;

char *__brkval = (char *)&_heap_start;

void * _sbrk(int incr)
{
    2b90:	b508      	push	{r3, lr}
        char *prev = __brkval;
    2b92:	4b0a      	ldr	r3, [pc, #40]	; (2bbc <_sbrk+0x2c>)
    2b94:	681b      	ldr	r3, [r3, #0]
        if (incr != 0) {
    2b96:	b170      	cbz	r0, 2bb6 <_sbrk+0x26>
                if (prev + incr > (char *)&_heap_end) {
    2b98:	1818      	adds	r0, r3, r0
    2b9a:	4a09      	ldr	r2, [pc, #36]	; (2bc0 <_sbrk+0x30>)
    2b9c:	4290      	cmp	r0, r2
    2b9e:	d906      	bls.n	2bae <_sbrk+0x1e>
                        errno = ENOMEM;
    2ba0:	f001 fa4e 	bl	4040 <__errno>
    2ba4:	230c      	movs	r3, #12
    2ba6:	6003      	str	r3, [r0, #0]
                        return (void *)-1;
    2ba8:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    2bac:	bd08      	pop	{r3, pc}
                }
                __brkval = prev + incr;
    2bae:	4a03      	ldr	r2, [pc, #12]	; (2bbc <_sbrk+0x2c>)
    2bb0:	6010      	str	r0, [r2, #0]
        }
        return prev;
    2bb2:	4618      	mov	r0, r3
    2bb4:	bd08      	pop	{r3, pc}
    2bb6:	4618      	mov	r0, r3
}
    2bb8:	bd08      	pop	{r3, pc}
    2bba:	bf00      	nop
    2bbc:	20000714 	.word	0x20000714
    2bc0:	20280000 	.word	0x20280000

00002bc4 <__cxa_pure_virtual>:
}

__attribute__((weak))
void __cxa_pure_virtual()
{
	while (1) asm ("WFI");
    2bc4:	bf30      	wfi
    2bc6:	e7fd      	b.n	2bc4 <__cxa_pure_virtual>

00002bc8 <Panic_Temp_isr>:

static uint32_t s_hotTemp, s_hotCount, s_roomC_hotC;
static float s_hot_ROOM;

void Panic_Temp_isr(void) {
  __disable_irq();
    2bc8:	b672      	cpsid	i
  IOMUXC_GPR_GPR16 = 0x00000007;
    2bca:	2207      	movs	r2, #7
    2bcc:	4b05      	ldr	r3, [pc, #20]	; (2be4 <Panic_Temp_isr+0x1c>)
    2bce:	641a      	str	r2, [r3, #64]	; 0x40
  SNVS_LPCR |= SNVS_LPCR_TOP; //Switch off now
    2bd0:	4a05      	ldr	r2, [pc, #20]	; (2be8 <Panic_Temp_isr+0x20>)
    2bd2:	6b93      	ldr	r3, [r2, #56]	; 0x38
    2bd4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    2bd8:	6393      	str	r3, [r2, #56]	; 0x38
  asm volatile ("dsb":::"memory");
    2bda:	f3bf 8f4f 	dsb	sy
  while (1) asm ("wfi");
    2bde:	bf30      	wfi
    2be0:	e7fd      	b.n	2bde <Panic_Temp_isr+0x16>
    2be2:	bf00      	nop
    2be4:	400ac000 	.word	0x400ac000
    2be8:	400d4000 	.word	0x400d4000

00002bec <endpoint0_transmit>:
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
}

static void endpoint0_transmit(const void *data, uint32_t len, int notify)
{
    2bec:	b410      	push	{r4}
	//printf("tx %lu\n", len);
	if (len > 0) {
    2bee:	b321      	cbz	r1, 2c3a <endpoint0_transmit+0x4e>
    2bf0:	460c      	mov	r4, r1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    2bf2:	4b25      	ldr	r3, [pc, #148]	; (2c88 <endpoint0_transmit+0x9c>)
    2bf4:	2101      	movs	r1, #1
    2bf6:	6019      	str	r1, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2bf8:	0424      	lsls	r4, r4, #16
    2bfa:	f044 0480 	orr.w	r4, r4, #128	; 0x80
    2bfe:	605c      	str	r4, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    2c00:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    2c02:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
    2c06:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    2c08:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
    2c0c:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    2c0e:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
    2c12:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    2c14:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    2c18:	6198      	str	r0, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_data;
    2c1a:	491c      	ldr	r1, [pc, #112]	; (2c8c <endpoint0_transmit+0xa0>)
    2c1c:	648b      	str	r3, [r1, #72]	; 0x48
		endpoint_queue_head[1].status = 0;
    2c1e:	2300      	movs	r3, #0
    2c20:	64cb      	str	r3, [r1, #76]	; 0x4c
		USB1_ENDPTPRIME |= (1<<16);
    2c22:	491b      	ldr	r1, [pc, #108]	; (2c90 <endpoint0_transmit+0xa4>)
    2c24:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    2c28:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
    2c2c:	f8c1 31b0 	str.w	r3, [r1, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    2c30:	4b17      	ldr	r3, [pc, #92]	; (2c90 <endpoint0_transmit+0xa4>)
    2c32:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    2c36:	2b00      	cmp	r3, #0
    2c38:	d1fa      	bne.n	2c30 <endpoint0_transmit+0x44>
	}
	endpoint0_transfer_ack.next = 1;
    2c3a:	2101      	movs	r1, #1
    2c3c:	4b15      	ldr	r3, [pc, #84]	; (2c94 <endpoint0_transmit+0xa8>)
    2c3e:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2c40:	b112      	cbz	r2, 2c48 <endpoint0_transmit+0x5c>
    2c42:	f248 0180 	movw	r1, #32896	; 0x8080
    2c46:	e000      	b.n	2c4a <endpoint0_transmit+0x5e>
    2c48:	2180      	movs	r1, #128	; 0x80
    2c4a:	4b12      	ldr	r3, [pc, #72]	; (2c94 <endpoint0_transmit+0xa8>)
    2c4c:	6059      	str	r1, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
    2c4e:	2000      	movs	r0, #0
    2c50:	6098      	str	r0, [r3, #8]
	endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_ack;
    2c52:	490e      	ldr	r1, [pc, #56]	; (2c8c <endpoint0_transmit+0xa0>)
    2c54:	608b      	str	r3, [r1, #8]
	endpoint_queue_head[0].status = 0;
    2c56:	60c8      	str	r0, [r1, #12]
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    2c58:	4b0d      	ldr	r3, [pc, #52]	; (2c90 <endpoint0_transmit+0xa4>)
    2c5a:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    2c5e:	f8c3 11bc 	str.w	r1, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<0);
    2c62:	f8d3 11b0 	ldr.w	r1, [r3, #432]	; 0x1b0
    2c66:	f041 0101 	orr.w	r1, r1, #1
    2c6a:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 0) : 0);
    2c6e:	1a12      	subs	r2, r2, r0
    2c70:	bf18      	it	ne
    2c72:	2201      	movne	r2, #1
    2c74:	4b08      	ldr	r3, [pc, #32]	; (2c98 <endpoint0_transmit+0xac>)
    2c76:	601a      	str	r2, [r3, #0]
	while (USB1_ENDPTPRIME) ;
    2c78:	4b05      	ldr	r3, [pc, #20]	; (2c90 <endpoint0_transmit+0xa4>)
    2c7a:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    2c7e:	2b00      	cmp	r3, #0
    2c80:	d1fa      	bne.n	2c78 <endpoint0_transmit+0x8c>
}
    2c82:	f85d 4b04 	ldr.w	r4, [sp], #4
    2c86:	4770      	bx	lr
    2c88:	20002000 	.word	0x20002000
    2c8c:	20003000 	.word	0x20003000
    2c90:	402e0000 	.word	0x402e0000
    2c94:	20002020 	.word	0x20002020
    2c98:	200013fc 	.word	0x200013fc

00002c9c <endpoint0_receive>:

static void endpoint0_receive(void *data, uint32_t len, int notify)
{
    2c9c:	b410      	push	{r4}
	//printf("rx %lu\n", len);
	if (len > 0) {
    2c9e:	b321      	cbz	r1, 2cea <endpoint0_receive+0x4e>
    2ca0:	460c      	mov	r4, r1
		// Executing A Transfer Descriptor, page 3182
		endpoint0_transfer_data.next = 1;
    2ca2:	4b26      	ldr	r3, [pc, #152]	; (2d3c <endpoint0_receive+0xa0>)
    2ca4:	2101      	movs	r1, #1
    2ca6:	6019      	str	r1, [r3, #0]
		endpoint0_transfer_data.status = (len << 16) | (1<<7);
    2ca8:	0424      	lsls	r4, r4, #16
    2caa:	f044 0480 	orr.w	r4, r4, #128	; 0x80
    2cae:	605c      	str	r4, [r3, #4]
		uint32_t addr = (uint32_t)data;
		endpoint0_transfer_data.pointer0 = addr; // format: table 55-60, pg 3159
    2cb0:	6098      	str	r0, [r3, #8]
		endpoint0_transfer_data.pointer1 = addr + 4096;
    2cb2:	f500 5180 	add.w	r1, r0, #4096	; 0x1000
    2cb6:	60d9      	str	r1, [r3, #12]
		endpoint0_transfer_data.pointer2 = addr + 8192;
    2cb8:	f500 5100 	add.w	r1, r0, #8192	; 0x2000
    2cbc:	6119      	str	r1, [r3, #16]
		endpoint0_transfer_data.pointer3 = addr + 12288;
    2cbe:	f500 5140 	add.w	r1, r0, #12288	; 0x3000
    2cc2:	6159      	str	r1, [r3, #20]
		endpoint0_transfer_data.pointer4 = addr + 16384;
    2cc4:	f500 4080 	add.w	r0, r0, #16384	; 0x4000
    2cc8:	6198      	str	r0, [r3, #24]
		//  Case 1: Link list is empty, page 3182
		endpoint_queue_head[0].next = (uint32_t)&endpoint0_transfer_data;
    2cca:	491d      	ldr	r1, [pc, #116]	; (2d40 <endpoint0_receive+0xa4>)
    2ccc:	608b      	str	r3, [r1, #8]
		endpoint_queue_head[0].status = 0;
    2cce:	2300      	movs	r3, #0
    2cd0:	60cb      	str	r3, [r1, #12]
		USB1_ENDPTPRIME |= (1<<0);
    2cd2:	491c      	ldr	r1, [pc, #112]	; (2d44 <endpoint0_receive+0xa8>)
    2cd4:	f8d1 31b0 	ldr.w	r3, [r1, #432]	; 0x1b0
    2cd8:	f043 0301 	orr.w	r3, r3, #1
    2cdc:	f8c1 31b0 	str.w	r3, [r1, #432]	; 0x1b0
		while (USB1_ENDPTPRIME) ;
    2ce0:	4b18      	ldr	r3, [pc, #96]	; (2d44 <endpoint0_receive+0xa8>)
    2ce2:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    2ce6:	2b00      	cmp	r3, #0
    2ce8:	d1fa      	bne.n	2ce0 <endpoint0_receive+0x44>
	}
	endpoint0_transfer_ack.next = 1;
    2cea:	2101      	movs	r1, #1
    2cec:	4b16      	ldr	r3, [pc, #88]	; (2d48 <endpoint0_receive+0xac>)
    2cee:	6019      	str	r1, [r3, #0]
	endpoint0_transfer_ack.status = (1<<7) | (notify ? (1 << 15) : 0);
    2cf0:	b112      	cbz	r2, 2cf8 <endpoint0_receive+0x5c>
    2cf2:	f248 0180 	movw	r1, #32896	; 0x8080
    2cf6:	e000      	b.n	2cfa <endpoint0_receive+0x5e>
    2cf8:	2180      	movs	r1, #128	; 0x80
    2cfa:	4b13      	ldr	r3, [pc, #76]	; (2d48 <endpoint0_receive+0xac>)
    2cfc:	6059      	str	r1, [r3, #4]
	endpoint0_transfer_ack.pointer0 = 0;
    2cfe:	2000      	movs	r0, #0
    2d00:	6098      	str	r0, [r3, #8]
	endpoint_queue_head[1].next = (uint32_t)&endpoint0_transfer_ack;
    2d02:	490f      	ldr	r1, [pc, #60]	; (2d40 <endpoint0_receive+0xa4>)
    2d04:	648b      	str	r3, [r1, #72]	; 0x48
	endpoint_queue_head[1].status = 0;
    2d06:	64c8      	str	r0, [r1, #76]	; 0x4c
	USB1_ENDPTCOMPLETE = (1<<0) | (1<<16);
    2d08:	4b0e      	ldr	r3, [pc, #56]	; (2d44 <endpoint0_receive+0xa8>)
    2d0a:	f04f 1101 	mov.w	r1, #65537	; 0x10001
    2d0e:	f8c3 11bc 	str.w	r1, [r3, #444]	; 0x1bc
	USB1_ENDPTPRIME |= (1<<16);
    2d12:	f8d3 11b0 	ldr.w	r1, [r3, #432]	; 0x1b0
    2d16:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
    2d1a:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
	endpoint0_notify_mask = (notify ? (1 << 16) : 0);
    2d1e:	b112      	cbz	r2, 2d26 <endpoint0_receive+0x8a>
    2d20:	f44f 3280 	mov.w	r2, #65536	; 0x10000
    2d24:	e000      	b.n	2d28 <endpoint0_receive+0x8c>
    2d26:	2200      	movs	r2, #0
    2d28:	4b08      	ldr	r3, [pc, #32]	; (2d4c <endpoint0_receive+0xb0>)
    2d2a:	601a      	str	r2, [r3, #0]
	while (USB1_ENDPTPRIME) ;
    2d2c:	4b05      	ldr	r3, [pc, #20]	; (2d44 <endpoint0_receive+0xa8>)
    2d2e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    2d32:	2b00      	cmp	r3, #0
    2d34:	d1fa      	bne.n	2d2c <endpoint0_receive+0x90>
}
    2d36:	f85d 4b04 	ldr.w	r4, [sp], #4
    2d3a:	4770      	bx	lr
    2d3c:	20002000 	.word	0x20002000
    2d40:	20003000 	.word	0x20003000
    2d44:	402e0000 	.word	0x402e0000
    2d48:	20002020 	.word	0x20002020
    2d4c:	200013fc 	.word	0x200013fc

00002d50 <schedule_transfer>:
	}
}
#endif

static void schedule_transfer(endpoint_t *endpoint, uint32_t epmask, transfer_t *transfer)
{
    2d50:	b430      	push	{r4, r5}
	// when we stop at 6, why is the last transfer missing from the USB output?
	//if (transfer_log_count >= 6) return;

	//uint32_t ret = (*(const uint8_t *)transfer->pointer0) << 8;
	if (endpoint->callback_function) {
    2d52:	6b83      	ldr	r3, [r0, #56]	; 0x38
    2d54:	b11b      	cbz	r3, 2d5e <schedule_transfer+0xe>
		transfer->status |= (1<<15);
    2d56:	6853      	ldr	r3, [r2, #4]
    2d58:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    2d5c:	6053      	str	r3, [r2, #4]
	}
	__disable_irq();
    2d5e:	b672      	cpsid	i
	//digitalWriteFast(1, HIGH);
	// Executing A Transfer Descriptor, page 2468 (RT1060 manual, Rev 1, 12/2018)
	transfer_t *last = endpoint->last_transfer;
    2d60:	6b43      	ldr	r3, [r0, #52]	; 0x34
	if (last) {
    2d62:	b1eb      	cbz	r3, 2da0 <schedule_transfer+0x50>
		last->next = (uint32_t)transfer;
    2d64:	601a      	str	r2, [r3, #0]
		if (USB1_ENDPTPRIME & epmask) goto end;
    2d66:	4b15      	ldr	r3, [pc, #84]	; (2dbc <schedule_transfer+0x6c>)
    2d68:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    2d6c:	420b      	tst	r3, r1
    2d6e:	d121      	bne.n	2db4 <schedule_transfer+0x64>
		//digitalWriteFast(2, HIGH);
		//ret |= 0x01;
		uint32_t status, cyccnt=ARM_DWT_CYCCNT;
    2d70:	4b13      	ldr	r3, [pc, #76]	; (2dc0 <schedule_transfer+0x70>)
    2d72:	681d      	ldr	r5, [r3, #0]
		do {
			USB1_USBCMD |= USB_USBCMD_ATDTW;
    2d74:	4b11      	ldr	r3, [pc, #68]	; (2dbc <schedule_transfer+0x6c>)
    2d76:	f8d3 4140 	ldr.w	r4, [r3, #320]	; 0x140
    2d7a:	f444 4480 	orr.w	r4, r4, #16384	; 0x4000
    2d7e:	f8c3 4140 	str.w	r4, [r3, #320]	; 0x140
			status = USB1_ENDPTSTATUS;
    2d82:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		} while (!(USB1_USBCMD & USB_USBCMD_ATDTW) && (ARM_DWT_CYCCNT - cyccnt < 2400));
    2d86:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
    2d8a:	f413 4f80 	tst.w	r3, #16384	; 0x4000
    2d8e:	d105      	bne.n	2d9c <schedule_transfer+0x4c>
    2d90:	4b0b      	ldr	r3, [pc, #44]	; (2dc0 <schedule_transfer+0x70>)
    2d92:	681b      	ldr	r3, [r3, #0]
    2d94:	1b5b      	subs	r3, r3, r5
    2d96:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
    2d9a:	d3eb      	bcc.n	2d74 <schedule_transfer+0x24>
		//USB1_USBCMD &= ~USB_USBCMD_ATDTW;
		if (status & epmask) goto end;
    2d9c:	4221      	tst	r1, r4
    2d9e:	d109      	bne.n	2db4 <schedule_transfer+0x64>
		//ret |= 0x02;
	}
	//digitalWriteFast(4, HIGH);
	endpoint->next = (uint32_t)transfer;
    2da0:	6082      	str	r2, [r0, #8]
	endpoint->status = 0;
    2da2:	2300      	movs	r3, #0
    2da4:	60c3      	str	r3, [r0, #12]
	USB1_ENDPTPRIME |= epmask;
    2da6:	4c05      	ldr	r4, [pc, #20]	; (2dbc <schedule_transfer+0x6c>)
    2da8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
    2dac:	4319      	orrs	r1, r3
    2dae:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
	endpoint->first_transfer = transfer;
    2db2:	6302      	str	r2, [r0, #48]	; 0x30
end:
	endpoint->last_transfer = transfer;
    2db4:	6342      	str	r2, [r0, #52]	; 0x34
	__enable_irq();
    2db6:	b662      	cpsie	i
	//digitalWriteFast(2, LOW);
	//digitalWriteFast(1, LOW);
	//if (transfer_log_head > LOG_SIZE) transfer_log_head = 0;
	//transfer_log[transfer_log_head++] = ret;
	//transfer_log_count++;
}
    2db8:	bc30      	pop	{r4, r5}
    2dba:	4770      	bx	lr
    2dbc:	402e0000 	.word	0x402e0000
    2dc0:	e0001004 	.word	0xe0001004

00002dc4 <run_callbacks>:
	void (*callback_function)(transfer_t *completed_transfer);
	uint32_t unused1;
};*/

static void run_callbacks(endpoint_t *ep)
{
    2dc4:	b570      	push	{r4, r5, r6, lr}
    2dc6:	4606      	mov	r6, r0
	//printf("run_callbacks\n");
	transfer_t *first = ep->first_transfer;
    2dc8:	6b00      	ldr	r0, [r0, #48]	; 0x30
	if (first == NULL) return;
    2dca:	b1b0      	cbz	r0, 2dfa <run_callbacks+0x36>
    2dcc:	4603      	mov	r3, r0
    2dce:	2400      	movs	r4, #0

	// count how many transfers are completed, then remove them from the endpoint's list
	uint32_t count = 0;
	transfer_t *t = first;
	while (1) {
		if (t->status & (1<<7)) {
    2dd0:	685a      	ldr	r2, [r3, #4]
    2dd2:	f012 0f80 	tst.w	r2, #128	; 0x80
    2dd6:	d001      	beq.n	2ddc <run_callbacks+0x18>
			// found a still-active transfer, new list begins here
			//printf(" still active\n");
			ep->first_transfer = t;
    2dd8:	6333      	str	r3, [r6, #48]	; 0x30
			break;
    2dda:	e00c      	b.n	2df6 <run_callbacks+0x32>
		}
		count++;
    2ddc:	3401      	adds	r4, #1
		t = (transfer_t *)t->next;
    2dde:	681b      	ldr	r3, [r3, #0]
		if ((uint32_t)t == 1) {
    2de0:	2b01      	cmp	r3, #1
    2de2:	d1f5      	bne.n	2dd0 <run_callbacks+0xc>
			// reached end of list, all need callbacks, new list is empty
			//printf(" end of list\n");
			ep->first_transfer = NULL;
    2de4:	2300      	movs	r3, #0
    2de6:	6333      	str	r3, [r6, #48]	; 0x30
			ep->last_transfer = NULL;
    2de8:	6373      	str	r3, [r6, #52]	; 0x34
			break;
    2dea:	e004      	b.n	2df6 <run_callbacks+0x32>
		}
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
    2dec:	6805      	ldr	r5, [r0, #0]
		ep->callback_function(first);
    2dee:	6bb3      	ldr	r3, [r6, #56]	; 0x38
    2df0:	4798      	blx	r3
		first = next;
		count--;
    2df2:	3c01      	subs	r4, #1
	}
	// do all the callbacks
	while (count) {
		transfer_t *next = (transfer_t *)first->next;
		ep->callback_function(first);
		first = next;
    2df4:	4628      	mov	r0, r5
			ep->last_transfer = NULL;
			break;
		}
	}
	// do all the callbacks
	while (count) {
    2df6:	2c00      	cmp	r4, #0
    2df8:	d1f8      	bne.n	2dec <run_callbacks+0x28>
    2dfa:	bd70      	pop	{r4, r5, r6, pc}

00002dfc <usb_endpoint_config>:
	}
#endif
}

static void usb_endpoint_config(endpoint_t *qh, uint32_t config, void (*callback)(transfer_t *))
{
    2dfc:	b570      	push	{r4, r5, r6, lr}
    2dfe:	4604      	mov	r4, r0
    2e00:	460e      	mov	r6, r1
    2e02:	4615      	mov	r5, r2
	memset(qh, 0, sizeof(endpoint_t));
    2e04:	2240      	movs	r2, #64	; 0x40
    2e06:	2100      	movs	r1, #0
    2e08:	f001 fc08 	bl	461c <memset>
	qh->config = config;
    2e0c:	6026      	str	r6, [r4, #0]
	qh->next = 1; // Terminate bit = 1
    2e0e:	2301      	movs	r3, #1
    2e10:	60a3      	str	r3, [r4, #8]
	qh->callback_function = callback;
    2e12:	63a5      	str	r5, [r4, #56]	; 0x38
    2e14:	bd70      	pop	{r4, r5, r6, pc}
    2e16:	bf00      	nop

00002e18 <endpoint0_setup>:
*/

static uint8_t reply_buffer[8];

static void endpoint0_setup(uint64_t setupdata)
{
    2e18:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    2e1a:	4604      	mov	r4, r0
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    2e1c:	b283      	uxth	r3, r0
    2e1e:	f240 6281 	movw	r2, #1665	; 0x681
    2e22:	4293      	cmp	r3, r2
    2e24:	d817      	bhi.n	2e56 <endpoint0_setup+0x3e>
    2e26:	4605      	mov	r5, r0
    2e28:	460e      	mov	r6, r1
    2e2a:	f5b3 6fd0 	cmp.w	r3, #1664	; 0x680
    2e2e:	f080 810e 	bcs.w	304e <endpoint0_setup+0x236>
    2e32:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
    2e36:	f000 809a 	beq.w	2f6e <endpoint0_setup+0x156>
    2e3a:	d804      	bhi.n	2e46 <endpoint0_setup+0x2e>
    2e3c:	2b80      	cmp	r3, #128	; 0x80
    2e3e:	d04e      	beq.n	2ede <endpoint0_setup+0xc6>
    2e40:	2b82      	cmp	r3, #130	; 0x82
    2e42:	d054      	beq.n	2eee <endpoint0_setup+0xd6>
    2e44:	e124      	b.n	3090 <endpoint0_setup+0x278>
    2e46:	f240 3202 	movw	r2, #770	; 0x302
    2e4a:	4293      	cmp	r3, r2
    2e4c:	d070      	beq.n	2f30 <endpoint0_setup+0x118>
    2e4e:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
    2e52:	d018      	beq.n	2e86 <endpoint0_setup+0x6e>
    2e54:	e11c      	b.n	3090 <endpoint0_setup+0x278>
    2e56:	f242 0221 	movw	r2, #8225	; 0x2021
    2e5a:	4293      	cmp	r3, r2
    2e5c:	f000 810c 	beq.w	3078 <endpoint0_setup+0x260>
    2e60:	d806      	bhi.n	2e70 <endpoint0_setup+0x58>
    2e62:	f5b3 6f08 	cmp.w	r3, #2176	; 0x880
    2e66:	d031      	beq.n	2ecc <endpoint0_setup+0xb4>
    2e68:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
    2e6c:	d018      	beq.n	2ea0 <endpoint0_setup+0x88>
    2e6e:	e10f      	b.n	3090 <endpoint0_setup+0x278>
    2e70:	f242 2221 	movw	r2, #8737	; 0x2221
    2e74:	4293      	cmp	r3, r2
    2e76:	f000 80ef 	beq.w	3058 <endpoint0_setup+0x240>
    2e7a:	f242 3221 	movw	r2, #8993	; 0x2321
    2e7e:	4293      	cmp	r3, r2
    2e80:	f000 80f4 	beq.w	306c <endpoint0_setup+0x254>
    2e84:	e104      	b.n	3090 <endpoint0_setup+0x278>
	  case 0x0500: // SET_ADDRESS
		endpoint0_receive(NULL, 0, 0);
    2e86:	2200      	movs	r2, #0
    2e88:	4611      	mov	r1, r2
    2e8a:	4610      	mov	r0, r2
    2e8c:	f7ff ff06 	bl	2c9c <endpoint0_receive>
		USB1_DEVICEADDR = USB_DEVICEADDR_USBADR(setup.wValue) | USB_DEVICEADDR_USBADRA;
    2e90:	0c23      	lsrs	r3, r4, #16
    2e92:	065b      	lsls	r3, r3, #25
    2e94:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
    2e98:	4a80      	ldr	r2, [pc, #512]	; (309c <endpoint0_setup+0x284>)
    2e9a:	f8c2 3154 	str.w	r3, [r2, #340]	; 0x154
		return;
    2e9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0900: // SET_CONFIGURATION
		usb_configuration = setup.wValue;
    2ea0:	f3c0 4407 	ubfx	r4, r0, #16, #8
    2ea4:	4b7e      	ldr	r3, [pc, #504]	; (30a0 <endpoint0_setup+0x288>)
    2ea6:	701c      	strb	r4, [r3, #0]
		// configure all other endpoints
		#if defined(ENDPOINT2_CONFIG)
		USB1_ENDPTCTRL2 = ENDPOINT2_CONFIG;
    2ea8:	4b7c      	ldr	r3, [pc, #496]	; (309c <endpoint0_setup+0x284>)
    2eaa:	4a7e      	ldr	r2, [pc, #504]	; (30a4 <endpoint0_setup+0x28c>)
    2eac:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
		#endif
		#if defined(ENDPOINT3_CONFIG)
		USB1_ENDPTCTRL3 = ENDPOINT3_CONFIG;
    2eb0:	4a7d      	ldr	r2, [pc, #500]	; (30a8 <endpoint0_setup+0x290>)
    2eb2:	f8c3 21cc 	str.w	r2, [r3, #460]	; 0x1cc
		#endif
		#if defined(ENDPOINT4_CONFIG)
		USB1_ENDPTCTRL4 = ENDPOINT4_CONFIG;
    2eb6:	4a7d      	ldr	r2, [pc, #500]	; (30ac <endpoint0_setup+0x294>)
    2eb8:	f8c3 21d0 	str.w	r2, [r3, #464]	; 0x1d0
		#endif
		#if defined(ENDPOINT7_CONFIG)
		USB1_ENDPTCTRL7 = ENDPOINT7_CONFIG;
		#endif
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_configure();
    2ebc:	f000 fbec 	bl	3698 <usb_serial_configure>
		usb_midi_configure();
		#endif
		#if defined(AUDIO_INTERFACE)
		usb_audio_configure();
		#endif
		endpoint0_receive(NULL, 0, 0);
    2ec0:	2200      	movs	r2, #0
    2ec2:	4611      	mov	r1, r2
    2ec4:	4610      	mov	r0, r2
    2ec6:	f7ff fee9 	bl	2c9c <endpoint0_receive>
		return;
    2eca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0880: // GET_CONFIGURATION
		reply_buffer[0] = usb_configuration;
    2ecc:	4b74      	ldr	r3, [pc, #464]	; (30a0 <endpoint0_setup+0x288>)
    2ece:	781b      	ldrb	r3, [r3, #0]
    2ed0:	4877      	ldr	r0, [pc, #476]	; (30b0 <endpoint0_setup+0x298>)
    2ed2:	7003      	strb	r3, [r0, #0]
		endpoint0_transmit(reply_buffer, 1, 0);
    2ed4:	2200      	movs	r2, #0
    2ed6:	2101      	movs	r1, #1
    2ed8:	f7ff fe88 	bl	2bec <endpoint0_transmit>
		return;
    2edc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0080: // GET_STATUS (device)
		reply_buffer[0] = 0;
    2ede:	4874      	ldr	r0, [pc, #464]	; (30b0 <endpoint0_setup+0x298>)
    2ee0:	2200      	movs	r2, #0
    2ee2:	7002      	strb	r2, [r0, #0]
		reply_buffer[1] = 0;
    2ee4:	7042      	strb	r2, [r0, #1]
		endpoint0_transmit(reply_buffer, 2, 0);
    2ee6:	2102      	movs	r1, #2
    2ee8:	f7ff fe80 	bl	2bec <endpoint0_transmit>
		return;
    2eec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0082: // GET_STATUS (endpoint)
		endpoint = setup.wIndex & 0x7F;
    2eee:	b289      	uxth	r1, r1
    2ef0:	f001 037f 	and.w	r3, r1, #127	; 0x7f
		if (endpoint > 7) break;
    2ef4:	2b07      	cmp	r3, #7
    2ef6:	f200 80cb 	bhi.w	3090 <endpoint0_setup+0x278>
		dir = setup.wIndex & 0x80;
    2efa:	f001 0180 	and.w	r1, r1, #128	; 0x80
    2efe:	b289      	uxth	r1, r1
		ctrl = *((uint32_t *)&USB1_ENDPTCTRL0 + endpoint);
    2f00:	4a6c      	ldr	r2, [pc, #432]	; (30b4 <endpoint0_setup+0x29c>)
    2f02:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
		reply_buffer[0] = 0;
    2f06:	4b6a      	ldr	r3, [pc, #424]	; (30b0 <endpoint0_setup+0x298>)
    2f08:	2200      	movs	r2, #0
    2f0a:	701a      	strb	r2, [r3, #0]
		reply_buffer[1] = 0;
    2f0c:	705a      	strb	r2, [r3, #1]
		if ((dir && (ctrl & USB_ENDPTCTRL_TXS)) || (!dir && (ctrl & USB_ENDPTCTRL_RXS))) {
    2f0e:	b111      	cbz	r1, 2f16 <endpoint0_setup+0xfe>
    2f10:	f410 3f80 	tst.w	r0, #65536	; 0x10000
    2f14:	d103      	bne.n	2f1e <endpoint0_setup+0x106>
    2f16:	b929      	cbnz	r1, 2f24 <endpoint0_setup+0x10c>
    2f18:	f010 0f01 	tst.w	r0, #1
    2f1c:	d002      	beq.n	2f24 <endpoint0_setup+0x10c>
			reply_buffer[0] = 1;
    2f1e:	2201      	movs	r2, #1
    2f20:	4b63      	ldr	r3, [pc, #396]	; (30b0 <endpoint0_setup+0x298>)
    2f22:	701a      	strb	r2, [r3, #0]
		}
		endpoint0_transmit(reply_buffer, 2, 0);
    2f24:	2200      	movs	r2, #0
    2f26:	2102      	movs	r1, #2
    2f28:	4861      	ldr	r0, [pc, #388]	; (30b0 <endpoint0_setup+0x298>)
    2f2a:	f7ff fe5f 	bl	2bec <endpoint0_transmit>
		return;
    2f2e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0302: // SET_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    2f30:	b289      	uxth	r1, r1
    2f32:	f001 037f 	and.w	r3, r1, #127	; 0x7f
		if (endpoint > 7) break;
    2f36:	2b07      	cmp	r3, #7
    2f38:	f200 80aa 	bhi.w	3090 <endpoint0_setup+0x278>
		dir = setup.wIndex & 0x80;
		if (dir) {
    2f3c:	f001 0180 	and.w	r1, r1, #128	; 0x80
    2f40:	b289      	uxth	r1, r1
    2f42:	b139      	cbz	r1, 2f54 <endpoint0_setup+0x13c>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_TXS;
    2f44:	495b      	ldr	r1, [pc, #364]	; (30b4 <endpoint0_setup+0x29c>)
    2f46:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2f4a:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
    2f4e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    2f52:	e006      	b.n	2f62 <endpoint0_setup+0x14a>
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) |= USB_ENDPTCTRL_RXS;
    2f54:	4957      	ldr	r1, [pc, #348]	; (30b4 <endpoint0_setup+0x29c>)
    2f56:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2f5a:	f042 0201 	orr.w	r2, r2, #1
    2f5e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		}
		endpoint0_receive(NULL, 0, 0);
    2f62:	2200      	movs	r2, #0
    2f64:	4611      	mov	r1, r2
    2f66:	4610      	mov	r0, r2
    2f68:	f7ff fe98 	bl	2c9c <endpoint0_receive>
		return;
    2f6c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0102: // CLEAR_FEATURE (endpoint)
		endpoint = setup.wIndex & 0x7F;
    2f6e:	b289      	uxth	r1, r1
    2f70:	f001 037f 	and.w	r3, r1, #127	; 0x7f
		if (endpoint > 7) break;
    2f74:	2b07      	cmp	r3, #7
    2f76:	f200 808b 	bhi.w	3090 <endpoint0_setup+0x278>
		dir = setup.wIndex & 0x80;
		if (dir) {
    2f7a:	f001 0180 	and.w	r1, r1, #128	; 0x80
    2f7e:	b289      	uxth	r1, r1
    2f80:	b139      	cbz	r1, 2f92 <endpoint0_setup+0x17a>
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_TXS;
    2f82:	494c      	ldr	r1, [pc, #304]	; (30b4 <endpoint0_setup+0x29c>)
    2f84:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2f88:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
    2f8c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    2f90:	e006      	b.n	2fa0 <endpoint0_setup+0x188>
		} else {
			*((volatile uint32_t *)&USB1_ENDPTCTRL0 + endpoint) &= ~USB_ENDPTCTRL_RXS;
    2f92:	4948      	ldr	r1, [pc, #288]	; (30b4 <endpoint0_setup+0x29c>)
    2f94:	f851 2023 	ldr.w	r2, [r1, r3, lsl #2]
    2f98:	f022 0201 	bic.w	r2, r2, #1
    2f9c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		}
		endpoint0_receive(NULL, 0, 0);
    2fa0:	2200      	movs	r2, #0
    2fa2:	4611      	mov	r1, r2
    2fa4:	4610      	mov	r0, r2
    2fa6:	f7ff fe79 	bl	2c9c <endpoint0_receive>
		return;
    2faa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
			if (setup.wValue == list->wValue && setup.wIndex == list->wIndex) {
    2fac:	0c2a      	lsrs	r2, r5, #16
    2fae:	881c      	ldrh	r4, [r3, #0]
    2fb0:	42a2      	cmp	r2, r4
    2fb2:	d14a      	bne.n	304a <endpoint0_setup+0x232>
    2fb4:	b2b4      	uxth	r4, r6
    2fb6:	885f      	ldrh	r7, [r3, #2]
    2fb8:	42bc      	cmp	r4, r7
    2fba:	d146      	bne.n	304a <endpoint0_setup+0x232>
				uint32_t datalen;
				if ((setup.wValue >> 8) == 3) {
    2fbc:	0a14      	lsrs	r4, r2, #8
    2fbe:	2c03      	cmp	r4, #3
    2fc0:	d101      	bne.n	2fc6 <endpoint0_setup+0x1ae>
					// for string descriptors, use the descriptor's
					// length field, allowing runtime configured length.
					datalen = *(list->addr);
    2fc2:	7803      	ldrb	r3, [r0, #0]
    2fc4:	e000      	b.n	2fc8 <endpoint0_setup+0x1b0>
				} else {
					datalen = list->length;
    2fc6:	891b      	ldrh	r3, [r3, #8]
				}
				if (datalen > setup.wLength) datalen = setup.wLength;
    2fc8:	0c0c      	lsrs	r4, r1, #16
    2fca:	42a3      	cmp	r3, r4
    2fcc:	d800      	bhi.n	2fd0 <endpoint0_setup+0x1b8>
    2fce:	461c      	mov	r4, r3

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
    2fd0:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    2fd4:	d10c      	bne.n	2ff0 <endpoint0_setup+0x1d8>
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
    2fd6:	4b38      	ldr	r3, [pc, #224]	; (30b8 <endpoint0_setup+0x2a0>)
    2fd8:	781b      	ldrb	r3, [r3, #0]
    2fda:	f013 0fff 	tst.w	r3, #255	; 0xff
    2fde:	d101      	bne.n	2fe4 <endpoint0_setup+0x1cc>
				if (datalen > setup.wLength) datalen = setup.wLength;

				// copy the descriptor, from PROGMEM to DMAMEM
				if (setup.wValue == 0x200) {
					// config descriptor needs to adapt to speed
					const uint8_t *src = usb_config_descriptor_12;
    2fe0:	4936      	ldr	r1, [pc, #216]	; (30bc <endpoint0_setup+0x2a4>)
    2fe2:	e000      	b.n	2fe6 <endpoint0_setup+0x1ce>
					if (usb_high_speed) src = usb_config_descriptor_480;
    2fe4:	4936      	ldr	r1, [pc, #216]	; (30c0 <endpoint0_setup+0x2a8>)
					memcpy(usb_descriptor_buffer, src, datalen);
    2fe6:	4622      	mov	r2, r4
    2fe8:	4836      	ldr	r0, [pc, #216]	; (30c4 <endpoint0_setup+0x2ac>)
    2fea:	f7ff fa75 	bl	24d8 <memcpy>
    2fee:	e017      	b.n	3020 <endpoint0_setup+0x208>
				} else if (setup.wValue == 0x700) {
    2ff0:	f5b2 6fe0 	cmp.w	r2, #1792	; 0x700
    2ff4:	d10f      	bne.n	3016 <endpoint0_setup+0x1fe>
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
					if (usb_high_speed) src = usb_config_descriptor_12;
    2ff6:	4b30      	ldr	r3, [pc, #192]	; (30b8 <endpoint0_setup+0x2a0>)
    2ff8:	781b      	ldrb	r3, [r3, #0]
    2ffa:	f013 0fff 	tst.w	r3, #255	; 0xff
    2ffe:	d101      	bne.n	3004 <endpoint0_setup+0x1ec>
					const uint8_t *src = usb_config_descriptor_12;
					if (usb_high_speed) src = usb_config_descriptor_480;
					memcpy(usb_descriptor_buffer, src, datalen);
				} else if (setup.wValue == 0x700) {
					// other speed config also needs to adapt
					const uint8_t *src = usb_config_descriptor_480;
    3000:	492f      	ldr	r1, [pc, #188]	; (30c0 <endpoint0_setup+0x2a8>)
    3002:	e000      	b.n	3006 <endpoint0_setup+0x1ee>
					if (usb_high_speed) src = usb_config_descriptor_12;
    3004:	492d      	ldr	r1, [pc, #180]	; (30bc <endpoint0_setup+0x2a4>)
					memcpy(usb_descriptor_buffer, src, datalen);
    3006:	4d2f      	ldr	r5, [pc, #188]	; (30c4 <endpoint0_setup+0x2ac>)
    3008:	4622      	mov	r2, r4
    300a:	4628      	mov	r0, r5
    300c:	f7ff fa64 	bl	24d8 <memcpy>
					usb_descriptor_buffer[1] = 7;
    3010:	2307      	movs	r3, #7
    3012:	706b      	strb	r3, [r5, #1]
    3014:	e004      	b.n	3020 <endpoint0_setup+0x208>
				} else {
					memcpy(usb_descriptor_buffer, list->addr, datalen);
    3016:	4622      	mov	r2, r4
    3018:	4601      	mov	r1, r0
    301a:	482a      	ldr	r0, [pc, #168]	; (30c4 <endpoint0_setup+0x2ac>)
    301c:	f7ff fa5c 	bl	24d8 <memcpy>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    3020:	4928      	ldr	r1, [pc, #160]	; (30c4 <endpoint0_setup+0x2ac>)
    3022:	f021 031f 	bic.w	r3, r1, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3026:	4421      	add	r1, r4
	asm volatile("": : :"memory");
	asm("dsb");
    3028:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    302c:	4a26      	ldr	r2, [pc, #152]	; (30c8 <endpoint0_setup+0x2b0>)
    302e:	6013      	str	r3, [r2, #0]
		location += 32;
    3030:	3320      	adds	r3, #32
	} while (location < end_addr);
    3032:	4299      	cmp	r1, r3
    3034:	d8fa      	bhi.n	302c <endpoint0_setup+0x214>
	asm("dsb");
    3036:	f3bf 8f4f 	dsb	sy
	asm("isb");
    303a:	f3bf 8f6f 	isb	sy
				}
				// prep transmit
				arm_dcache_flush_delete(usb_descriptor_buffer, datalen);
				endpoint0_transmit(usb_descriptor_buffer, datalen, 0);
    303e:	2200      	movs	r2, #0
    3040:	4621      	mov	r1, r4
    3042:	4820      	ldr	r0, [pc, #128]	; (30c4 <endpoint0_setup+0x2ac>)
    3044:	f7ff fdd2 	bl	2bec <endpoint0_transmit>
				return;
    3048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    304a:	330c      	adds	r3, #12
    304c:	e000      	b.n	3050 <endpoint0_setup+0x238>
	setup_t setup;
	uint32_t endpoint, dir, ctrl;
	const usb_descriptor_list_t *list;

	setup.bothwords = setupdata;
	switch (setup.wRequestAndType) {
    304e:	4b1f      	ldr	r3, [pc, #124]	; (30cc <endpoint0_setup+0x2b4>)
		}
		endpoint0_receive(NULL, 0, 0);
		return;
	  case 0x0680: // GET_DESCRIPTOR
	  case 0x0681:
		for (list = usb_descriptor_list; list->addr != NULL; list++) {
    3050:	6858      	ldr	r0, [r3, #4]
    3052:	2800      	cmp	r0, #0
    3054:	d1aa      	bne.n	2fac <endpoint0_setup+0x194>
    3056:	e01b      	b.n	3090 <endpoint0_setup+0x278>
		}
		break;
#if defined(CDC_STATUS_INTERFACE)
	  case 0x2221: // CDC_SET_CONTROL_LINE_STATE
		#ifdef CDC_STATUS_INTERFACE
		if (setup.wIndex == CDC_STATUS_INTERFACE) {
    3058:	b289      	uxth	r1, r1
    305a:	b939      	cbnz	r1, 306c <endpoint0_setup+0x254>
			usb_cdc_line_rtsdtr_millis = systick_millis_count;
    305c:	4b1c      	ldr	r3, [pc, #112]	; (30d0 <endpoint0_setup+0x2b8>)
    305e:	681a      	ldr	r2, [r3, #0]
    3060:	4b1c      	ldr	r3, [pc, #112]	; (30d4 <endpoint0_setup+0x2bc>)
    3062:	601a      	str	r2, [r3, #0]
			usb_cdc_line_rtsdtr = setup.wValue;
    3064:	f3c0 4407 	ubfx	r4, r0, #16, #8
    3068:	4b1b      	ldr	r3, [pc, #108]	; (30d8 <endpoint0_setup+0x2c0>)
    306a:	701c      	strb	r4, [r3, #0]
			usb_cdc3_line_rtsdtr = setup.wValue;
		}
		#endif
		// fall through to next case, to always send ZLP ACK
	  case 0x2321: // CDC_SEND_BREAK
		endpoint0_receive(NULL, 0, 0);
    306c:	2200      	movs	r2, #0
    306e:	4611      	mov	r1, r2
    3070:	4610      	mov	r0, r2
    3072:	f7ff fe13 	bl	2c9c <endpoint0_receive>
		return;
    3076:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	  case 0x2021: // CDC_SET_LINE_CODING
		if (setup.wLength != 7) break;
    3078:	0c0b      	lsrs	r3, r1, #16
    307a:	2b07      	cmp	r3, #7
    307c:	d108      	bne.n	3090 <endpoint0_setup+0x278>
		endpoint0_setupdata.bothwords = setupdata;
    307e:	4b17      	ldr	r3, [pc, #92]	; (30dc <endpoint0_setup+0x2c4>)
    3080:	6018      	str	r0, [r3, #0]
    3082:	6059      	str	r1, [r3, #4]
		endpoint0_receive(endpoint0_buffer, 7, 1);
    3084:	2201      	movs	r2, #1
    3086:	2107      	movs	r1, #7
    3088:	4815      	ldr	r0, [pc, #84]	; (30e0 <endpoint0_setup+0x2c8>)
    308a:	f7ff fe07 	bl	2c9c <endpoint0_receive>
		return;
    308e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			return;
		}
		break;
#endif
	}
	USB1_ENDPTCTRL0 = 0x000010001; // stall
    3090:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    3094:	4b01      	ldr	r3, [pc, #4]	; (309c <endpoint0_setup+0x284>)
    3096:	f8c3 21c0 	str.w	r2, [r3, #448]	; 0x1c0
    309a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    309c:	402e0000 	.word	0x402e0000
    30a0:	20001420 	.word	0x20001420
    30a4:	00cc0002 	.word	0x00cc0002
    30a8:	000200c8 	.word	0x000200c8
    30ac:	00c80002 	.word	0x00c80002
    30b0:	20001410 	.word	0x20001410
    30b4:	402e01c0 	.word	0x402e01c0
    30b8:	200013f8 	.word	0x200013f8
    30bc:	600017d4 	.word	0x600017d4
    30c0:	60001818 	.word	0x60001818
    30c4:	20200c40 	.word	0x20200c40
    30c8:	e000ef70 	.word	0xe000ef70
    30cc:	200005a4 	.word	0x200005a4
    30d0:	200013d4 	.word	0x200013d4
    30d4:	20003288 	.word	0x20003288
    30d8:	200015f4 	.word	0x200015f4
    30dc:	20001408 	.word	0x20001408
    30e0:	20001418 	.word	0x20001418

000030e4 <usb_start_sof_interrupts>:
}


void usb_start_sof_interrupts(int interface)
{
	__disable_irq();
    30e4:	b672      	cpsid	i
	sof_usage |= (1 << interface);
    30e6:	2301      	movs	r3, #1
    30e8:	fa03 f000 	lsl.w	r0, r3, r0
    30ec:	4b09      	ldr	r3, [pc, #36]	; (3114 <usb_start_sof_interrupts+0x30>)
    30ee:	781a      	ldrb	r2, [r3, #0]
    30f0:	4310      	orrs	r0, r2
    30f2:	7018      	strb	r0, [r3, #0]
	uint32_t intr = USB1_USBINTR;
    30f4:	4b08      	ldr	r3, [pc, #32]	; (3118 <usb_start_sof_interrupts+0x34>)
    30f6:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
	if (!(intr & USB_USBINTR_SRE)) {
    30fa:	f013 0f80 	tst.w	r3, #128	; 0x80
    30fe:	d106      	bne.n	310e <usb_start_sof_interrupts+0x2a>
		USB1_USBSTS = USB_USBSTS_SRI; // clear prior SOF before SOF IRQ enable
    3100:	4a05      	ldr	r2, [pc, #20]	; (3118 <usb_start_sof_interrupts+0x34>)
    3102:	2180      	movs	r1, #128	; 0x80
    3104:	f8c2 1144 	str.w	r1, [r2, #324]	; 0x144
		USB1_USBINTR = intr | USB_USBINTR_SRE;
    3108:	430b      	orrs	r3, r1
    310a:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
	}
	__enable_irq();
    310e:	b662      	cpsie	i
    3110:	4770      	bx	lr
    3112:	bf00      	nop
    3114:	200013f0 	.word	0x200013f0
    3118:	402e0000 	.word	0x402e0000

0000311c <endpoint0_complete>:
	uint64_t bothwords;
} setup_t; */


static void endpoint0_complete(void)
{
    311c:	b508      	push	{r3, lr}
	setup_t setup;

	setup.bothwords = endpoint0_setupdata.bothwords;
    311e:	4a0d      	ldr	r2, [pc, #52]	; (3154 <endpoint0_complete+0x38>)
    3120:	6813      	ldr	r3, [r2, #0]
    3122:	6852      	ldr	r2, [r2, #4]
	//printf("complete %x %x %x\n", setup.word1, setup.word2, endpoint0_buffer[0]);
#ifdef CDC_STATUS_INTERFACE
	// 0x2021 is CDC_SET_LINE_CODING
	if (setup.wRequestAndType == 0x2021 && setup.wIndex == CDC_STATUS_INTERFACE) {
    3124:	b29b      	uxth	r3, r3
    3126:	f242 0121 	movw	r1, #8225	; 0x2021
    312a:	428b      	cmp	r3, r1
    312c:	d111      	bne.n	3152 <endpoint0_complete+0x36>
    312e:	b292      	uxth	r2, r2
    3130:	b97a      	cbnz	r2, 3152 <endpoint0_complete+0x36>
		memcpy(usb_cdc_line_coding, endpoint0_buffer, 7);
    3132:	4b09      	ldr	r3, [pc, #36]	; (3158 <endpoint0_complete+0x3c>)
    3134:	4a09      	ldr	r2, [pc, #36]	; (315c <endpoint0_complete+0x40>)
    3136:	e892 0003 	ldmia.w	r2, {r0, r1}
    313a:	6018      	str	r0, [r3, #0]
    313c:	8099      	strh	r1, [r3, #4]
    313e:	0c09      	lsrs	r1, r1, #16
    3140:	7199      	strb	r1, [r3, #6]
		printf("usb_cdc_line_coding, baud=%u\n", usb_cdc_line_coding[0]);
		if (usb_cdc_line_coding[0] == 134) {
    3142:	2886      	cmp	r0, #134	; 0x86
    3144:	d105      	bne.n	3152 <endpoint0_complete+0x36>
			usb_start_sof_interrupts(NUM_INTERFACE);
    3146:	2002      	movs	r0, #2
    3148:	f7ff ffcc 	bl	30e4 <usb_start_sof_interrupts>
			usb_reboot_timer = 80; // TODO: 10 if only 12 Mbit/sec
    314c:	2250      	movs	r2, #80	; 0x50
    314e:	4b04      	ldr	r3, [pc, #16]	; (3160 <endpoint0_complete+0x44>)
    3150:	701a      	strb	r2, [r3, #0]
    3152:	bd08      	pop	{r3, pc}
    3154:	20001408 	.word	0x20001408
    3158:	20003280 	.word	0x20003280
    315c:	20001418 	.word	0x20001418
    3160:	20001400 	.word	0x20001400

00003164 <usb_stop_sof_interrupts>:
	__enable_irq();
}

void usb_stop_sof_interrupts(int interface)
{
	sof_usage &= ~(1 << interface);
    3164:	2301      	movs	r3, #1
    3166:	fa03 f000 	lsl.w	r0, r3, r0
    316a:	4a07      	ldr	r2, [pc, #28]	; (3188 <usb_stop_sof_interrupts+0x24>)
    316c:	7813      	ldrb	r3, [r2, #0]
    316e:	ea23 0000 	bic.w	r0, r3, r0
    3172:	7010      	strb	r0, [r2, #0]
	if (sof_usage == 0) {
    3174:	b930      	cbnz	r0, 3184 <usb_stop_sof_interrupts+0x20>
		USB1_USBINTR &= ~USB_USBINTR_SRE;
    3176:	4a05      	ldr	r2, [pc, #20]	; (318c <usb_stop_sof_interrupts+0x28>)
    3178:	f8d2 3148 	ldr.w	r3, [r2, #328]	; 0x148
    317c:	f023 0380 	bic.w	r3, r3, #128	; 0x80
    3180:	f8c2 3148 	str.w	r3, [r2, #328]	; 0x148
    3184:	4770      	bx	lr
    3186:	bf00      	nop
    3188:	200013f0 	.word	0x200013f0
    318c:	402e0000 	.word	0x402e0000

00003190 <isr>:
	//USB1_PORTSC1 |= USB_PORTSC1_PFSC; // force 12 Mbit/sec
}


static void isr(void)
{
    3190:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	//printf("*");

	//  Port control in device mode is only used for
	//  status port reset, suspend, and current connect status.
	uint32_t status = USB1_USBSTS;
    3192:	4b61      	ldr	r3, [pc, #388]	; (3318 <isr+0x188>)
    3194:	f8d3 4144 	ldr.w	r4, [r3, #324]	; 0x144
	USB1_USBSTS = status;
    3198:	f8c3 4144 	str.w	r4, [r3, #324]	; 0x144

	// USB_USBSTS_SLI - set to 1 when enters a suspend state from an active state
	// USB_USBSTS_SRI - set at start of frame
	// USB_USBSTS_SRI - set when USB reset detected

	if (status & USB_USBSTS_UI) {
    319c:	f014 0f01 	tst.w	r4, #1
    31a0:	d068      	beq.n	3274 <isr+0xe4>
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
    31a2:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    31a6:	e02a      	b.n	31fe <isr+0x6e>
			USB1_ENDPTSETUPSTAT = setupstatus;
    31a8:	4a5b      	ldr	r2, [pc, #364]	; (3318 <isr+0x188>)
    31aa:	f8c2 31ac 	str.w	r3, [r2, #428]	; 0x1ac
			setup_t s;
			do {
				USB1_USBCMD |= USB_USBCMD_SUTW;
    31ae:	4b5a      	ldr	r3, [pc, #360]	; (3318 <isr+0x188>)
    31b0:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
    31b4:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
    31b8:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
				s.word1 = endpoint_queue_head[0].setup0;
    31bc:	4a57      	ldr	r2, [pc, #348]	; (331c <isr+0x18c>)
    31be:	6a90      	ldr	r0, [r2, #40]	; 0x28
				s.word2 = endpoint_queue_head[0].setup1;
    31c0:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
			} while (!(USB1_USBCMD & USB_USBCMD_SUTW));
    31c2:	f8d3 3140 	ldr.w	r3, [r3, #320]	; 0x140
    31c6:	f413 5f00 	tst.w	r3, #8192	; 0x2000
    31ca:	d0f0      	beq.n	31ae <isr+0x1e>
			USB1_USBCMD &= ~USB_USBCMD_SUTW;
    31cc:	4b52      	ldr	r3, [pc, #328]	; (3318 <isr+0x188>)
    31ce:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
    31d2:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
    31d6:	f8c3 2140 	str.w	r2, [r3, #320]	; 0x140
			//printf("setup %08lX %08lX\n", s.word1, s.word2);
			USB1_ENDPTFLUSH = (1<<16) | (1<<0); // page 3174
    31da:	f04f 1201 	mov.w	r2, #65537	; 0x10001
    31de:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
    31e2:	4b4d      	ldr	r3, [pc, #308]	; (3318 <isr+0x188>)
    31e4:	f8d3 31b4 	ldr.w	r3, [r3, #436]	; 0x1b4
    31e8:	f013 1f01 	tst.w	r3, #65537	; 0x10001
    31ec:	d1f9      	bne.n	31e2 <isr+0x52>
			endpoint0_notify_mask = 0;
    31ee:	2200      	movs	r2, #0
    31f0:	4b4b      	ldr	r3, [pc, #300]	; (3320 <isr+0x190>)
    31f2:	601a      	str	r2, [r3, #0]
			endpoint0_setup(s.bothwords);
    31f4:	f7ff fe10 	bl	2e18 <endpoint0_setup>
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
    31f8:	4b47      	ldr	r3, [pc, #284]	; (3318 <isr+0x188>)
    31fa:	f8d3 31ac 	ldr.w	r3, [r3, #428]	; 0x1ac

	if (status & USB_USBSTS_UI) {
		//printf("data\n");
		uint32_t setupstatus = USB1_ENDPTSETUPSTAT;
		//printf("USB1_ENDPTSETUPSTAT=%X\n", setupstatus);
		while (setupstatus) {
    31fe:	2b00      	cmp	r3, #0
    3200:	d1d2      	bne.n	31a8 <isr+0x18>
			while (USB1_ENDPTFLUSH & ((1<<16) | (1<<0))) ;
			endpoint0_notify_mask = 0;
			endpoint0_setup(s.bothwords);
			setupstatus = USB1_ENDPTSETUPSTAT; // page 3175
		}
		uint32_t completestatus = USB1_ENDPTCOMPLETE;
    3202:	4b45      	ldr	r3, [pc, #276]	; (3318 <isr+0x188>)
    3204:	f8d3 51bc 	ldr.w	r5, [r3, #444]	; 0x1bc
		if (completestatus) {
    3208:	2d00      	cmp	r5, #0
    320a:	d033      	beq.n	3274 <isr+0xe4>
			USB1_ENDPTCOMPLETE = completestatus;
    320c:	f8c3 51bc 	str.w	r5, [r3, #444]	; 0x1bc
			//printf("USB1_ENDPTCOMPLETE=%lX\n", completestatus);
			if (completestatus & endpoint0_notify_mask) {
    3210:	4b43      	ldr	r3, [pc, #268]	; (3320 <isr+0x190>)
    3212:	681b      	ldr	r3, [r3, #0]
    3214:	421d      	tst	r5, r3
    3216:	d004      	beq.n	3222 <isr+0x92>
				endpoint0_notify_mask = 0;
    3218:	2200      	movs	r2, #0
    321a:	4b41      	ldr	r3, [pc, #260]	; (3320 <isr+0x190>)
    321c:	601a      	str	r2, [r3, #0]
				endpoint0_complete();
    321e:	f7ff ff7d 	bl	311c <endpoint0_complete>
			}
			completestatus &= endpointN_notify_mask;
    3222:	4b40      	ldr	r3, [pc, #256]	; (3324 <isr+0x194>)
    3224:	681e      	ldr	r6, [r3, #0]
#if 1
			if (completestatus) {
    3226:	402e      	ands	r6, r5
    3228:	d024      	beq.n	3274 <isr+0xe4>

				// transmit:
				uint32_t tx = completestatus >> 16;
    322a:	0c37      	lsrs	r7, r6, #16
				while (tx) {
    322c:	e00e      	b.n	324c <isr+0xbc>
					int p=__builtin_ctz(tx);
    322e:	fa97 f5a7 	rbit	r5, r7
    3232:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2 + 1);
    3236:	01eb      	lsls	r3, r5, #7
    3238:	3340      	adds	r3, #64	; 0x40
    323a:	4838      	ldr	r0, [pc, #224]	; (331c <isr+0x18c>)
    323c:	4418      	add	r0, r3
    323e:	f7ff fdc1 	bl	2dc4 <run_callbacks>
					tx &= ~(1<<p);
    3242:	2301      	movs	r3, #1
    3244:	fa03 f505 	lsl.w	r5, r3, r5
    3248:	ea27 0705 	bic.w	r7, r7, r5
#if 1
			if (completestatus) {

				// transmit:
				uint32_t tx = completestatus >> 16;
				while (tx) {
    324c:	2f00      	cmp	r7, #0
    324e:	d1ee      	bne.n	322e <isr+0x9e>
					run_callbacks(endpoint_queue_head + p * 2 + 1);
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
    3250:	b2b6      	uxth	r6, r6
				while(rx) {
    3252:	e00d      	b.n	3270 <isr+0xe0>
					int p=__builtin_ctz(rx);
    3254:	fa96 f5a6 	rbit	r5, r6
    3258:	fab5 f585 	clz	r5, r5
					run_callbacks(endpoint_queue_head + p * 2);
    325c:	482f      	ldr	r0, [pc, #188]	; (331c <isr+0x18c>)
    325e:	eb00 10c5 	add.w	r0, r0, r5, lsl #7
    3262:	f7ff fdaf 	bl	2dc4 <run_callbacks>
					rx &= ~(1<<p);
    3266:	2301      	movs	r3, #1
    3268:	fa03 f505 	lsl.w	r5, r3, r5
    326c:	ea26 0605 	bic.w	r6, r6, r5
					tx &= ~(1<<p);
				}

				// receive:
				uint32_t rx = completestatus & 0xffff;
				while(rx) {
    3270:	2e00      	cmp	r6, #0
    3272:	d1ef      	bne.n	3254 <isr+0xc4>
			}
#endif

		}
	}
	if (status & USB_USBSTS_URI) { // page 3164
    3274:	f014 0f40 	tst.w	r4, #64	; 0x40
    3278:	d019      	beq.n	32ae <isr+0x11e>
		USB1_ENDPTSETUPSTAT = USB1_ENDPTSETUPSTAT; // Clear all setup token semaphores
    327a:	4b27      	ldr	r3, [pc, #156]	; (3318 <isr+0x188>)
    327c:	f8d3 21ac 	ldr.w	r2, [r3, #428]	; 0x1ac
    3280:	f8c3 21ac 	str.w	r2, [r3, #428]	; 0x1ac
		USB1_ENDPTCOMPLETE = USB1_ENDPTCOMPLETE; // Clear all the endpoint complete status
    3284:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
    3288:	f8c3 21bc 	str.w	r2, [r3, #444]	; 0x1bc
		while (USB1_ENDPTPRIME != 0) ; // Wait for any endpoint priming
    328c:	4b22      	ldr	r3, [pc, #136]	; (3318 <isr+0x188>)
    328e:	f8d3 31b0 	ldr.w	r3, [r3, #432]	; 0x1b0
    3292:	2b00      	cmp	r3, #0
    3294:	d1fa      	bne.n	328c <isr+0xfc>
		USB1_ENDPTFLUSH = 0xFFFFFFFF;  // Cancel all endpoint primed status
    3296:	4b20      	ldr	r3, [pc, #128]	; (3318 <isr+0x188>)
    3298:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
    329c:	f8c3 21b4 	str.w	r2, [r3, #436]	; 0x1b4
		if ((USB1_PORTSC1 & USB_PORTSC1_PR)) {
    32a0:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
			// we took too long to respond :(
			// TODO; is this ever really a problem?
			//printf("reset too slow\n");
		}
		#if defined(CDC_STATUS_INTERFACE) && defined(CDC_DATA_INTERFACE)
		usb_serial_reset();
    32a4:	f000 f9f6 	bl	3694 <usb_serial_reset>
		#endif
		endpointN_notify_mask = 0;
    32a8:	2200      	movs	r2, #0
    32aa:	4b1e      	ldr	r3, [pc, #120]	; (3324 <isr+0x194>)
    32ac:	601a      	str	r2, [r3, #0]
			// shut off USB - easier to see results in protocol analyzer
			//USB1_USBCMD &= ~USB_USBCMD_RS;
			//printf("shut off USB\n");
		//}
	}
	if (status & USB_USBSTS_TI0) {
    32ae:	f014 7f80 	tst.w	r4, #16777216	; 0x1000000
    32b2:	d003      	beq.n	32bc <isr+0x12c>
		if (usb_timer0_callback != NULL) usb_timer0_callback();
    32b4:	4b1c      	ldr	r3, [pc, #112]	; (3328 <isr+0x198>)
    32b6:	681b      	ldr	r3, [r3, #0]
    32b8:	b103      	cbz	r3, 32bc <isr+0x12c>
    32ba:	4798      	blx	r3
	}
	if (status & USB_USBSTS_TI1) {
    32bc:	f014 7f00 	tst.w	r4, #33554432	; 0x2000000
    32c0:	d003      	beq.n	32ca <isr+0x13a>
		if (usb_timer1_callback != NULL) usb_timer1_callback();
    32c2:	4b1a      	ldr	r3, [pc, #104]	; (332c <isr+0x19c>)
    32c4:	681b      	ldr	r3, [r3, #0]
    32c6:	b103      	cbz	r3, 32ca <isr+0x13a>
    32c8:	4798      	blx	r3
	}
	if (status & USB_USBSTS_PCI) {
    32ca:	f014 0f04 	tst.w	r4, #4
    32ce:	d00c      	beq.n	32ea <isr+0x15a>
		if (USB1_PORTSC1 & USB_PORTSC1_HSP) {
    32d0:	4b11      	ldr	r3, [pc, #68]	; (3318 <isr+0x188>)
    32d2:	f8d3 3184 	ldr.w	r3, [r3, #388]	; 0x184
    32d6:	f413 7f00 	tst.w	r3, #512	; 0x200
    32da:	d003      	beq.n	32e4 <isr+0x154>
			//printf("port at 480 Mbit\n");
			usb_high_speed = 1;
    32dc:	2201      	movs	r2, #1
    32de:	4b14      	ldr	r3, [pc, #80]	; (3330 <isr+0x1a0>)
    32e0:	701a      	strb	r2, [r3, #0]
    32e2:	e002      	b.n	32ea <isr+0x15a>
		} else {
			//printf("port at 12 Mbit\n");
			usb_high_speed = 0;
    32e4:	2200      	movs	r2, #0
    32e6:	4b12      	ldr	r3, [pc, #72]	; (3330 <isr+0x1a0>)
    32e8:	701a      	strb	r2, [r3, #0]
		//printf("suspend\n");
	}
	if (status & USB_USBSTS_UEI) {
		//printf("error\n");
	}
	if ((USB1_USBINTR & USB_USBINTR_SRE) && (status & USB_USBSTS_SRI)) {
    32ea:	4b0b      	ldr	r3, [pc, #44]	; (3318 <isr+0x188>)
    32ec:	f8d3 3148 	ldr.w	r3, [r3, #328]	; 0x148
    32f0:	f013 0f80 	tst.w	r3, #128	; 0x80
    32f4:	d00e      	beq.n	3314 <isr+0x184>
    32f6:	f014 0f80 	tst.w	r4, #128	; 0x80
    32fa:	d00b      	beq.n	3314 <isr+0x184>
		//printf("sof %d\n", usb_reboot_timer);
		if (usb_reboot_timer) {
    32fc:	4b0d      	ldr	r3, [pc, #52]	; (3334 <isr+0x1a4>)
    32fe:	781b      	ldrb	r3, [r3, #0]
    3300:	b143      	cbz	r3, 3314 <isr+0x184>
			if (--usb_reboot_timer == 0) {
    3302:	3b01      	subs	r3, #1
    3304:	b2db      	uxtb	r3, r3
    3306:	4a0b      	ldr	r2, [pc, #44]	; (3334 <isr+0x1a4>)
    3308:	7013      	strb	r3, [r2, #0]
    330a:	b91b      	cbnz	r3, 3314 <isr+0x184>
				usb_stop_sof_interrupts(NUM_INTERFACE);
    330c:	2002      	movs	r0, #2
    330e:	f7ff ff29 	bl	3164 <usb_stop_sof_interrupts>
				asm("bkpt #251"); // run bootloader
    3312:	befb      	bkpt	0x00fb
    3314:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3316:	bf00      	nop
    3318:	402e0000 	.word	0x402e0000
    331c:	20003000 	.word	0x20003000
    3320:	200013fc 	.word	0x200013fc
    3324:	200013ec 	.word	0x200013ec
    3328:	200013e8 	.word	0x200013e8
    332c:	200013f4 	.word	0x200013f4
    3330:	200013f8 	.word	0x200013f8
    3334:	20001400 	.word	0x20001400

00003338 <usb_config_rx>:
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    3338:	0409      	lsls	r1, r1, #16
    333a:	b10a      	cbz	r2, 3340 <usb_config_rx+0x8>
    333c:	2200      	movs	r2, #0
    333e:	e001      	b.n	3344 <usb_config_rx+0xc>
    3340:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    3344:	4311      	orrs	r1, r2
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    3346:	1e82      	subs	r2, r0, #2
    3348:	2a02      	cmp	r2, #2
    334a:	d810      	bhi.n	336e <usb_config_rx+0x36>
	qh->next = 1; // Terminate bit = 1
	qh->callback_function = callback;
}

void usb_config_rx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    334c:	b538      	push	{r3, r4, r5, lr}
    334e:	461d      	mov	r5, r3
    3350:	4604      	mov	r4, r0
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
    3352:	461a      	mov	r2, r3
    3354:	4806      	ldr	r0, [pc, #24]	; (3370 <usb_config_rx+0x38>)
    3356:	eb00 10c4 	add.w	r0, r0, r4, lsl #7
    335a:	f7ff fd4f 	bl	2dfc <usb_endpoint_config>
	if (cb) endpointN_notify_mask |= (1 << ep);
    335e:	b12d      	cbz	r5, 336c <usb_config_rx+0x34>
    3360:	2001      	movs	r0, #1
    3362:	40a0      	lsls	r0, r4
    3364:	4b03      	ldr	r3, [pc, #12]	; (3374 <usb_config_rx+0x3c>)
    3366:	681c      	ldr	r4, [r3, #0]
    3368:	4320      	orrs	r0, r4
    336a:	6018      	str	r0, [r3, #0]
    336c:	bd38      	pop	{r3, r4, r5, pc}
    336e:	4770      	bx	lr
    3370:	20003000 	.word	0x20003000
    3374:	200013ec 	.word	0x200013ec

00003378 <usb_config_tx>:
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
    3378:	0409      	lsls	r1, r1, #16
    337a:	b10a      	cbz	r2, 3380 <usb_config_tx+0x8>
    337c:	2200      	movs	r2, #0
    337e:	e001      	b.n	3384 <usb_config_tx+0xc>
    3380:	f04f 5200 	mov.w	r2, #536870912	; 0x20000000
    3384:	4311      	orrs	r1, r2
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
    3386:	1e82      	subs	r2, r0, #2
    3388:	2a02      	cmp	r2, #2
    338a:	d814      	bhi.n	33b6 <usb_config_tx+0x3e>
	usb_endpoint_config(endpoint_queue_head + ep * 2, config, cb);
	if (cb) endpointN_notify_mask |= (1 << ep);
}

void usb_config_tx(uint32_t ep, uint32_t packet_size, int do_zlp, void (*cb)(transfer_t *))
{
    338c:	b538      	push	{r3, r4, r5, lr}
    338e:	461d      	mov	r5, r3
    3390:	4604      	mov	r4, r0
	uint32_t config = (packet_size << 16) | (do_zlp ? 0 : (1 << 29));
	if (ep < 2 || ep > NUM_ENDPOINTS) return;
	usb_endpoint_config(endpoint_queue_head + ep * 2 + 1, config, cb);
    3392:	01c3      	lsls	r3, r0, #7
    3394:	3340      	adds	r3, #64	; 0x40
    3396:	462a      	mov	r2, r5
    3398:	4807      	ldr	r0, [pc, #28]	; (33b8 <usb_config_tx+0x40>)
    339a:	4418      	add	r0, r3
    339c:	f7ff fd2e 	bl	2dfc <usb_endpoint_config>
	if (cb) endpointN_notify_mask |= (1 << (ep + 16));
    33a0:	b145      	cbz	r5, 33b4 <usb_config_tx+0x3c>
    33a2:	f104 0010 	add.w	r0, r4, #16
    33a6:	2401      	movs	r4, #1
    33a8:	fa04 f000 	lsl.w	r0, r4, r0
    33ac:	4b03      	ldr	r3, [pc, #12]	; (33bc <usb_config_tx+0x44>)
    33ae:	681c      	ldr	r4, [r3, #0]
    33b0:	4320      	orrs	r0, r4
    33b2:	6018      	str	r0, [r3, #0]
    33b4:	bd38      	pop	{r3, r4, r5, pc}
    33b6:	4770      	bx	lr
    33b8:	20003000 	.word	0x20003000
    33bc:	200013ec 	.word	0x200013ec

000033c0 <usb_prepare_transfer>:
}



void usb_prepare_transfer(transfer_t *transfer, const void *data, uint32_t len, uint32_t param)
{
    33c0:	b410      	push	{r4}
	transfer->next = 1;
    33c2:	2401      	movs	r4, #1
    33c4:	6004      	str	r4, [r0, #0]
	transfer->status = (len << 16) | (1<<7);
    33c6:	0412      	lsls	r2, r2, #16
    33c8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
    33cc:	6042      	str	r2, [r0, #4]
	uint32_t addr = (uint32_t)data;
	transfer->pointer0 = addr;
    33ce:	6081      	str	r1, [r0, #8]
	transfer->pointer1 = addr + 4096;
    33d0:	f501 5280 	add.w	r2, r1, #4096	; 0x1000
    33d4:	60c2      	str	r2, [r0, #12]
	transfer->pointer2 = addr + 8192;
    33d6:	f501 5200 	add.w	r2, r1, #8192	; 0x2000
    33da:	6102      	str	r2, [r0, #16]
	transfer->pointer3 = addr + 12288;
    33dc:	f501 5240 	add.w	r2, r1, #12288	; 0x3000
    33e0:	6142      	str	r2, [r0, #20]
	transfer->pointer4 = addr + 16384;
    33e2:	f501 4180 	add.w	r1, r1, #16384	; 0x4000
    33e6:	6181      	str	r1, [r0, #24]
	transfer->callback_param = param;
    33e8:	61c3      	str	r3, [r0, #28]
}
    33ea:	f85d 4b04 	ldr.w	r4, [sp], #4
    33ee:	4770      	bx	lr

000033f0 <usb_transmit>:
		count--;
	}
}

void usb_transmit(int endpoint_number, transfer_t *transfer)
{
    33f0:	b508      	push	{r3, lr}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    33f2:	1e83      	subs	r3, r0, #2
    33f4:	2b02      	cmp	r3, #2
    33f6:	d809      	bhi.n	340c <usb_transmit+0x1c>
    33f8:	460a      	mov	r2, r1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2 + 1;
    33fa:	01c3      	lsls	r3, r0, #7
    33fc:	3340      	adds	r3, #64	; 0x40
	uint32_t mask = 1 << (endpoint_number + 16);
    33fe:	3010      	adds	r0, #16
	schedule_transfer(endpoint, mask, transfer);
    3400:	2101      	movs	r1, #1
    3402:	4081      	lsls	r1, r0
    3404:	4802      	ldr	r0, [pc, #8]	; (3410 <usb_transmit+0x20>)
    3406:	4418      	add	r0, r3
    3408:	f7ff fca2 	bl	2d50 <schedule_transfer>
    340c:	bd08      	pop	{r3, pc}
    340e:	bf00      	nop
    3410:	20003000 	.word	0x20003000

00003414 <usb_receive>:
}

void usb_receive(int endpoint_number, transfer_t *transfer)
{
    3414:	b508      	push	{r3, lr}
	if (endpoint_number < 2 || endpoint_number > NUM_ENDPOINTS) return;
    3416:	1e83      	subs	r3, r0, #2
    3418:	2b02      	cmp	r3, #2
    341a:	d807      	bhi.n	342c <usb_receive+0x18>
    341c:	460a      	mov	r2, r1
	endpoint_t *endpoint = endpoint_queue_head + endpoint_number * 2;
	uint32_t mask = 1 << endpoint_number;
	schedule_transfer(endpoint, mask, transfer);
    341e:	2101      	movs	r1, #1
    3420:	4081      	lsls	r1, r0
    3422:	4b03      	ldr	r3, [pc, #12]	; (3430 <usb_receive+0x1c>)
    3424:	eb03 10c0 	add.w	r0, r3, r0, lsl #7
    3428:	f7ff fc92 	bl	2d50 <schedule_transfer>
    342c:	bd08      	pop	{r3, pc}
    342e:	bf00      	nop
    3430:	20003000 	.word	0x20003000

00003434 <usb_transfer_status>:
		//if (!(cmd & USB_USBCMD_ATDTW)) continue;
		//if (status & 0x80) break; // for still active, only 1 reading needed
		//if (++count > 1) break; // for completed, check 10 times
	}
#else
	return transfer->status;
    3434:	6840      	ldr	r0, [r0, #4]
#endif
}
    3436:	4770      	bx	lr

00003438 <usb_init_serialnumber>:
	{'M','T','P'}
};
#endif

void usb_init_serialnumber(void)
{
    3438:	b500      	push	{lr}
    343a:	b085      	sub	sp, #20
	char buf[11];
	uint32_t i, num;

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
    343c:	4b11      	ldr	r3, [pc, #68]	; (3484 <usb_init_serialnumber+0x4c>)
    343e:	f8d3 0220 	ldr.w	r0, [r3, #544]	; 0x220
    3442:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
    3446:	4b10      	ldr	r3, [pc, #64]	; (3488 <usb_init_serialnumber+0x50>)
    3448:	4298      	cmp	r0, r3
    344a:	d802      	bhi.n	3452 <usb_init_serialnumber+0x1a>
    344c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
    3450:	0058      	lsls	r0, r3, #1
	ultoa(num, buf, 10);
    3452:	220a      	movs	r2, #10
    3454:	a901      	add	r1, sp, #4
    3456:	f000 fdc1 	bl	3fdc <ultoa>
	for (i=0; i<10; i++) {
    345a:	2300      	movs	r3, #0
    345c:	e009      	b.n	3472 <usb_init_serialnumber+0x3a>
		char c = buf[i];
    345e:	aa04      	add	r2, sp, #16
    3460:	441a      	add	r2, r3
    3462:	f812 1c0c 	ldrb.w	r1, [r2, #-12]
		if (!c) break;
    3466:	b131      	cbz	r1, 3476 <usb_init_serialnumber+0x3e>
		usb_string_serial_number_default.wString[i] = c;
    3468:	4a08      	ldr	r2, [pc, #32]	; (348c <usb_init_serialnumber+0x54>)
    346a:	eb02 0243 	add.w	r2, r2, r3, lsl #1
    346e:	8051      	strh	r1, [r2, #2]

	num = HW_OCOTP_MAC0 & 0xFFFFFF;
	// add extra zero to work around OS-X CDC-ACM driver bug
	if (num < 10000000) num = num * 10;
	ultoa(num, buf, 10);
	for (i=0; i<10; i++) {
    3470:	3301      	adds	r3, #1
    3472:	2b09      	cmp	r3, #9
    3474:	d9f3      	bls.n	345e <usb_init_serialnumber+0x26>
		char c = buf[i];
		if (!c) break;
		usb_string_serial_number_default.wString[i] = c;
	}
	usb_string_serial_number_default.bLength = i * 2 + 2;
    3476:	3301      	adds	r3, #1
    3478:	005b      	lsls	r3, r3, #1
    347a:	4a04      	ldr	r2, [pc, #16]	; (348c <usb_init_serialnumber+0x54>)
    347c:	7013      	strb	r3, [r2, #0]
}
    347e:	b005      	add	sp, #20
    3480:	f85d fb04 	ldr.w	pc, [sp], #4
    3484:	401f4400 	.word	0x401f4400
    3488:	0098967f 	.word	0x0098967f
    348c:	2000072c 	.word	0x2000072c

00003490 <timer_config>:
static void timer_start_oneshot();
static void timer_stop();

static void timer_config(void (*callback)(void), uint32_t microseconds)
{
	usb_timer0_callback = callback;
    3490:	4b07      	ldr	r3, [pc, #28]	; (34b0 <timer_config+0x20>)
    3492:	6018      	str	r0, [r3, #0]
	USB1_GPTIMER0CTRL = 0;
    3494:	4b07      	ldr	r3, [pc, #28]	; (34b4 <timer_config+0x24>)
    3496:	2200      	movs	r2, #0
    3498:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	USB1_GPTIMER0LD = microseconds - 1;
    349c:	3901      	subs	r1, #1
    349e:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
	USB1_USBINTR |= USB_USBINTR_TIE0;
    34a2:	f8d3 2148 	ldr.w	r2, [r3, #328]	; 0x148
    34a6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
    34aa:	f8c3 2148 	str.w	r2, [r3, #328]	; 0x148
    34ae:	4770      	bx	lr
    34b0:	200013e8 	.word	0x200013e8
    34b4:	402e0000 	.word	0x402e0000

000034b8 <timer_start_oneshot>:
}

static void timer_start_oneshot(void)
{
	// restarts timer if already running (retriggerable one-shot)
	USB1_GPTIMER0CTRL = USB_GPTIMERCTRL_GPTRUN | USB_GPTIMERCTRL_GPTRST;
    34b8:	f04f 4240 	mov.w	r2, #3221225472	; 0xc0000000
    34bc:	4b01      	ldr	r3, [pc, #4]	; (34c4 <timer_start_oneshot+0xc>)
    34be:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    34c2:	4770      	bx	lr
    34c4:	402e0000 	.word	0x402e0000

000034c8 <timer_stop>:
}

static void timer_stop(void)
{
	USB1_GPTIMER0CTRL = 0;
    34c8:	2200      	movs	r2, #0
    34ca:	4b02      	ldr	r3, [pc, #8]	; (34d4 <timer_stop+0xc>)
    34cc:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    34d0:	4770      	bx	lr
    34d2:	bf00      	nop
    34d4:	402e0000 	.word	0x402e0000

000034d8 <usb_serial_flush_callback>:
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
	if (tx_noautoflush) return;
    34d8:	4b1f      	ldr	r3, [pc, #124]	; (3558 <usb_serial_flush_callback+0x80>)
    34da:	781b      	ldrb	r3, [r3, #0]
    34dc:	f013 0fff 	tst.w	r3, #255	; 0xff
    34e0:	d138      	bne.n	3554 <usb_serial_flush_callback+0x7c>
	if (!usb_configuration) return;
    34e2:	4b1e      	ldr	r3, [pc, #120]	; (355c <usb_serial_flush_callback+0x84>)
    34e4:	781b      	ldrb	r3, [r3, #0]
    34e6:	f013 0fff 	tst.w	r3, #255	; 0xff
    34ea:	d033      	beq.n	3554 <usb_serial_flush_callback+0x7c>
	tx_available = 0;
	tx_noautoflush = 0;
}

static void usb_serial_flush_callback(void)
{
    34ec:	b570      	push	{r4, r5, r6, lr}
	if (tx_noautoflush) return;
	if (!usb_configuration) return;
	if (tx_available == 0) return;
    34ee:	4b1c      	ldr	r3, [pc, #112]	; (3560 <usb_serial_flush_callback+0x88>)
    34f0:	881d      	ldrh	r5, [r3, #0]
    34f2:	b375      	cbz	r5, 3552 <usb_serial_flush_callback+0x7a>
	//printf("flush callback, %d bytes\n", TX_SIZE - tx_available);
	transfer_t *xfer = tx_transfer + tx_head;
    34f4:	4b1b      	ldr	r3, [pc, #108]	; (3564 <usb_serial_flush_callback+0x8c>)
    34f6:	781a      	ldrb	r2, [r3, #0]
    34f8:	4e1b      	ldr	r6, [pc, #108]	; (3568 <usb_serial_flush_callback+0x90>)
    34fa:	eb06 1642 	add.w	r6, r6, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    34fe:	4b1b      	ldr	r3, [pc, #108]	; (356c <usb_serial_flush_callback+0x94>)
    3500:	eb03 24c2 	add.w	r4, r3, r2, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
    3504:	f5c5 6500 	rsb	r5, r5, #2048	; 0x800
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    3508:	2300      	movs	r3, #0
    350a:	462a      	mov	r2, r5
    350c:	4621      	mov	r1, r4
    350e:	4630      	mov	r0, r6
    3510:	f7ff ff56 	bl	33c0 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    3514:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3518:	192a      	adds	r2, r5, r4
	asm volatile("": : :"memory");
	asm("dsb");
    351a:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    351e:	4814      	ldr	r0, [pc, #80]	; (3570 <usb_serial_flush_callback+0x98>)
    3520:	6003      	str	r3, [r0, #0]
		location += 32;
    3522:	3320      	adds	r3, #32
	} while (location < end_addr);
    3524:	429a      	cmp	r2, r3
    3526:	d8fa      	bhi.n	351e <usb_serial_flush_callback+0x46>
	asm("dsb");
    3528:	f3bf 8f4f 	dsb	sy
	asm("isb");
    352c:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    3530:	4631      	mov	r1, r6
    3532:	2004      	movs	r0, #4
    3534:	f7ff ff5c 	bl	33f0 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    3538:	4a0a      	ldr	r2, [pc, #40]	; (3564 <usb_serial_flush_callback+0x8c>)
    353a:	7813      	ldrb	r3, [r2, #0]
    353c:	3301      	adds	r3, #1
    353e:	b2db      	uxtb	r3, r3
    3540:	7013      	strb	r3, [r2, #0]
    3542:	2b03      	cmp	r3, #3
    3544:	d902      	bls.n	354c <usb_serial_flush_callback+0x74>
    3546:	2200      	movs	r2, #0
    3548:	4b06      	ldr	r3, [pc, #24]	; (3564 <usb_serial_flush_callback+0x8c>)
    354a:	701a      	strb	r2, [r3, #0]
	tx_available = 0;
    354c:	2200      	movs	r2, #0
    354e:	4b04      	ldr	r3, [pc, #16]	; (3560 <usb_serial_flush_callback+0x88>)
    3550:	801a      	strh	r2, [r3, #0]
    3552:	bd70      	pop	{r4, r5, r6, pc}
    3554:	4770      	bx	lr
    3556:	bf00      	nop
    3558:	20001436 	.word	0x20001436
    355c:	20001420 	.word	0x20001420
    3560:	20001550 	.word	0x20001550
    3564:	20001437 	.word	0x20001437
    3568:	20001560 	.word	0x20001560
    356c:	20200ca0 	.word	0x20200ca0
    3570:	e000ef70 	.word	0xe000ef70

00003574 <rx_queue_transfer>:
/*************************************************************************/
/**                               Receive                               **/
/*************************************************************************/

static void rx_queue_transfer(int i)
{
    3574:	b570      	push	{r4, r5, r6, lr}
    3576:	4603      	mov	r3, r0
	NVIC_DISABLE_IRQ(IRQ_USB1);
    3578:	f44f 3100 	mov.w	r1, #131072	; 0x20000
    357c:	4a12      	ldr	r2, [pc, #72]	; (35c8 <rx_queue_transfer+0x54>)
    357e:	6011      	str	r1, [r2, #0]
	printf("rx queue i=%d\n", i);
	void *buffer = rx_buffer + i * CDC_RX_SIZE_480;
    3580:	4912      	ldr	r1, [pc, #72]	; (35cc <rx_queue_transfer+0x58>)
    3582:	eb01 2440 	add.w	r4, r1, r0, lsl #9
	usb_prepare_transfer(rx_transfer + i, buffer, rx_packet_size, i);
    3586:	4d12      	ldr	r5, [pc, #72]	; (35d0 <rx_queue_transfer+0x5c>)
    3588:	eb05 1540 	add.w	r5, r5, r0, lsl #5
    358c:	4e11      	ldr	r6, [pc, #68]	; (35d4 <rx_queue_transfer+0x60>)
    358e:	8832      	ldrh	r2, [r6, #0]
    3590:	4621      	mov	r1, r4
    3592:	4628      	mov	r0, r5
    3594:	f7ff ff14 	bl	33c0 <usb_prepare_transfer>
	arm_dcache_delete(buffer, rx_packet_size);
    3598:	8831      	ldrh	r1, [r6, #0]
// want to delete anything the cache may have stored, so your next
// read is certain to access the physical memory.
__attribute__((always_inline, unused))
static inline void arm_dcache_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    359a:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    359e:	4421      	add	r1, r4
	asm volatile("": : :"memory");
	asm("dsb");
    35a0:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCIMVAC = location;
    35a4:	4a0c      	ldr	r2, [pc, #48]	; (35d8 <rx_queue_transfer+0x64>)
    35a6:	6013      	str	r3, [r2, #0]
		location += 32;
    35a8:	3320      	adds	r3, #32
	} while (location < end_addr);
    35aa:	4299      	cmp	r1, r3
    35ac:	d8fa      	bhi.n	35a4 <rx_queue_transfer+0x30>
	asm("dsb");
    35ae:	f3bf 8f4f 	dsb	sy
	asm("isb");
    35b2:	f3bf 8f6f 	isb	sy
	usb_receive(CDC_RX_ENDPOINT, rx_transfer + i);
    35b6:	4629      	mov	r1, r5
    35b8:	2003      	movs	r0, #3
    35ba:	f7ff ff2b 	bl	3414 <usb_receive>
	NVIC_ENABLE_IRQ(IRQ_USB1);
    35be:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    35c2:	4b06      	ldr	r3, [pc, #24]	; (35dc <rx_queue_transfer+0x68>)
    35c4:	601a      	str	r2, [r3, #0]
    35c6:	bd70      	pop	{r4, r5, r6, pc}
    35c8:	e000e18c 	.word	0xe000e18c
    35cc:	20202ca0 	.word	0x20202ca0
    35d0:	20001440 	.word	0x20001440
    35d4:	2000154e 	.word	0x2000154e
    35d8:	e000ef5c 	.word	0xe000ef5c
    35dc:	e000e10c 	.word	0xe000e10c

000035e0 <rx_event>:
}

// called by USB interrupt when any packet is received
static void rx_event(transfer_t *t)
{
    35e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	int len = rx_packet_size - ((t->status >> 16) & 0x7FFF);
    35e2:	6844      	ldr	r4, [r0, #4]
    35e4:	f3c4 430e 	ubfx	r3, r4, #16, #15
    35e8:	4a22      	ldr	r2, [pc, #136]	; (3674 <rx_event+0x94>)
    35ea:	8814      	ldrh	r4, [r2, #0]
    35ec:	1ae4      	subs	r4, r4, r3
	int i = t->callback_param;
    35ee:	69c5      	ldr	r5, [r0, #28]
	printf("rx event, len=%d, i=%d\n", len, i);
	if (len > 0) {
    35f0:	2c00      	cmp	r4, #0
    35f2:	dd3a      	ble.n	366a <rx_event+0x8a>
		// received a packet with data
		uint32_t head = rx_head;
    35f4:	4b20      	ldr	r3, [pc, #128]	; (3678 <rx_event+0x98>)
    35f6:	781b      	ldrb	r3, [r3, #0]
    35f8:	b2db      	uxtb	r3, r3
		if (head != rx_tail) {
    35fa:	4a20      	ldr	r2, [pc, #128]	; (367c <rx_event+0x9c>)
    35fc:	7812      	ldrb	r2, [r2, #0]
    35fe:	b2d2      	uxtb	r2, r2
    3600:	4293      	cmp	r3, r2
    3602:	d01d      	beq.n	3640 <rx_event+0x60>
			// a previous packet is still buffered
			uint32_t ii = rx_list[head];
    3604:	4a1e      	ldr	r2, [pc, #120]	; (3680 <rx_event+0xa0>)
    3606:	5cd7      	ldrb	r7, [r2, r3]
			uint32_t count = rx_count[ii];
    3608:	4a1e      	ldr	r2, [pc, #120]	; (3684 <rx_event+0xa4>)
    360a:	f832 6017 	ldrh.w	r6, [r2, r7, lsl #1]
			if (len <= CDC_RX_SIZE_480 - count) {
    360e:	f5c6 7200 	rsb	r2, r6, #512	; 0x200
    3612:	4294      	cmp	r4, r2
    3614:	d814      	bhi.n	3640 <rx_event+0x60>
				// previous buffer has enough free space for this packet's data
				memcpy(rx_buffer + ii * CDC_RX_SIZE_480 + count,
    3616:	4b1c      	ldr	r3, [pc, #112]	; (3688 <rx_event+0xa8>)
    3618:	eb06 2047 	add.w	r0, r6, r7, lsl #9
    361c:	4622      	mov	r2, r4
    361e:	eb03 2145 	add.w	r1, r3, r5, lsl #9
    3622:	4418      	add	r0, r3
    3624:	f7fe ff58 	bl	24d8 <memcpy>
					rx_buffer + i * CDC_RX_SIZE_480, len);
				rx_count[ii] = count + len;
    3628:	4426      	add	r6, r4
    362a:	4b16      	ldr	r3, [pc, #88]	; (3684 <rx_event+0xa4>)
    362c:	f823 6017 	strh.w	r6, [r3, r7, lsl #1]
				rx_available += len;
    3630:	4a16      	ldr	r2, [pc, #88]	; (368c <rx_event+0xac>)
    3632:	6813      	ldr	r3, [r2, #0]
    3634:	441c      	add	r4, r3
    3636:	6014      	str	r4, [r2, #0]
				rx_queue_transfer(i);
    3638:	4628      	mov	r0, r5
    363a:	f7ff ff9b 	bl	3574 <rx_queue_transfer>
				// TODO: trigger serialEvent
				return;
    363e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			}
		}
		// add this packet to rx_list
		rx_count[i] = len;
    3640:	4a10      	ldr	r2, [pc, #64]	; (3684 <rx_event+0xa4>)
    3642:	f822 4015 	strh.w	r4, [r2, r5, lsl #1]
		rx_index[i] = 0;
    3646:	2100      	movs	r1, #0
    3648:	4a11      	ldr	r2, [pc, #68]	; (3690 <rx_event+0xb0>)
    364a:	f822 1015 	strh.w	r1, [r2, r5, lsl #1]
		if (++head > RX_NUM) head = 0;
    364e:	3301      	adds	r3, #1
    3650:	2b08      	cmp	r3, #8
    3652:	d900      	bls.n	3656 <rx_event+0x76>
    3654:	460b      	mov	r3, r1
		rx_list[head] = i;
    3656:	4a0a      	ldr	r2, [pc, #40]	; (3680 <rx_event+0xa0>)
    3658:	54d5      	strb	r5, [r2, r3]
		rx_head = head;
    365a:	b2db      	uxtb	r3, r3
    365c:	4a06      	ldr	r2, [pc, #24]	; (3678 <rx_event+0x98>)
    365e:	7013      	strb	r3, [r2, #0]
		rx_available += len;
    3660:	4a0a      	ldr	r2, [pc, #40]	; (368c <rx_event+0xac>)
    3662:	6813      	ldr	r3, [r2, #0]
    3664:	441c      	add	r4, r3
    3666:	6014      	str	r4, [r2, #0]
    3668:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		// TODO: trigger serialEvent
	} else {
		// received a zero length packet
		rx_queue_transfer(i);
    366a:	4628      	mov	r0, r5
    366c:	f7ff ff82 	bl	3574 <rx_queue_transfer>
    3670:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3672:	bf00      	nop
    3674:	2000154e 	.word	0x2000154e
    3678:	20001438 	.word	0x20001438
    367c:	20001540 	.word	0x20001540
    3680:	20001544 	.word	0x20001544
    3684:	200015e4 	.word	0x200015e4
    3688:	20202ca0 	.word	0x20202ca0
    368c:	20001554 	.word	0x20001554
    3690:	20001424 	.word	0x20001424

00003694 <usb_serial_reset>:
static void rx_queue_transfer(int i);
static void rx_event(transfer_t *t);


void usb_serial_reset(void)
{
    3694:	4770      	bx	lr
    3696:	bf00      	nop

00003698 <usb_serial_configure>:
	printf("usb_serial_reset\n");
	// deallocate all transfer descriptors
}

void usb_serial_configure(void)
{
    3698:	b510      	push	{r4, lr}
	int i;

	printf("usb_serial_configure\n");
	if (usb_high_speed) {
    369a:	4b28      	ldr	r3, [pc, #160]	; (373c <usb_serial_configure+0xa4>)
    369c:	781b      	ldrb	r3, [r3, #0]
    369e:	f013 0fff 	tst.w	r3, #255	; 0xff
    36a2:	d006      	beq.n	36b2 <usb_serial_configure+0x1a>
		tx_packet_size = CDC_TX_SIZE_480;
    36a4:	f44f 7300 	mov.w	r3, #512	; 0x200
    36a8:	4a25      	ldr	r2, [pc, #148]	; (3740 <usb_serial_configure+0xa8>)
    36aa:	8013      	strh	r3, [r2, #0]
		rx_packet_size = CDC_RX_SIZE_480;
    36ac:	4a25      	ldr	r2, [pc, #148]	; (3744 <usb_serial_configure+0xac>)
    36ae:	8013      	strh	r3, [r2, #0]
    36b0:	e004      	b.n	36bc <usb_serial_configure+0x24>
	} else {
		tx_packet_size = CDC_TX_SIZE_12;
    36b2:	2340      	movs	r3, #64	; 0x40
    36b4:	4a22      	ldr	r2, [pc, #136]	; (3740 <usb_serial_configure+0xa8>)
    36b6:	8013      	strh	r3, [r2, #0]
		rx_packet_size = CDC_RX_SIZE_12;
    36b8:	4a22      	ldr	r2, [pc, #136]	; (3744 <usb_serial_configure+0xac>)
    36ba:	8013      	strh	r3, [r2, #0]
	}
	memset(tx_transfer, 0, sizeof(tx_transfer));
    36bc:	2280      	movs	r2, #128	; 0x80
    36be:	2100      	movs	r1, #0
    36c0:	4821      	ldr	r0, [pc, #132]	; (3748 <usb_serial_configure+0xb0>)
    36c2:	f000 ffab 	bl	461c <memset>
	tx_head = 0;
    36c6:	2400      	movs	r4, #0
    36c8:	4b20      	ldr	r3, [pc, #128]	; (374c <usb_serial_configure+0xb4>)
    36ca:	701c      	strb	r4, [r3, #0]
	tx_available = 0;
    36cc:	4b20      	ldr	r3, [pc, #128]	; (3750 <usb_serial_configure+0xb8>)
    36ce:	801c      	strh	r4, [r3, #0]
	memset(rx_transfer, 0, sizeof(rx_transfer));
    36d0:	f44f 7280 	mov.w	r2, #256	; 0x100
    36d4:	4621      	mov	r1, r4
    36d6:	481f      	ldr	r0, [pc, #124]	; (3754 <usb_serial_configure+0xbc>)
    36d8:	f000 ffa0 	bl	461c <memset>
	memset(rx_count, 0, sizeof(rx_count));
    36dc:	4b1e      	ldr	r3, [pc, #120]	; (3758 <usb_serial_configure+0xc0>)
    36de:	601c      	str	r4, [r3, #0]
    36e0:	605c      	str	r4, [r3, #4]
    36e2:	609c      	str	r4, [r3, #8]
    36e4:	60dc      	str	r4, [r3, #12]
	memset(rx_index, 0, sizeof(rx_index));
    36e6:	4b1d      	ldr	r3, [pc, #116]	; (375c <usb_serial_configure+0xc4>)
    36e8:	601c      	str	r4, [r3, #0]
    36ea:	605c      	str	r4, [r3, #4]
    36ec:	609c      	str	r4, [r3, #8]
    36ee:	60dc      	str	r4, [r3, #12]
	rx_head = 0;
    36f0:	4b1b      	ldr	r3, [pc, #108]	; (3760 <usb_serial_configure+0xc8>)
    36f2:	701c      	strb	r4, [r3, #0]
	rx_tail = 0;
    36f4:	4b1b      	ldr	r3, [pc, #108]	; (3764 <usb_serial_configure+0xcc>)
    36f6:	701c      	strb	r4, [r3, #0]
	rx_available = 0;
    36f8:	4b1b      	ldr	r3, [pc, #108]	; (3768 <usb_serial_configure+0xd0>)
    36fa:	601c      	str	r4, [r3, #0]
	usb_config_tx(CDC_ACM_ENDPOINT, CDC_ACM_SIZE, 0, NULL); // size same 12 & 480
    36fc:	4623      	mov	r3, r4
    36fe:	4622      	mov	r2, r4
    3700:	2110      	movs	r1, #16
    3702:	2002      	movs	r0, #2
    3704:	f7ff fe38 	bl	3378 <usb_config_tx>
	usb_config_rx(CDC_RX_ENDPOINT, rx_packet_size, 0, rx_event);
    3708:	4b18      	ldr	r3, [pc, #96]	; (376c <usb_serial_configure+0xd4>)
    370a:	4622      	mov	r2, r4
    370c:	490d      	ldr	r1, [pc, #52]	; (3744 <usb_serial_configure+0xac>)
    370e:	8809      	ldrh	r1, [r1, #0]
    3710:	2003      	movs	r0, #3
    3712:	f7ff fe11 	bl	3338 <usb_config_rx>
	usb_config_tx(CDC_TX_ENDPOINT, tx_packet_size, 1, NULL);
    3716:	4623      	mov	r3, r4
    3718:	2201      	movs	r2, #1
    371a:	4909      	ldr	r1, [pc, #36]	; (3740 <usb_serial_configure+0xa8>)
    371c:	8809      	ldrh	r1, [r1, #0]
    371e:	2004      	movs	r0, #4
    3720:	f7ff fe2a 	bl	3378 <usb_config_tx>
	for (i=0; i < RX_NUM; i++) rx_queue_transfer(i);
    3724:	e003      	b.n	372e <usb_serial_configure+0x96>
    3726:	4620      	mov	r0, r4
    3728:	f7ff ff24 	bl	3574 <rx_queue_transfer>
    372c:	3401      	adds	r4, #1
    372e:	2c07      	cmp	r4, #7
    3730:	ddf9      	ble.n	3726 <usb_serial_configure+0x8e>
	timer_config(usb_serial_flush_callback, TRANSMIT_FLUSH_TIMEOUT);
    3732:	214b      	movs	r1, #75	; 0x4b
    3734:	480e      	ldr	r0, [pc, #56]	; (3770 <usb_serial_configure+0xd8>)
    3736:	f7ff feab 	bl	3490 <timer_config>
    373a:	bd10      	pop	{r4, pc}
    373c:	200013f8 	.word	0x200013f8
    3740:	20001434 	.word	0x20001434
    3744:	2000154e 	.word	0x2000154e
    3748:	20001560 	.word	0x20001560
    374c:	20001437 	.word	0x20001437
    3750:	20001550 	.word	0x20001550
    3754:	20001440 	.word	0x20001440
    3758:	200015e4 	.word	0x200015e4
    375c:	20001424 	.word	0x20001424
    3760:	20001438 	.word	0x20001438
    3764:	20001540 	.word	0x20001540
    3768:	20001554 	.word	0x20001554
    376c:	000035e1 	.word	0x000035e1
    3770:	000034d9 	.word	0x000034d9

00003774 <usb_serial_read>:

//static int maxtimes=0;

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
    3774:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    3778:	4681      	mov	r9, r0
    377a:	4688      	mov	r8, r1
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;

	NVIC_DISABLE_IRQ(IRQ_USB1);
    377c:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    3780:	4b27      	ldr	r3, [pc, #156]	; (3820 <usb_serial_read+0xac>)
    3782:	601a      	str	r2, [r3, #0]
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
    3784:	4b27      	ldr	r3, [pc, #156]	; (3824 <usb_serial_read+0xb0>)
    3786:	781c      	ldrb	r4, [r3, #0]
    3788:	b2e4      	uxtb	r4, r4

// read a block of bytes to a buffer
int usb_serial_read(void *buffer, uint32_t size)
{
	uint8_t *p = (uint8_t *)buffer;
	uint32_t count=0;
    378a:	2700      	movs	r7, #0

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    378c:	e039      	b.n	3802 <usb_serial_read+0x8e>
		if (++tail > RX_NUM) tail = 0;
    378e:	3401      	adds	r4, #1
    3790:	2c08      	cmp	r4, #8
    3792:	d900      	bls.n	3796 <usb_serial_read+0x22>
    3794:	2400      	movs	r4, #0
		uint32_t i = rx_list[tail];
    3796:	4b24      	ldr	r3, [pc, #144]	; (3828 <usb_serial_read+0xb4>)
    3798:	5d1e      	ldrb	r6, [r3, r4]
		uint32_t len = size - count;
    379a:	ebc7 0a08 	rsb	sl, r7, r8
		uint32_t avail = rx_count[i] - rx_index[i];
    379e:	4b23      	ldr	r3, [pc, #140]	; (382c <usb_serial_read+0xb8>)
    37a0:	f833 5016 	ldrh.w	r5, [r3, r6, lsl #1]
    37a4:	4b22      	ldr	r3, [pc, #136]	; (3830 <usb_serial_read+0xbc>)
    37a6:	f833 1016 	ldrh.w	r1, [r3, r6, lsl #1]
    37aa:	1a6d      	subs	r5, r5, r1
		 //printf("usb_serial_read, count=%d, size=%d, i=%d, index=%d, len=%d, avail=%d, c=%c\n",
		  //count, size, i, rx_index[i], len, avail, rx_buffer[i * CDC_RX_SIZE_480]);
		if (avail > len) {
    37ac:	45aa      	cmp	sl, r5
    37ae:	d214      	bcs.n	37da <usb_serial_read+0x66>
			// partially consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], len);
    37b0:	eb01 2146 	add.w	r1, r1, r6, lsl #9
    37b4:	4652      	mov	r2, sl
    37b6:	4b1f      	ldr	r3, [pc, #124]	; (3834 <usb_serial_read+0xc0>)
    37b8:	4419      	add	r1, r3
    37ba:	4648      	mov	r0, r9
    37bc:	f7fe fe8c 	bl	24d8 <memcpy>
			rx_available -= len;
    37c0:	4a1d      	ldr	r2, [pc, #116]	; (3838 <usb_serial_read+0xc4>)
    37c2:	6813      	ldr	r3, [r2, #0]
    37c4:	ebca 0303 	rsb	r3, sl, r3
    37c8:	6013      	str	r3, [r2, #0]
			rx_index[i] += len;
    37ca:	4a19      	ldr	r2, [pc, #100]	; (3830 <usb_serial_read+0xbc>)
    37cc:	f832 3016 	ldrh.w	r3, [r2, r6, lsl #1]
    37d0:	449a      	add	sl, r3
    37d2:	f822 a016 	strh.w	sl, [r2, r6, lsl #1]
			count += len;
    37d6:	4647      	mov	r7, r8
    37d8:	e013      	b.n	3802 <usb_serial_read+0x8e>
		} else {
			// fully consume this packet
			memcpy(p, rx_buffer + i * CDC_RX_SIZE_480 + rx_index[i], avail);
    37da:	eb01 2146 	add.w	r1, r1, r6, lsl #9
    37de:	462a      	mov	r2, r5
    37e0:	4b14      	ldr	r3, [pc, #80]	; (3834 <usb_serial_read+0xc0>)
    37e2:	4419      	add	r1, r3
    37e4:	4648      	mov	r0, r9
    37e6:	f7fe fe77 	bl	24d8 <memcpy>
			p += avail;
    37ea:	44a9      	add	r9, r5
			rx_available -= avail;
    37ec:	4a12      	ldr	r2, [pc, #72]	; (3838 <usb_serial_read+0xc4>)
    37ee:	6813      	ldr	r3, [r2, #0]
    37f0:	1b5b      	subs	r3, r3, r5
    37f2:	6013      	str	r3, [r2, #0]
			count += avail;
    37f4:	442f      	add	r7, r5
			rx_tail = tail;
    37f6:	b2e3      	uxtb	r3, r4
    37f8:	4a0a      	ldr	r2, [pc, #40]	; (3824 <usb_serial_read+0xb0>)
    37fa:	7013      	strb	r3, [r2, #0]
			rx_queue_transfer(i);
    37fc:	4630      	mov	r0, r6
    37fe:	f7ff feb9 	bl	3574 <rx_queue_transfer>

	NVIC_DISABLE_IRQ(IRQ_USB1);
	//if (++maxtimes > 15) while (1) ;
	uint32_t tail = rx_tail;
	//printf("usb_serial_read, size=%d, tail=%d, head=%d\n", size, tail, rx_head);
	while (count < size && tail != rx_head) {
    3802:	4547      	cmp	r7, r8
    3804:	d204      	bcs.n	3810 <usb_serial_read+0x9c>
    3806:	4b0d      	ldr	r3, [pc, #52]	; (383c <usb_serial_read+0xc8>)
    3808:	781b      	ldrb	r3, [r3, #0]
    380a:	b2db      	uxtb	r3, r3
    380c:	429c      	cmp	r4, r3
    380e:	d1be      	bne.n	378e <usb_serial_read+0x1a>
			count += avail;
			rx_tail = tail;
			rx_queue_transfer(i);
		}
	}
	NVIC_ENABLE_IRQ(IRQ_USB1);
    3810:	f44f 3200 	mov.w	r2, #131072	; 0x20000
    3814:	4b0a      	ldr	r3, [pc, #40]	; (3840 <usb_serial_read+0xcc>)
    3816:	601a      	str	r2, [r3, #0]
	return count;
}
    3818:	4638      	mov	r0, r7
    381a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    381e:	bf00      	nop
    3820:	e000e18c 	.word	0xe000e18c
    3824:	20001540 	.word	0x20001540
    3828:	20001544 	.word	0x20001544
    382c:	200015e4 	.word	0x200015e4
    3830:	20001424 	.word	0x20001424
    3834:	20202ca0 	.word	0x20202ca0
    3838:	20001554 	.word	0x20001554
    383c:	20001438 	.word	0x20001438
    3840:	e000e10c 	.word	0xe000e10c

00003844 <usb_serial_peekchar>:

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
    3844:	4b0d      	ldr	r3, [pc, #52]	; (387c <usb_serial_peekchar+0x38>)
    3846:	781b      	ldrb	r3, [r3, #0]
    3848:	b2db      	uxtb	r3, r3
	if (tail == rx_head) return -1;
    384a:	4a0d      	ldr	r2, [pc, #52]	; (3880 <usb_serial_peekchar+0x3c>)
    384c:	7812      	ldrb	r2, [r2, #0]
    384e:	b2d2      	uxtb	r2, r2
    3850:	4293      	cmp	r3, r2
    3852:	d00f      	beq.n	3874 <usb_serial_peekchar+0x30>
	if (++tail > RX_NUM) tail = 0;
    3854:	3301      	adds	r3, #1
    3856:	2b08      	cmp	r3, #8
    3858:	d900      	bls.n	385c <usb_serial_peekchar+0x18>
    385a:	2300      	movs	r3, #0
	uint32_t i = rx_list[tail];
    385c:	4a09      	ldr	r2, [pc, #36]	; (3884 <usb_serial_peekchar+0x40>)
    385e:	5cd2      	ldrb	r2, [r2, r3]
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
    3860:	4b09      	ldr	r3, [pc, #36]	; (3888 <usb_serial_peekchar+0x44>)
    3862:	f833 3012 	ldrh.w	r3, [r3, r2, lsl #1]
    3866:	eb03 2342 	add.w	r3, r3, r2, lsl #9
    386a:	4a08      	ldr	r2, [pc, #32]	; (388c <usb_serial_peekchar+0x48>)
    386c:	4413      	add	r3, r2
    386e:	f893 0f08 	ldrb.w	r0, [r3, #3848]	; 0xf08
    3872:	4770      	bx	lr

// peek at the next character, or -1 if nothing received
int usb_serial_peekchar(void)
{
	uint32_t tail = rx_tail;
	if (tail == rx_head) return -1;
    3874:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	if (++tail > RX_NUM) tail = 0;
	uint32_t i = rx_list[tail];
	return rx_buffer[i * CDC_RX_SIZE_480 + rx_index[i]];
}
    3878:	4770      	bx	lr
    387a:	bf00      	nop
    387c:	20001540 	.word	0x20001540
    3880:	20001438 	.word	0x20001438
    3884:	20001544 	.word	0x20001544
    3888:	20001424 	.word	0x20001424
    388c:	20201d98 	.word	0x20201d98

00003890 <usb_serial_available>:

// number of bytes available in the receive buffer
int usb_serial_available(void)
{
	return rx_available;
    3890:	4b01      	ldr	r3, [pc, #4]	; (3898 <usb_serial_available+0x8>)
    3892:	6818      	ldr	r0, [r3, #0]
}
    3894:	4770      	bx	lr
    3896:	bf00      	nop
    3898:	20001554 	.word	0x20001554

0000389c <usb_serial_flush_input>:

// discard any buffered input
void usb_serial_flush_input(void)
{
    389c:	b538      	push	{r3, r4, r5, lr}
	uint32_t tail = rx_tail;
    389e:	4b10      	ldr	r3, [pc, #64]	; (38e0 <usb_serial_flush_input+0x44>)
    38a0:	781c      	ldrb	r4, [r3, #0]
    38a2:	b2e4      	uxtb	r4, r4
	while (tail != rx_head) {
    38a4:	e015      	b.n	38d2 <usb_serial_flush_input+0x36>
		if (++tail > RX_NUM) tail = 0;
    38a6:	3401      	adds	r4, #1
    38a8:	2c08      	cmp	r4, #8
    38aa:	d900      	bls.n	38ae <usb_serial_flush_input+0x12>
    38ac:	2400      	movs	r4, #0
		uint32_t i = rx_list[tail];
    38ae:	4b0d      	ldr	r3, [pc, #52]	; (38e4 <usb_serial_flush_input+0x48>)
    38b0:	5d18      	ldrb	r0, [r3, r4]
		rx_available -= rx_count[i] - rx_index[i];
    38b2:	490d      	ldr	r1, [pc, #52]	; (38e8 <usb_serial_flush_input+0x4c>)
    38b4:	680a      	ldr	r2, [r1, #0]
    38b6:	4b0d      	ldr	r3, [pc, #52]	; (38ec <usb_serial_flush_input+0x50>)
    38b8:	f833 3010 	ldrh.w	r3, [r3, r0, lsl #1]
    38bc:	4d0c      	ldr	r5, [pc, #48]	; (38f0 <usb_serial_flush_input+0x54>)
    38be:	f835 5010 	ldrh.w	r5, [r5, r0, lsl #1]
    38c2:	1b5b      	subs	r3, r3, r5
    38c4:	1ad3      	subs	r3, r2, r3
    38c6:	600b      	str	r3, [r1, #0]
		rx_queue_transfer(i);
    38c8:	f7ff fe54 	bl	3574 <rx_queue_transfer>
		rx_tail = tail;
    38cc:	b2e3      	uxtb	r3, r4
    38ce:	4a04      	ldr	r2, [pc, #16]	; (38e0 <usb_serial_flush_input+0x44>)
    38d0:	7013      	strb	r3, [r2, #0]

// discard any buffered input
void usb_serial_flush_input(void)
{
	uint32_t tail = rx_tail;
	while (tail != rx_head) {
    38d2:	4b08      	ldr	r3, [pc, #32]	; (38f4 <usb_serial_flush_input+0x58>)
    38d4:	781b      	ldrb	r3, [r3, #0]
    38d6:	b2db      	uxtb	r3, r3
    38d8:	429c      	cmp	r4, r3
    38da:	d1e4      	bne.n	38a6 <usb_serial_flush_input+0xa>
		uint32_t i = rx_list[tail];
		rx_available -= rx_count[i] - rx_index[i];
		rx_queue_transfer(i);
		rx_tail = tail;
	}
}
    38dc:	bd38      	pop	{r3, r4, r5, pc}
    38de:	bf00      	nop
    38e0:	20001540 	.word	0x20001540
    38e4:	20001544 	.word	0x20001544
    38e8:	20001554 	.word	0x20001554
    38ec:	200015e4 	.word	0x200015e4
    38f0:	20001424 	.word	0x20001424
    38f4:	20001438 	.word	0x20001438

000038f8 <usb_serial_getchar>:


// get the next character, or -1 if nothing received
int usb_serial_getchar(void)
{
    38f8:	b500      	push	{lr}
    38fa:	b083      	sub	sp, #12
	uint8_t c;
	if (usb_serial_read(&c, 1)) return c;
    38fc:	2101      	movs	r1, #1
    38fe:	f10d 0007 	add.w	r0, sp, #7
    3902:	f7ff ff37 	bl	3774 <usb_serial_read>
    3906:	b110      	cbz	r0, 390e <usb_serial_getchar+0x16>
    3908:	f89d 0007 	ldrb.w	r0, [sp, #7]
    390c:	e001      	b.n	3912 <usb_serial_getchar+0x1a>
	return -1;
    390e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
}
    3912:	b003      	add	sp, #12
    3914:	f85d fb04 	ldr.w	pc, [sp], #4

00003918 <usb_serial_write>:
	USB1_GPTIMER0CTRL = 0;
}


int usb_serial_write(const void *buffer, uint32_t size)
{
    3918:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    391c:	4b4d      	ldr	r3, [pc, #308]	; (3a54 <usb_serial_write+0x13c>)
    391e:	781b      	ldrb	r3, [r3, #0]
    3920:	f013 0fff 	tst.w	r3, #255	; 0xff
    3924:	f000 8092 	beq.w	3a4c <usb_serial_write+0x134>
    3928:	4681      	mov	r9, r0
    392a:	4688      	mov	r8, r1
    392c:	2700      	movs	r7, #0
    392e:	e086      	b.n	3a3e <usb_serial_write+0x126>
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
    3930:	4b49      	ldr	r3, [pc, #292]	; (3a58 <usb_serial_write+0x140>)
    3932:	781e      	ldrb	r6, [r3, #0]
    3934:	4b49      	ldr	r3, [pc, #292]	; (3a5c <usb_serial_write+0x144>)
    3936:	eb03 1646 	add.w	r6, r3, r6, lsl #5
		int waiting=0;
		uint32_t wait_begin_at=0;
    393a:	2400      	movs	r4, #0
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
    393c:	4625      	mov	r5, r4
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    393e:	e02c      	b.n	399a <usb_serial_write+0x82>
			//digitalWriteFast(3, HIGH);
			uint32_t status = usb_transfer_status(xfer);
    3940:	4630      	mov	r0, r6
    3942:	f7ff fd77 	bl	3434 <usb_transfer_status>
			if (!(status & 0x80)) {
    3946:	f010 0f80 	tst.w	r0, #128	; 0x80
    394a:	d107      	bne.n	395c <usb_serial_write+0x44>
				if (status & 0x68) {
					// TODO: what if status has errors???
					printf("ERROR status = %x, i=%d, ms=%u\n",
						status, tx_head, systick_millis_count);
				}
				tx_available = TX_SIZE;
    394c:	f44f 6200 	mov.w	r2, #2048	; 0x800
    3950:	4b43      	ldr	r3, [pc, #268]	; (3a60 <usb_serial_write+0x148>)
    3952:	801a      	strh	r2, [r3, #0]
				transmit_previous_timeout = 0;
    3954:	2200      	movs	r2, #0
    3956:	4b43      	ldr	r3, [pc, #268]	; (3a64 <usb_serial_write+0x14c>)
    3958:	701a      	strb	r2, [r3, #0]
				break;
    395a:	e022      	b.n	39a2 <usb_serial_write+0x8a>
			}
			if (!waiting) {
    395c:	b915      	cbnz	r5, 3964 <usb_serial_write+0x4c>
				wait_begin_at = systick_millis_count;
    395e:	4b42      	ldr	r3, [pc, #264]	; (3a68 <usb_serial_write+0x150>)
    3960:	681c      	ldr	r4, [r3, #0]
				waiting = 1;
    3962:	2501      	movs	r5, #1
			}
			if (transmit_previous_timeout) return sent;
    3964:	4b3f      	ldr	r3, [pc, #252]	; (3a64 <usb_serial_write+0x14c>)
    3966:	781b      	ldrb	r3, [r3, #0]
    3968:	b113      	cbz	r3, 3970 <usb_serial_write+0x58>
    396a:	4638      	mov	r0, r7
    396c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (systick_millis_count - wait_begin_at > TX_TIMEOUT_MSEC) {
    3970:	4b3d      	ldr	r3, [pc, #244]	; (3a68 <usb_serial_write+0x150>)
    3972:	681b      	ldr	r3, [r3, #0]
    3974:	1b1b      	subs	r3, r3, r4
    3976:	2b78      	cmp	r3, #120	; 0x78
    3978:	d905      	bls.n	3986 <usb_serial_write+0x6e>
				// waited too long, assume the USB host isn't listening
				transmit_previous_timeout = 1;
    397a:	2201      	movs	r2, #1
    397c:	4b39      	ldr	r3, [pc, #228]	; (3a64 <usb_serial_write+0x14c>)
    397e:	701a      	strb	r2, [r3, #0]
				return sent;
    3980:	4638      	mov	r0, r7
    3982:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
				//printf("tx head=%d\n", tx_head);
				//printf("TXFILLTUNING=%08lX\n", USB1_TXFILLTUNING);
				//usb_print_transfer_log();
				//while (1) ;
			}
			if (!usb_configuration) return sent;
    3986:	4b33      	ldr	r3, [pc, #204]	; (3a54 <usb_serial_write+0x13c>)
    3988:	781b      	ldrb	r3, [r3, #0]
    398a:	f013 0fff 	tst.w	r3, #255	; 0xff
    398e:	d102      	bne.n	3996 <usb_serial_write+0x7e>
    3990:	4638      	mov	r0, r7
    3992:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			yield();
    3996:	f000 faa9 	bl	3eec <yield>
	if (!usb_configuration) return 0;
	while (size > 0) {
		transfer_t *xfer = tx_transfer + tx_head;
		int waiting=0;
		uint32_t wait_begin_at=0;
		while (!tx_available) {
    399a:	4b31      	ldr	r3, [pc, #196]	; (3a60 <usb_serial_write+0x148>)
    399c:	881b      	ldrh	r3, [r3, #0]
    399e:	2b00      	cmp	r3, #0
    39a0:	d0ce      	beq.n	3940 <usb_serial_write+0x28>
			}
			if (!usb_configuration) return sent;
			yield();
		}
		//digitalWriteFast(3, LOW);
		uint8_t *txdata = txbuffer + (tx_head * TX_SIZE) + (TX_SIZE - tx_available);
    39a2:	4b2d      	ldr	r3, [pc, #180]	; (3a58 <usb_serial_write+0x140>)
    39a4:	781c      	ldrb	r4, [r3, #0]
    39a6:	02e4      	lsls	r4, r4, #11
    39a8:	4b2d      	ldr	r3, [pc, #180]	; (3a60 <usb_serial_write+0x148>)
    39aa:	881d      	ldrh	r5, [r3, #0]
    39ac:	1b63      	subs	r3, r4, r5
    39ae:	f503 6300 	add.w	r3, r3, #2048	; 0x800
    39b2:	482e      	ldr	r0, [pc, #184]	; (3a6c <usb_serial_write+0x154>)
    39b4:	4418      	add	r0, r3
		if (size >= tx_available) {
    39b6:	45a8      	cmp	r8, r5
    39b8:	d334      	bcc.n	3a24 <usb_serial_write+0x10c>
			memcpy(txdata, data, tx_available);
    39ba:	462a      	mov	r2, r5
    39bc:	4649      	mov	r1, r9
    39be:	f7fe fd8b 	bl	24d8 <memcpy>
			//*(txbuffer + (tx_head * TX_SIZE)) = 'A' + tx_head; // to see which buffer
			//*(txbuffer + (tx_head * TX_SIZE) + 1) = ' '; // really see it
			uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    39c2:	492a      	ldr	r1, [pc, #168]	; (3a6c <usb_serial_write+0x154>)
    39c4:	440c      	add	r4, r1
			usb_prepare_transfer(xfer, txbuf, TX_SIZE, 0);
    39c6:	2300      	movs	r3, #0
    39c8:	f44f 6200 	mov.w	r2, #2048	; 0x800
    39cc:	4621      	mov	r1, r4
    39ce:	4630      	mov	r0, r6
    39d0:	f7ff fcf6 	bl	33c0 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    39d4:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    39d8:	f504 6100 	add.w	r1, r4, #2048	; 0x800
	asm volatile("": : :"memory");
	asm("dsb");
    39dc:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    39e0:	4a23      	ldr	r2, [pc, #140]	; (3a70 <usb_serial_write+0x158>)
    39e2:	6013      	str	r3, [r2, #0]
		location += 32;
    39e4:	3320      	adds	r3, #32
	} while (location < end_addr);
    39e6:	4299      	cmp	r1, r3
    39e8:	d8fa      	bhi.n	39e0 <usb_serial_write+0xc8>
	asm("dsb");
    39ea:	f3bf 8f4f 	dsb	sy
	asm("isb");
    39ee:	f3bf 8f6f 	isb	sy
			arm_dcache_flush_delete(txbuf, TX_SIZE);
			usb_transmit(CDC_TX_ENDPOINT, xfer);
    39f2:	4631      	mov	r1, r6
    39f4:	2004      	movs	r0, #4
    39f6:	f7ff fcfb 	bl	33f0 <usb_transmit>
			if (++tx_head >= TX_NUM) tx_head = 0;
    39fa:	4a17      	ldr	r2, [pc, #92]	; (3a58 <usb_serial_write+0x140>)
    39fc:	7813      	ldrb	r3, [r2, #0]
    39fe:	3301      	adds	r3, #1
    3a00:	b2db      	uxtb	r3, r3
    3a02:	7013      	strb	r3, [r2, #0]
    3a04:	2b03      	cmp	r3, #3
    3a06:	d902      	bls.n	3a0e <usb_serial_write+0xf6>
    3a08:	2200      	movs	r2, #0
    3a0a:	4b13      	ldr	r3, [pc, #76]	; (3a58 <usb_serial_write+0x140>)
    3a0c:	701a      	strb	r2, [r3, #0]
			size -= tx_available;
    3a0e:	4a14      	ldr	r2, [pc, #80]	; (3a60 <usb_serial_write+0x148>)
    3a10:	8813      	ldrh	r3, [r2, #0]
    3a12:	ebc3 0808 	rsb	r8, r3, r8
			sent += tx_available;
    3a16:	441f      	add	r7, r3
			data += tx_available;
    3a18:	4499      	add	r9, r3
			tx_available = 0;
    3a1a:	2300      	movs	r3, #0
    3a1c:	8013      	strh	r3, [r2, #0]
			timer_stop();
    3a1e:	f7ff fd53 	bl	34c8 <timer_stop>
    3a22:	e00c      	b.n	3a3e <usb_serial_write+0x126>
		} else {
			memcpy(txdata, data, size);
    3a24:	4642      	mov	r2, r8
    3a26:	4649      	mov	r1, r9
    3a28:	f7fe fd56 	bl	24d8 <memcpy>
			tx_available -= size;
    3a2c:	ebc8 0505 	rsb	r5, r8, r5
    3a30:	4b0b      	ldr	r3, [pc, #44]	; (3a60 <usb_serial_write+0x148>)
    3a32:	801d      	strh	r5, [r3, #0]
			sent += size;
    3a34:	4447      	add	r7, r8
			size = 0;
			timer_start_oneshot();
    3a36:	f7ff fd3f 	bl	34b8 <timer_start_oneshot>
			timer_stop();
		} else {
			memcpy(txdata, data, size);
			tx_available -= size;
			sent += size;
			size = 0;
    3a3a:	f04f 0800 	mov.w	r8, #0
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
	while (size > 0) {
    3a3e:	f1b8 0f00 	cmp.w	r8, #0
    3a42:	f47f af75 	bne.w	3930 <usb_serial_write+0x18>
			sent += size;
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
    3a46:	4638      	mov	r0, r7
    3a48:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
int usb_serial_write(const void *buffer, uint32_t size)
{
	uint32_t sent=0;
	const uint8_t *data = (const uint8_t *)buffer;

	if (!usb_configuration) return 0;
    3a4c:	2000      	movs	r0, #0
			size = 0;
			timer_start_oneshot();
		}
	}
	return sent;
}
    3a4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    3a52:	bf00      	nop
    3a54:	20001420 	.word	0x20001420
    3a58:	20001437 	.word	0x20001437
    3a5c:	20001560 	.word	0x20001560
    3a60:	20001550 	.word	0x20001550
    3a64:	200015e0 	.word	0x200015e0
    3a68:	200013d4 	.word	0x200013d4
    3a6c:	20200ca0 	.word	0x20200ca0
    3a70:	e000ef70 	.word	0xe000ef70

00003a74 <usb_serial_putchar>:
static uint8_t transmit_previous_timeout=0;


// transmit a character.  0 returned on success, -1 on error
int usb_serial_putchar(uint8_t c)
{
    3a74:	b500      	push	{lr}
    3a76:	b083      	sub	sp, #12
    3a78:	ab02      	add	r3, sp, #8
    3a7a:	f803 0d01 	strb.w	r0, [r3, #-1]!
	return usb_serial_write(&c, 1);
    3a7e:	2101      	movs	r1, #1
    3a80:	4618      	mov	r0, r3
    3a82:	f7ff ff49 	bl	3918 <usb_serial_write>
}
    3a86:	b003      	add	sp, #12
    3a88:	f85d fb04 	ldr.w	pc, [sp], #4

00003a8c <usb_serial_write_buffer_free>:
	}
	return sent;
}

int usb_serial_write_buffer_free(void)
{
    3a8c:	b538      	push	{r3, r4, r5, lr}
	uint32_t sum = 0;
	tx_noautoflush = 1;
    3a8e:	2201      	movs	r2, #1
    3a90:	4b0d      	ldr	r3, [pc, #52]	; (3ac8 <usb_serial_write_buffer_free+0x3c>)
    3a92:	701a      	strb	r2, [r3, #0]
	for (uint32_t i=0; i < TX_NUM; i++) {
    3a94:	2400      	movs	r4, #0
	return sent;
}

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
    3a96:	4625      	mov	r5, r4
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    3a98:	e00e      	b.n	3ab8 <usb_serial_write_buffer_free+0x2c>
		if (i == tx_head) continue;
    3a9a:	4b0c      	ldr	r3, [pc, #48]	; (3acc <usb_serial_write_buffer_free+0x40>)
    3a9c:	781b      	ldrb	r3, [r3, #0]
    3a9e:	429c      	cmp	r4, r3
    3aa0:	d009      	beq.n	3ab6 <usb_serial_write_buffer_free+0x2a>
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
    3aa2:	480b      	ldr	r0, [pc, #44]	; (3ad0 <usb_serial_write_buffer_free+0x44>)
    3aa4:	eb00 1044 	add.w	r0, r0, r4, lsl #5
    3aa8:	f7ff fcc4 	bl	3434 <usb_transfer_status>
    3aac:	f010 0f80 	tst.w	r0, #128	; 0x80
    3ab0:	d101      	bne.n	3ab6 <usb_serial_write_buffer_free+0x2a>
    3ab2:	f505 6500 	add.w	r5, r5, #2048	; 0x800

int usb_serial_write_buffer_free(void)
{
	uint32_t sum = 0;
	tx_noautoflush = 1;
	for (uint32_t i=0; i < TX_NUM; i++) {
    3ab6:	3401      	adds	r4, #1
    3ab8:	2c03      	cmp	r4, #3
    3aba:	d9ee      	bls.n	3a9a <usb_serial_write_buffer_free+0xe>
		if (i == tx_head) continue;
		if (!(usb_transfer_status(tx_transfer + i) & 0x80)) sum += TX_SIZE;
	}
	tx_noautoflush = 0;
    3abc:	2200      	movs	r2, #0
    3abe:	4b02      	ldr	r3, [pc, #8]	; (3ac8 <usb_serial_write_buffer_free+0x3c>)
    3ac0:	701a      	strb	r2, [r3, #0]
	return sum;
}
    3ac2:	4628      	mov	r0, r5
    3ac4:	bd38      	pop	{r3, r4, r5, pc}
    3ac6:	bf00      	nop
    3ac8:	20001436 	.word	0x20001436
    3acc:	20001437 	.word	0x20001437
    3ad0:	20001560 	.word	0x20001560

00003ad4 <usb_serial_flush_output>:

void usb_serial_flush_output(void)
{

	if (!usb_configuration) return;
    3ad4:	4b1f      	ldr	r3, [pc, #124]	; (3b54 <usb_serial_flush_output+0x80>)
    3ad6:	781b      	ldrb	r3, [r3, #0]
    3ad8:	f013 0fff 	tst.w	r3, #255	; 0xff
    3adc:	d039      	beq.n	3b52 <usb_serial_flush_output+0x7e>
	tx_noautoflush = 0;
	return sum;
}

void usb_serial_flush_output(void)
{
    3ade:	b570      	push	{r4, r5, r6, lr}

	if (!usb_configuration) return;
	if (tx_available == 0) return;
    3ae0:	4b1d      	ldr	r3, [pc, #116]	; (3b58 <usb_serial_flush_output+0x84>)
    3ae2:	881d      	ldrh	r5, [r3, #0]
    3ae4:	2d00      	cmp	r5, #0
    3ae6:	d033      	beq.n	3b50 <usb_serial_flush_output+0x7c>
	tx_noautoflush = 1;
    3ae8:	2201      	movs	r2, #1
    3aea:	4b1c      	ldr	r3, [pc, #112]	; (3b5c <usb_serial_flush_output+0x88>)
    3aec:	701a      	strb	r2, [r3, #0]
	transfer_t *xfer = tx_transfer + tx_head;
    3aee:	4b1c      	ldr	r3, [pc, #112]	; (3b60 <usb_serial_flush_output+0x8c>)
    3af0:	781a      	ldrb	r2, [r3, #0]
    3af2:	4e1c      	ldr	r6, [pc, #112]	; (3b64 <usb_serial_flush_output+0x90>)
    3af4:	eb06 1642 	add.w	r6, r6, r2, lsl #5
	uint8_t *txbuf = txbuffer + (tx_head * TX_SIZE);
    3af8:	4b1b      	ldr	r3, [pc, #108]	; (3b68 <usb_serial_flush_output+0x94>)
    3afa:	eb03 24c2 	add.w	r4, r3, r2, lsl #11
	uint32_t txnum = TX_SIZE - tx_available;
    3afe:	f5c5 6500 	rsb	r5, r5, #2048	; 0x800
	usb_prepare_transfer(xfer, txbuf, txnum, 0);
    3b02:	2300      	movs	r3, #0
    3b04:	462a      	mov	r2, r5
    3b06:	4621      	mov	r1, r4
    3b08:	4630      	mov	r0, r6
    3b0a:	f7ff fc59 	bl	33c0 <usb_prepare_transfer>
// any cached data written to memory, and then removed from the cache,
// because you no longer need to access the data after transmission.
__attribute__((always_inline, unused))
static inline void arm_dcache_flush_delete(void *addr, uint32_t size)
{
	uint32_t location = (uint32_t)addr & 0xFFFFFFE0;
    3b0e:	f024 031f 	bic.w	r3, r4, #31
	uint32_t end_addr = (uint32_t)addr + size;
    3b12:	192a      	adds	r2, r5, r4
	asm volatile("": : :"memory");
	asm("dsb");
    3b14:	f3bf 8f4f 	dsb	sy
	do {
		SCB_CACHE_DCCIMVAC = location;
    3b18:	4814      	ldr	r0, [pc, #80]	; (3b6c <usb_serial_flush_output+0x98>)
    3b1a:	6003      	str	r3, [r0, #0]
		location += 32;
    3b1c:	3320      	adds	r3, #32
	} while (location < end_addr);
    3b1e:	429a      	cmp	r2, r3
    3b20:	d8fa      	bhi.n	3b18 <usb_serial_flush_output+0x44>
	asm("dsb");
    3b22:	f3bf 8f4f 	dsb	sy
	asm("isb");
    3b26:	f3bf 8f6f 	isb	sy
	arm_dcache_flush_delete(txbuf, txnum);
	usb_transmit(CDC_TX_ENDPOINT, xfer);
    3b2a:	4631      	mov	r1, r6
    3b2c:	2004      	movs	r0, #4
    3b2e:	f7ff fc5f 	bl	33f0 <usb_transmit>
	if (++tx_head >= TX_NUM) tx_head = 0;
    3b32:	4a0b      	ldr	r2, [pc, #44]	; (3b60 <usb_serial_flush_output+0x8c>)
    3b34:	7813      	ldrb	r3, [r2, #0]
    3b36:	3301      	adds	r3, #1
    3b38:	b2db      	uxtb	r3, r3
    3b3a:	7013      	strb	r3, [r2, #0]
    3b3c:	2b03      	cmp	r3, #3
    3b3e:	d902      	bls.n	3b46 <usb_serial_flush_output+0x72>
    3b40:	2200      	movs	r2, #0
    3b42:	4b07      	ldr	r3, [pc, #28]	; (3b60 <usb_serial_flush_output+0x8c>)
    3b44:	701a      	strb	r2, [r3, #0]
	tx_available = 0;
    3b46:	2300      	movs	r3, #0
    3b48:	4a03      	ldr	r2, [pc, #12]	; (3b58 <usb_serial_flush_output+0x84>)
    3b4a:	8013      	strh	r3, [r2, #0]
	tx_noautoflush = 0;
    3b4c:	4a03      	ldr	r2, [pc, #12]	; (3b5c <usb_serial_flush_output+0x88>)
    3b4e:	7013      	strb	r3, [r2, #0]
    3b50:	bd70      	pop	{r4, r5, r6, pc}
    3b52:	4770      	bx	lr
    3b54:	20001420 	.word	0x20001420
    3b58:	20001550 	.word	0x20001550
    3b5c:	20001436 	.word	0x20001436
    3b60:	20001437 	.word	0x20001437
    3b64:	20001560 	.word	0x20001560
    3b68:	20200ca0 	.word	0x20200ca0
    3b6c:	e000ef70 	.word	0xe000ef70

00003b70 <software_isr()>:
}

AudioStream * AudioStream::first_update = NULL;

void software_isr(void) // AudioStream::update_all()
{
    3b70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
    3b72:	4b14      	ldr	r3, [pc, #80]	; (3bc4 <software_isr()+0x54>)
    3b74:	681e      	ldr	r6, [r3, #0]
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    3b76:	4b14      	ldr	r3, [pc, #80]	; (3bc8 <software_isr()+0x58>)
    3b78:	681c      	ldr	r4, [r3, #0]
    3b7a:	b194      	cbz	r4, 3ba2 <software_isr()+0x32>
		if (p->active) {
    3b7c:	7a23      	ldrb	r3, [r4, #8]
    3b7e:	b173      	cbz	r3, 3b9e <software_isr()+0x2e>
			uint32_t cycles = ARM_DWT_CYCCNT;
    3b80:	4d10      	ldr	r5, [pc, #64]	; (3bc4 <software_isr()+0x54>)
    3b82:	682f      	ldr	r7, [r5, #0]
			p->update();
    3b84:	6823      	ldr	r3, [r4, #0]
    3b86:	681b      	ldr	r3, [r3, #0]
    3b88:	4620      	mov	r0, r4
    3b8a:	4798      	blx	r3
			// TODO: traverse inputQueueArray and release
			// any input blocks that weren't consumed?
			cycles = (ARM_DWT_CYCCNT - cycles) >> 6;
    3b8c:	682b      	ldr	r3, [r5, #0]
    3b8e:	1bdb      	subs	r3, r3, r7
    3b90:	099b      	lsrs	r3, r3, #6
			p->cpu_cycles = cycles;
    3b92:	b29a      	uxth	r2, r3
    3b94:	80a2      	strh	r2, [r4, #4]
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
    3b96:	88e1      	ldrh	r1, [r4, #6]
    3b98:	428b      	cmp	r3, r1
    3b9a:	d900      	bls.n	3b9e <software_isr()+0x2e>
    3b9c:	80e2      	strh	r2, [r4, #6]
{
	AudioStream *p;

	uint32_t totalcycles = ARM_DWT_CYCCNT;
	//digitalWriteFast(2, HIGH);
	for (p = AudioStream::first_update; p; p = p->next_update) {
    3b9e:	6964      	ldr	r4, [r4, #20]
    3ba0:	e7eb      	b.n	3b7a <software_isr()+0xa>
			p->cpu_cycles = cycles;
			if (cycles > p->cpu_cycles_max) p->cpu_cycles_max = cycles;
		}
	}
	//digitalWriteFast(2, LOW);
	totalcycles = (ARM_DWT_CYCCNT - totalcycles) >> 6;
    3ba2:	4b08      	ldr	r3, [pc, #32]	; (3bc4 <software_isr()+0x54>)
    3ba4:	681b      	ldr	r3, [r3, #0]
    3ba6:	1b9b      	subs	r3, r3, r6
    3ba8:	099b      	lsrs	r3, r3, #6
	AudioStream::cpu_cycles_total = totalcycles;
    3baa:	b29a      	uxth	r2, r3
    3bac:	4907      	ldr	r1, [pc, #28]	; (3bcc <software_isr()+0x5c>)
    3bae:	800a      	strh	r2, [r1, #0]
	if (totalcycles > AudioStream::cpu_cycles_total_max)
    3bb0:	4907      	ldr	r1, [pc, #28]	; (3bd0 <software_isr()+0x60>)
    3bb2:	8809      	ldrh	r1, [r1, #0]
    3bb4:	428b      	cmp	r3, r1
    3bb6:	d901      	bls.n	3bbc <software_isr()+0x4c>
		AudioStream::cpu_cycles_total_max = totalcycles;
    3bb8:	4b05      	ldr	r3, [pc, #20]	; (3bd0 <software_isr()+0x60>)
    3bba:	801a      	strh	r2, [r3, #0]

	asm("DSB");
    3bbc:	f3bf 8f4f 	dsb	sy
    3bc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3bc2:	bf00      	nop
    3bc4:	e0001004 	.word	0xe0001004
    3bc8:	200015fc 	.word	0x200015fc
    3bcc:	2000167a 	.word	0x2000167a
    3bd0:	200015f8 	.word	0x200015f8

00003bd4 <AudioStream::allocate()>:
	audio_block_t *block;
	uint32_t used;

	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
    3bd4:	b672      	cpsid	i
	index = memory_pool_first_mask;
    3bd6:	4b1d      	ldr	r3, [pc, #116]	; (3c4c <AudioStream::allocate()+0x78>)
    3bd8:	8819      	ldrh	r1, [r3, #0]
	p += index;
    3bda:	4b1d      	ldr	r3, [pc, #116]	; (3c50 <AudioStream::allocate()+0x7c>)
    3bdc:	eb03 0381 	add.w	r3, r3, r1, lsl #2
	while (1) {
		if (p >= end) {
    3be0:	4a1c      	ldr	r2, [pc, #112]	; (3c54 <AudioStream::allocate()+0x80>)
    3be2:	4293      	cmp	r3, r2
    3be4:	d302      	bcc.n	3bec <AudioStream::allocate()+0x18>
			__enable_irq();
    3be6:	b662      	cpsie	i
			//Serial.println("alloc:null");
			return NULL;
    3be8:	2000      	movs	r0, #0
	block->ref_count = 1;
	if (used > memory_used_max) memory_used_max = used;
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    3bea:	4770      	bx	lr
		if (p >= end) {
			__enable_irq();
			//Serial.println("alloc:null");
			return NULL;
		}
		avail = *p;
    3bec:	681a      	ldr	r2, [r3, #0]
		if (avail) break;
    3bee:	b912      	cbnz	r2, 3bf6 <AudioStream::allocate()+0x22>
		index++;
    3bf0:	3101      	adds	r1, #1
		p++;
    3bf2:	3304      	adds	r3, #4
	p = memory_pool_available_mask;
	end = p + NUM_MASKS;
	__disable_irq();
	index = memory_pool_first_mask;
	p += index;
	while (1) {
    3bf4:	e7f4      	b.n	3be0 <AudioStream::allocate()+0xc>
}

// Allocate 1 audio data block.  If successful
// the caller is the only owner of this new block
audio_block_t * AudioStream::allocate(void)
{
    3bf6:	b430      	push	{r4, r5}
		avail = *p;
		if (avail) break;
		index++;
		p++;
	}
	n = __builtin_clz(avail);
    3bf8:	fab2 f082 	clz	r0, r2
	avail &= ~(0x80000000 >> n);
    3bfc:	f04f 4400 	mov.w	r4, #2147483648	; 0x80000000
    3c00:	40c4      	lsrs	r4, r0
    3c02:	ea22 0204 	bic.w	r2, r2, r4
	*p = avail;
    3c06:	601a      	str	r2, [r3, #0]
	if (!avail) index++;
    3c08:	b902      	cbnz	r2, 3c0c <AudioStream::allocate()+0x38>
    3c0a:	3101      	adds	r1, #1
	memory_pool_first_mask = index;
    3c0c:	4a0f      	ldr	r2, [pc, #60]	; (3c4c <AudioStream::allocate()+0x78>)
    3c0e:	8011      	strh	r1, [r2, #0]
	used = memory_used + 1;
    3c10:	4911      	ldr	r1, [pc, #68]	; (3c58 <AudioStream::allocate()+0x84>)
    3c12:	880a      	ldrh	r2, [r1, #0]
    3c14:	3201      	adds	r2, #1
	memory_used = used;
    3c16:	b294      	uxth	r4, r2
    3c18:	800c      	strh	r4, [r1, #0]
	__enable_irq();
    3c1a:	b662      	cpsie	i
	index = p - memory_pool_available_mask;
    3c1c:	490c      	ldr	r1, [pc, #48]	; (3c50 <AudioStream::allocate()+0x7c>)
    3c1e:	1a5b      	subs	r3, r3, r1
    3c20:	109b      	asrs	r3, r3, #2
	block = memory_pool + ((index << 5) + (31 - n));
    3c22:	490e      	ldr	r1, [pc, #56]	; (3c5c <AudioStream::allocate()+0x88>)
    3c24:	6809      	ldr	r1, [r1, #0]
    3c26:	ebc0 1343 	rsb	r3, r0, r3, lsl #5
    3c2a:	eb03 1383 	add.w	r3, r3, r3, lsl #6
    3c2e:	0098      	lsls	r0, r3, #2
    3c30:	f641 737c 	movw	r3, #8060	; 0x1f7c
    3c34:	4403      	add	r3, r0
    3c36:	18c8      	adds	r0, r1, r3
	block->ref_count = 1;
    3c38:	2501      	movs	r5, #1
    3c3a:	54cd      	strb	r5, [r1, r3]
	if (used > memory_used_max) memory_used_max = used;
    3c3c:	4b08      	ldr	r3, [pc, #32]	; (3c60 <AudioStream::allocate()+0x8c>)
    3c3e:	881b      	ldrh	r3, [r3, #0]
    3c40:	429a      	cmp	r2, r3
    3c42:	d901      	bls.n	3c48 <AudioStream::allocate()+0x74>
    3c44:	4b06      	ldr	r3, [pc, #24]	; (3c60 <AudioStream::allocate()+0x8c>)
    3c46:	801c      	strh	r4, [r3, #0]
	//Serial.print("alloc:");
	//Serial.println((uint32_t)block, HEX);
	return block;
}
    3c48:	bc30      	pop	{r4, r5}
    3c4a:	4770      	bx	lr
    3c4c:	20001676 	.word	0x20001676
    3c50:	20001600 	.word	0x20001600
    3c54:	20001670 	.word	0x20001670
    3c58:	20001678 	.word	0x20001678
    3c5c:	20001670 	.word	0x20001670
    3c60:	200015f6 	.word	0x200015f6

00003c64 <AudioStream::release(audio_block_struct*)>:
// other streams have ownership, the block is
// returned to the free pool
void AudioStream::release(audio_block_t *block)
{
	//if (block == NULL) return;
	uint32_t mask = (0x80000000 >> (31 - (block->memory_pool_index & 0x1F)));
    3c64:	8843      	ldrh	r3, [r0, #2]
    3c66:	43da      	mvns	r2, r3
    3c68:	f002 011f 	and.w	r1, r2, #31
    3c6c:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
    3c70:	40ca      	lsrs	r2, r1
	uint32_t index = block->memory_pool_index >> 5;
    3c72:	115b      	asrs	r3, r3, #5

	__disable_irq();
    3c74:	b672      	cpsid	i
	if (block->ref_count > 1) {
    3c76:	7801      	ldrb	r1, [r0, #0]
    3c78:	2901      	cmp	r1, #1
    3c7a:	d902      	bls.n	3c82 <AudioStream::release(audio_block_struct*)+0x1e>
		block->ref_count--;
    3c7c:	3901      	subs	r1, #1
    3c7e:	7001      	strb	r1, [r0, #0]
    3c80:	e00f      	b.n	3ca2 <AudioStream::release(audio_block_struct*)+0x3e>
	} else {
		//Serial.print("reles:");
		//Serial.println((uint32_t)block, HEX);
		memory_pool_available_mask[index] |= mask;
    3c82:	4909      	ldr	r1, [pc, #36]	; (3ca8 <AudioStream::release(audio_block_struct*)+0x44>)
    3c84:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    3c88:	4302      	orrs	r2, r0
    3c8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
		if (index < memory_pool_first_mask) memory_pool_first_mask = index;
    3c8e:	4a07      	ldr	r2, [pc, #28]	; (3cac <AudioStream::release(audio_block_struct*)+0x48>)
    3c90:	8812      	ldrh	r2, [r2, #0]
    3c92:	4293      	cmp	r3, r2
    3c94:	d201      	bcs.n	3c9a <AudioStream::release(audio_block_struct*)+0x36>
    3c96:	4a05      	ldr	r2, [pc, #20]	; (3cac <AudioStream::release(audio_block_struct*)+0x48>)
    3c98:	8013      	strh	r3, [r2, #0]
		memory_used--;
    3c9a:	4a05      	ldr	r2, [pc, #20]	; (3cb0 <AudioStream::release(audio_block_struct*)+0x4c>)
    3c9c:	8813      	ldrh	r3, [r2, #0]
    3c9e:	3b01      	subs	r3, #1
    3ca0:	8013      	strh	r3, [r2, #0]
	}
	__enable_irq();
    3ca2:	b662      	cpsie	i
    3ca4:	4770      	bx	lr
    3ca6:	bf00      	nop
    3ca8:	20001600 	.word	0x20001600
    3cac:	20001676 	.word	0x20001676
    3cb0:	20001678 	.word	0x20001678

00003cb4 <AudioStream::update_setup()>:
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    3cb4:	4b09      	ldr	r3, [pc, #36]	; (3cdc <AudioStream::update_setup()+0x28>)
    3cb6:	781b      	ldrb	r3, [r3, #0]
    3cb8:	b973      	cbnz	r3, 3cd8 <AudioStream::update_setup()+0x24>
#define DMA_NUM_CHANNELS        32

#ifdef __cplusplus
extern "C" void (* _VectorsRam[NVIC_NUM_INTERRUPTS+16])(void);
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) __attribute__((always_inline, unused));
static inline void attachInterruptVector(IRQ_NUMBER_t irq, void (*function)(void)) { _VectorsRam[irq + 16] = function; asm volatile("": : :"memory"); }
    3cba:	4a09      	ldr	r2, [pc, #36]	; (3ce0 <AudioStream::update_setup()+0x2c>)
    3cbc:	4b09      	ldr	r3, [pc, #36]	; (3ce4 <AudioStream::update_setup()+0x30>)
    3cbe:	f8c3 2158 	str.w	r2, [r3, #344]	; 0x158
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
    3cc2:	22d0      	movs	r2, #208	; 0xd0
    3cc4:	4b08      	ldr	r3, [pc, #32]	; (3ce8 <AudioStream::update_setup()+0x34>)
    3cc6:	701a      	strb	r2, [r3, #0]
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
    3cc8:	2240      	movs	r2, #64	; 0x40
    3cca:	f2a3 333e 	subw	r3, r3, #830	; 0x33e
    3cce:	601a      	str	r2, [r3, #0]
	update_scheduled = true;
    3cd0:	2001      	movs	r0, #1
    3cd2:	4b02      	ldr	r3, [pc, #8]	; (3cdc <AudioStream::update_setup()+0x28>)
    3cd4:	7018      	strb	r0, [r3, #0]
	return true;
    3cd6:	4770      	bx	lr
// their constructors.
bool AudioStream::update_scheduled = false;

bool AudioStream::update_setup(void)
{
	if (update_scheduled) return false;
    3cd8:	2000      	movs	r0, #0
	attachInterruptVector(IRQ_SOFTWARE, software_isr);
	NVIC_SET_PRIORITY(IRQ_SOFTWARE, 208); // 255 = lowest priority
	NVIC_ENABLE_IRQ(IRQ_SOFTWARE);
	update_scheduled = true;
	return true;
}
    3cda:	4770      	bx	lr
    3cdc:	20001674 	.word	0x20001674
    3ce0:	00003b71 	.word	0x00003b71
    3ce4:	20001800 	.word	0x20001800
    3ce8:	e000e446 	.word	0xe000e446

00003cec <DMAChannel::begin(bool)>:

void DMAChannel::begin(bool force_initialization)
{
	uint32_t ch = 0;

	__disable_irq();
    3cec:	b672      	cpsid	i
	if (!force_initialization && TCD && channel < DMA_MAX_CHANNELS
    3cee:	b989      	cbnz	r1, 3d14 <DMAChannel::begin(bool)+0x28>
    3cf0:	6802      	ldr	r2, [r0, #0]
    3cf2:	b18a      	cbz	r2, 3d18 <DMAChannel::begin(bool)+0x2c>
    3cf4:	7903      	ldrb	r3, [r0, #4]
    3cf6:	2b0f      	cmp	r3, #15
    3cf8:	d810      	bhi.n	3d1c <DMAChannel::begin(bool)+0x30>
	  && (dma_channel_allocated_mask & (1 << channel))
    3cfa:	4926      	ldr	r1, [pc, #152]	; (3d94 <DMAChannel::begin(bool)+0xa8>)
    3cfc:	8809      	ldrh	r1, [r1, #0]
    3cfe:	4119      	asrs	r1, r3
    3d00:	f011 0f01 	tst.w	r1, #1
    3d04:	d00c      	beq.n	3d20 <DMAChannel::begin(bool)+0x34>
	  && (uint32_t)TCD == (uint32_t)(0x400E9000 + channel * 32)) {
    3d06:	4924      	ldr	r1, [pc, #144]	; (3d98 <DMAChannel::begin(bool)+0xac>)
    3d08:	4419      	add	r1, r3
    3d0a:	ebb2 1f41 	cmp.w	r2, r1, lsl #5
    3d0e:	d109      	bne.n	3d24 <DMAChannel::begin(bool)+0x38>
		// DMA channel already allocated
		__enable_irq();
    3d10:	b662      	cpsie	i
		return;
    3d12:	4770      	bx	lr
    3d14:	2300      	movs	r3, #0
    3d16:	e006      	b.n	3d26 <DMAChannel::begin(bool)+0x3a>
    3d18:	2300      	movs	r3, #0
    3d1a:	e004      	b.n	3d26 <DMAChannel::begin(bool)+0x3a>
    3d1c:	2300      	movs	r3, #0
    3d1e:	e002      	b.n	3d26 <DMAChannel::begin(bool)+0x3a>
    3d20:	2300      	movs	r3, #0
    3d22:	e000      	b.n	3d26 <DMAChannel::begin(bool)+0x3a>
    3d24:	2300      	movs	r3, #0
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
    3d26:	4a1b      	ldr	r2, [pc, #108]	; (3d94 <DMAChannel::begin(bool)+0xa8>)
    3d28:	8812      	ldrh	r2, [r2, #0]
    3d2a:	fa42 f103 	asr.w	r1, r2, r3
    3d2e:	f011 0f01 	tst.w	r1, #1
    3d32:	d123      	bne.n	3d7c <DMAChannel::begin(bool)+0x90>
#warning "CR is defined as something?"
#endif


void DMAChannel::begin(bool force_initialization)
{
    3d34:	b410      	push	{r4}
		__enable_irq();
		return;
	}
	while (1) {
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
    3d36:	2101      	movs	r1, #1
    3d38:	4099      	lsls	r1, r3
    3d3a:	430a      	orrs	r2, r1
    3d3c:	4915      	ldr	r1, [pc, #84]	; (3d94 <DMAChannel::begin(bool)+0xa8>)
    3d3e:	800a      	strh	r2, [r1, #0]
			__enable_irq();
    3d40:	b662      	cpsie	i
			channel = DMA_MAX_CHANNELS;
			return; // no more channels available
			// attempts to use this object will hardfault
		}
	}
	channel = ch;
    3d42:	b2d9      	uxtb	r1, r3
    3d44:	7101      	strb	r1, [r0, #4]

	CCM_CCGR5 |= CCM_CCGR5_DMA(CCM_CCGR_ON);
    3d46:	4c15      	ldr	r4, [pc, #84]	; (3d9c <DMAChannel::begin(bool)+0xb0>)
    3d48:	6fe2      	ldr	r2, [r4, #124]	; 0x7c
    3d4a:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
    3d4e:	67e2      	str	r2, [r4, #124]	; 0x7c
	DMA_CR = DMA_CR_GRP1PRI | DMA_CR_EMLM | DMA_CR_EDBG;
    3d50:	4a13      	ldr	r2, [pc, #76]	; (3da0 <DMAChannel::begin(bool)+0xb4>)
    3d52:	f240 4482 	movw	r4, #1154	; 0x482
    3d56:	6014      	str	r4, [r2, #0]
	DMA_CERQ = ch;
    3d58:	7691      	strb	r1, [r2, #26]
	DMA_CERR = ch;
    3d5a:	7791      	strb	r1, [r2, #30]
	DMA_CEEI = ch;
    3d5c:	7611      	strb	r1, [r2, #24]
	DMA_CINT = ch;
    3d5e:	77d1      	strb	r1, [r2, #31]
	TCD = (TCD_t *)(0x400E9000 + ch * 32);
    3d60:	4a0d      	ldr	r2, [pc, #52]	; (3d98 <DMAChannel::begin(bool)+0xac>)
    3d62:	441a      	add	r2, r3
    3d64:	0153      	lsls	r3, r2, #5
    3d66:	6003      	str	r3, [r0, #0]
	uint32_t *p = (uint32_t *)TCD;
	*p++ = 0;
    3d68:	2200      	movs	r2, #0
    3d6a:	601a      	str	r2, [r3, #0]
	*p++ = 0;
    3d6c:	605a      	str	r2, [r3, #4]
	*p++ = 0;
    3d6e:	609a      	str	r2, [r3, #8]
	*p++ = 0;
    3d70:	60da      	str	r2, [r3, #12]
	*p++ = 0;
    3d72:	611a      	str	r2, [r3, #16]
	*p++ = 0;
    3d74:	615a      	str	r2, [r3, #20]
	*p++ = 0;
    3d76:	619a      	str	r2, [r3, #24]
	*p++ = 0;
    3d78:	61da      	str	r2, [r3, #28]
    3d7a:	e008      	b.n	3d8e <DMAChannel::begin(bool)+0xa2>
		if (!(dma_channel_allocated_mask & (1 << ch))) {
			dma_channel_allocated_mask |= (1 << ch);
			__enable_irq();
			break;
		}
		if (++ch >= DMA_MAX_CHANNELS) {
    3d7c:	3301      	adds	r3, #1
    3d7e:	2b0f      	cmp	r3, #15
    3d80:	d9d1      	bls.n	3d26 <DMAChannel::begin(bool)+0x3a>
			__enable_irq();
    3d82:	b662      	cpsie	i
			TCD = (TCD_t *)0;
    3d84:	2300      	movs	r3, #0
    3d86:	6003      	str	r3, [r0, #0]
			channel = DMA_MAX_CHANNELS;
    3d88:	2310      	movs	r3, #16
    3d8a:	7103      	strb	r3, [r0, #4]
			return; // no more channels available
    3d8c:	4770      	bx	lr
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
	*p++ = 0;
}
    3d8e:	f85d 4b04 	ldr.w	r4, [sp], #4
    3d92:	4770      	bx	lr
    3d94:	2000167c 	.word	0x2000167c
    3d98:	02007480 	.word	0x02007480
    3d9c:	400fc000 	.word	0x400fc000
    3da0:	400e8000 	.word	0x400e8000

00003da4 <DMAChannel::release()>:

void DMAChannel::release(void)
{
	if (channel >= DMA_MAX_CHANNELS) return;
    3da4:	7903      	ldrb	r3, [r0, #4]
    3da6:	2b0f      	cmp	r3, #15
    3da8:	d810      	bhi.n	3dcc <DMAChannel::release()+0x28>
	DMA_CERQ = channel;
    3daa:	4a09      	ldr	r2, [pc, #36]	; (3dd0 <DMAChannel::release()+0x2c>)
    3dac:	7693      	strb	r3, [r2, #26]
	__disable_irq();
    3dae:	b672      	cpsid	i
	dma_channel_allocated_mask &= ~(1 << channel);
    3db0:	7902      	ldrb	r2, [r0, #4]
    3db2:	2301      	movs	r3, #1
    3db4:	fa03 f202 	lsl.w	r2, r3, r2
    3db8:	4906      	ldr	r1, [pc, #24]	; (3dd4 <DMAChannel::release()+0x30>)
    3dba:	880b      	ldrh	r3, [r1, #0]
    3dbc:	ea23 0302 	bic.w	r3, r3, r2
    3dc0:	800b      	strh	r3, [r1, #0]
	__enable_irq();
    3dc2:	b662      	cpsie	i
	channel = DMA_MAX_CHANNELS;
    3dc4:	2310      	movs	r3, #16
    3dc6:	7103      	strb	r3, [r0, #4]
	TCD = (TCD_t *)0;
    3dc8:	2300      	movs	r3, #0
    3dca:	6003      	str	r3, [r0, #0]
    3dcc:	4770      	bx	lr
    3dce:	bf00      	nop
    3dd0:	400e8000 	.word	0x400e8000
    3dd4:	2000167c 	.word	0x2000167c

00003dd8 <EventResponder::runFromInterrupt()>:
{
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
    3dd8:	b508      	push	{r3, lr}
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3dda:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    3dde:	b672      	cpsid	i
	while (1) {
		bool irq = disableInterrupts();
		EventResponder *first = firstInterrupt;
    3de0:	4b0b      	ldr	r3, [pc, #44]	; (3e10 <EventResponder::runFromInterrupt()+0x38>)
    3de2:	6818      	ldr	r0, [r3, #0]
		if (first) {
    3de4:	b180      	cbz	r0, 3e08 <EventResponder::runFromInterrupt()+0x30>
			firstInterrupt = first->_next;
    3de6:	6943      	ldr	r3, [r0, #20]
    3de8:	4909      	ldr	r1, [pc, #36]	; (3e10 <EventResponder::runFromInterrupt()+0x38>)
    3dea:	600b      	str	r3, [r1, #0]
			if (firstInterrupt) {
    3dec:	b113      	cbz	r3, 3df4 <EventResponder::runFromInterrupt()+0x1c>
				firstInterrupt->_prev = nullptr;
    3dee:	2100      	movs	r1, #0
    3df0:	6199      	str	r1, [r3, #24]
    3df2:	e002      	b.n	3dfa <EventResponder::runFromInterrupt()+0x22>
			} else {
				lastInterrupt = nullptr;
    3df4:	2100      	movs	r1, #0
    3df6:	4b07      	ldr	r3, [pc, #28]	; (3e14 <EventResponder::runFromInterrupt()+0x3c>)
    3df8:	6019      	str	r1, [r3, #0]
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3dfa:	b902      	cbnz	r2, 3dfe <EventResponder::runFromInterrupt()+0x26>
    3dfc:	b662      	cpsie	i
			}
			enableInterrupts(irq);
			first->_triggered = false;
    3dfe:	2300      	movs	r3, #0
    3e00:	7743      	strb	r3, [r0, #29]
			(*(first->_function))(*first);
    3e02:	6883      	ldr	r3, [r0, #8]
    3e04:	4798      	blx	r3
	EventResponder::runFromInterrupt();
}

void EventResponder::runFromInterrupt()
{
	while (1) {
    3e06:	e7e8      	b.n	3dda <EventResponder::runFromInterrupt()+0x2>
    3e08:	b902      	cbnz	r2, 3e0c <EventResponder::runFromInterrupt()+0x34>
    3e0a:	b662      	cpsie	i
    3e0c:	bd08      	pop	{r3, pc}
    3e0e:	bf00      	nop
    3e10:	20001680 	.word	0x20001680
    3e14:	20001684 	.word	0x20001684

00003e18 <pendablesrvreq_isr>:
	}
	enableInterrupts(irq);
}

extern "C" void pendablesrvreq_isr(void)
{
    3e18:	b508      	push	{r3, lr}
	EventResponder::runFromInterrupt();
    3e1a:	f7ff ffdd 	bl	3dd8 <EventResponder::runFromInterrupt()>
    3e1e:	bd08      	pop	{r3, pc}

00003e20 <systick_isr>:
extern "C" volatile uint32_t systick_millis_count;
extern "C" volatile uint32_t systick_cycle_count;
extern "C" uint32_t systick_safe_read; // micros() synchronization
extern "C" void systick_isr(void)
{
	systick_cycle_count = ARM_DWT_CYCCNT;
    3e20:	4b04      	ldr	r3, [pc, #16]	; (3e34 <systick_isr+0x14>)
    3e22:	681a      	ldr	r2, [r3, #0]
    3e24:	4b04      	ldr	r3, [pc, #16]	; (3e38 <systick_isr+0x18>)
    3e26:	601a      	str	r2, [r3, #0]
	systick_millis_count++;
    3e28:	4a04      	ldr	r2, [pc, #16]	; (3e3c <systick_isr+0x1c>)
    3e2a:	6813      	ldr	r3, [r2, #0]
    3e2c:	3301      	adds	r3, #1
    3e2e:	6013      	str	r3, [r2, #0]
    3e30:	4770      	bx	lr
    3e32:	bf00      	nop
    3e34:	e0001004 	.word	0xe0001004
    3e38:	200013cc 	.word	0x200013cc
    3e3c:	200013d4 	.word	0x200013d4

00003e40 <Print::write(unsigned char const*, unsigned int)>:
#include "debug/printf.h"
#undef printf

size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    3e40:	b179      	cbz	r1, 3e62 <Print::write(unsigned char const*, unsigned int)+0x22>

#include "debug/printf.h"
#undef printf

size_t Print::write(const uint8_t *buffer, size_t size)
{
    3e42:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    3e44:	4605      	mov	r5, r0
    3e46:	460b      	mov	r3, r1
    3e48:	2400      	movs	r4, #0
	if (buffer == nullptr) return 0;
	size_t count = 0;
	while (size--) count += write(*buffer++);
    3e4a:	1e56      	subs	r6, r2, #1
    3e4c:	b15a      	cbz	r2, 3e66 <Print::write(unsigned char const*, unsigned int)+0x26>
    3e4e:	682a      	ldr	r2, [r5, #0]
    3e50:	6812      	ldr	r2, [r2, #0]
    3e52:	1c5f      	adds	r7, r3, #1
    3e54:	7819      	ldrb	r1, [r3, #0]
    3e56:	4628      	mov	r0, r5
    3e58:	4790      	blx	r2
    3e5a:	4404      	add	r4, r0
    3e5c:	4632      	mov	r2, r6
    3e5e:	463b      	mov	r3, r7
    3e60:	e7f3      	b.n	3e4a <Print::write(unsigned char const*, unsigned int)+0xa>
#include "debug/printf.h"
#undef printf

size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
    3e62:	2000      	movs	r0, #0
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
}
    3e64:	4770      	bx	lr
size_t Print::write(const uint8_t *buffer, size_t size)
{
	if (buffer == nullptr) return 0;
	size_t count = 0;
	while (size--) count += write(*buffer++);
	return count;
    3e66:	4620      	mov	r0, r4
}
    3e68:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    3e6a:	bf00      	nop

00003e6c <Print::println()>:
	return printNumber(n, 10, sign);
}


size_t Print::println(void)
{
    3e6c:	b500      	push	{lr}
    3e6e:	b083      	sub	sp, #12
	uint8_t buf[2]={'\r', '\n'};
    3e70:	4b05      	ldr	r3, [pc, #20]	; (3e88 <Print::println()+0x1c>)
    3e72:	881b      	ldrh	r3, [r3, #0]
    3e74:	f8ad 3004 	strh.w	r3, [sp, #4]
	return write(buf, 2);
    3e78:	6803      	ldr	r3, [r0, #0]
    3e7a:	685b      	ldr	r3, [r3, #4]
    3e7c:	2202      	movs	r2, #2
    3e7e:	a901      	add	r1, sp, #4
    3e80:	4798      	blx	r3
}
    3e82:	b003      	add	sp, #12
    3e84:	f85d fb04 	ldr.w	pc, [sp], #4
    3e88:	20000610 	.word	0x20000610

00003e8c <main>:
 */

#include <Arduino.h>

extern "C" int main(void)
{
    3e8c:	b508      	push	{r3, lr}
	}


#else
	// Arduino's main() function just calls setup() and loop()....
	setup();
    3e8e:	f7fc f973 	bl	178 <setup>
	while (1) {
		loop();
    3e92:	f7fc f9cd 	bl	230 <loop>
		yield();
    3e96:	f000 f829 	bl	3eec <yield>
    3e9a:	e7fa      	b.n	3e92 <main+0x6>

00003e9c <operator new[](unsigned int)>:
{
	return malloc(size);
}

void * operator new[](size_t size)
{
    3e9c:	b508      	push	{r3, lr}
	return malloc(size);
    3e9e:	f000 f8fd 	bl	409c <malloc>
}
    3ea2:	bd08      	pop	{r3, pc}

00003ea4 <usb_serial_class::clear()>:
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
    3ea4:	b508      	push	{r3, lr}
    3ea6:	f7ff fcf9 	bl	389c <usb_serial_flush_input>
    3eaa:	bd08      	pop	{r3, pc}

00003eac <usb_serial_class::peek()>:
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
    3eac:	b508      	push	{r3, lr}
    3eae:	f7ff fcc9 	bl	3844 <usb_serial_peekchar>
    3eb2:	bd08      	pop	{r3, pc}

00003eb4 <usb_serial_class::read()>:
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
    3eb4:	b508      	push	{r3, lr}
    3eb6:	f7ff fd1f 	bl	38f8 <usb_serial_getchar>
    3eba:	bd08      	pop	{r3, pc}

00003ebc <usb_serial_class::available()>:
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    3ebc:	b508      	push	{r3, lr}
    3ebe:	f7ff fce7 	bl	3890 <usb_serial_available>
    3ec2:	bd08      	pop	{r3, pc}

00003ec4 <usb_serial_class::flush()>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
    3ec4:	b508      	push	{r3, lr}
    3ec6:	f7ff fe05 	bl	3ad4 <usb_serial_flush_output>
    3eca:	bd08      	pop	{r3, pc}

00003ecc <usb_serial_class::availableForWrite()>:
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
	size_t write(unsigned long n) { return write((uint8_t)n); }
	size_t write(long n) { return write((uint8_t)n); }
	size_t write(unsigned int n) { return write((uint8_t)n); }
	size_t write(int n) { return write((uint8_t)n); }
	virtual int availableForWrite() { return usb_serial_write_buffer_free(); }
    3ecc:	b508      	push	{r3, lr}
    3ece:	f7ff fddd 	bl	3a8c <usb_serial_write_buffer_free>
    3ed2:	bd08      	pop	{r3, pc}

00003ed4 <usb_serial_class::write(unsigned char const*, unsigned int)>:
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
        virtual size_t write(const uint8_t *buffer, size_t size) { return usb_serial_write(buffer, size); }
    3ed4:	b508      	push	{r3, lr}
    3ed6:	4608      	mov	r0, r1
    3ed8:	4611      	mov	r1, r2
    3eda:	f7ff fd1d 	bl	3918 <usb_serial_write>
    3ede:	bd08      	pop	{r3, pc}

00003ee0 <usb_serial_class::write(unsigned char)>:
        virtual int available() { return usb_serial_available(); }
        virtual int read() { return usb_serial_getchar(); }
        virtual int peek() { return usb_serial_peekchar(); }
        virtual void flush() { usb_serial_flush_output(); }  // TODO: actually wait for data to leave USB...
        virtual void clear(void) { usb_serial_flush_input(); }
        virtual size_t write(uint8_t c) { return usb_serial_putchar(c); }
    3ee0:	b508      	push	{r3, lr}
    3ee2:	4608      	mov	r0, r1
    3ee4:	f7ff fdc6 	bl	3a74 <usb_serial_putchar>
    3ee8:	bd08      	pop	{r3, pc}
    3eea:	bf00      	nop

00003eec <yield>:

extern const uint8_t _serialEvent_default;	

void yield(void) __attribute__ ((weak));
void yield(void)
{
    3eec:	b538      	push	{r3, r4, r5, lr}
	static uint8_t running=0;
	if (!yield_active_check_flags) return;	// nothing to do
    3eee:	4b33      	ldr	r3, [pc, #204]	; (3fbc <yield+0xd0>)
    3ef0:	781b      	ldrb	r3, [r3, #0]
    3ef2:	2b00      	cmp	r3, #0
    3ef4:	d060      	beq.n	3fb8 <yield+0xcc>
	if (running) return; // TODO: does this need to be atomic?
    3ef6:	4a32      	ldr	r2, [pc, #200]	; (3fc0 <yield+0xd4>)
    3ef8:	7812      	ldrb	r2, [r2, #0]
    3efa:	2a00      	cmp	r2, #0
    3efc:	d15c      	bne.n	3fb8 <yield+0xcc>
	running = 1;
    3efe:	2101      	movs	r1, #1
    3f00:	4a2f      	ldr	r2, [pc, #188]	; (3fc0 <yield+0xd4>)
    3f02:	7011      	strb	r1, [r2, #0]


	// USB Serail - Add hack to minimize impact...
	if (yield_active_check_flags & YIELD_CHECK_USB_SERIAL) {
    3f04:	f013 0f01 	tst.w	r3, #1
    3f08:	d00c      	beq.n	3f24 <yield+0x38>
			// sketch still gets to run normally after this wait time.
			//if ((uint32_t)(systick_millis_count - millis_begin) > 2500) break;
		//}
	}
        void end() { /* TODO: flush output and shut down USB port */ };
        virtual int available() { return usb_serial_available(); }
    3f0a:	f7ff fcc1 	bl	3890 <usb_serial_available>
		if (Serial.available()) serialEvent();
    3f0e:	b108      	cbz	r0, 3f14 <yield+0x28>
    3f10:	f000 f888 	bl	4024 <serialEvent()>
		if (_serialEvent_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIAL;
    3f14:	4b2b      	ldr	r3, [pc, #172]	; (3fc4 <yield+0xd8>)
    3f16:	781b      	ldrb	r3, [r3, #0]
    3f18:	b123      	cbz	r3, 3f24 <yield+0x38>
    3f1a:	4a28      	ldr	r2, [pc, #160]	; (3fbc <yield+0xd0>)
    3f1c:	7813      	ldrb	r3, [r2, #0]
    3f1e:	f023 0301 	bic.w	r3, r3, #1
    3f22:	7013      	strb	r3, [r2, #0]
		if (_serialEventUSB2_default) yield_active_check_flags &= ~YIELD_CHECK_USB_SERIALUSB2;
	}
#endif

	// Current workaround until integrate with EventResponder.
	if (yield_active_check_flags & YIELD_CHECK_HARDWARE_SERIAL) HardwareSerial::processSerialEventsList();
    3f24:	4b25      	ldr	r3, [pc, #148]	; (3fbc <yield+0xd0>)
    3f26:	781b      	ldrb	r3, [r3, #0]
    3f28:	f013 0f02 	tst.w	r3, #2
    3f2c:	d012      	beq.n	3f54 <yield+0x68>
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    3f2e:	2400      	movs	r4, #0
    3f30:	4b25      	ldr	r3, [pc, #148]	; (3fc8 <yield+0xdc>)
    3f32:	781b      	ldrb	r3, [r3, #0]
    3f34:	42a3      	cmp	r3, r4
    3f36:	d90d      	bls.n	3f54 <yield+0x68>
			s_serials_with_serial_events[i]->doYieldCode();
    3f38:	4b24      	ldr	r3, [pc, #144]	; (3fcc <yield+0xe0>)
    3f3a:	f853 5024 	ldr.w	r5, [r3, r4, lsl #2]
	static HardwareSerial 	*s_serials_with_serial_events[7];
	#endif
	static uint8_t 			s_count_serials_with_serial_events;
	void addToSerialEventsList(); 
	inline void doYieldCode()  {
		if (available()) (*hardware->_serialEvent)();
    3f3e:	682b      	ldr	r3, [r5, #0]
    3f40:	691b      	ldr	r3, [r3, #16]
    3f42:	4628      	mov	r0, r5
    3f44:	4798      	blx	r3
    3f46:	b110      	cbz	r0, 3f4e <yield+0x62>
    3f48:	696b      	ldr	r3, [r5, #20]
    3f4a:	689b      	ldr	r3, [r3, #8]
    3f4c:	4798      	blx	r3
	*/

	operator bool()			{ return true; }

	static inline void processSerialEventsList() {
		for (uint8_t i = 0; i < s_count_serials_with_serial_events; i++) {
    3f4e:	3401      	adds	r4, #1
    3f50:	b2e4      	uxtb	r4, r4
    3f52:	e7ed      	b.n	3f30 <yield+0x44>

	running = 0;
    3f54:	2200      	movs	r2, #0
    3f56:	4b1a      	ldr	r3, [pc, #104]	; (3fc0 <yield+0xd4>)
    3f58:	701a      	strb	r2, [r3, #0]
	if (yield_active_check_flags & YIELD_CHECK_EVENT_RESPONDER) EventResponder::runFromYield();
    3f5a:	4b18      	ldr	r3, [pc, #96]	; (3fbc <yield+0xd0>)
    3f5c:	781b      	ldrb	r3, [r3, #0]
    3f5e:	f013 0f04 	tst.w	r3, #4
    3f62:	d029      	beq.n	3fb8 <yield+0xcc>
	// Wait for event(s) to occur.  These are most likely to be useful when
	// used with a scheduler or RTOS.
	bool waitForEvent(EventResponderRef event, int timeout);
	EventResponder * waitForEvent(EventResponder *list, int listsize, int timeout);
	static void runFromYield() {
		if (!firstYield) return;  
    3f64:	4b1a      	ldr	r3, [pc, #104]	; (3fd0 <yield+0xe4>)
    3f66:	681b      	ldr	r3, [r3, #0]
    3f68:	b333      	cbz	r3, 3fb8 <yield+0xcc>
		// First, check if yield was called from an interrupt
		// never call normal handler functions from any interrupt context
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
    3f6a:	f3ef 8305 	mrs	r3, IPSR
		if (ipsr != 0) return;
    3f6e:	bb1b      	cbnz	r3, 3fb8 <yield+0xcc>
	static EventResponder *lastInterrupt;
	static bool runningFromYield;
private:
	static bool disableInterrupts() {
		uint32_t primask;
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
    3f70:	f3ef 8210 	mrs	r2, PRIMASK
		__disable_irq();
    3f74:	b672      	cpsid	i
		uint32_t ipsr;
		__asm__ volatile("mrs %0, ipsr\n" : "=r" (ipsr)::);
		if (ipsr != 0) return;
		// Next, check if any events have been triggered
		bool irq = disableInterrupts();
		EventResponder *first = firstYield;
    3f76:	4b16      	ldr	r3, [pc, #88]	; (3fd0 <yield+0xe4>)
    3f78:	6818      	ldr	r0, [r3, #0]
		if (first == nullptr) {
    3f7a:	b910      	cbnz	r0, 3f82 <yield+0x96>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3f7c:	b9e2      	cbnz	r2, 3fb8 <yield+0xcc>
    3f7e:	b662      	cpsie	i
    3f80:	bd38      	pop	{r3, r4, r5, pc}
			return;
		}
		// Finally, make sure we're not being recursively called,
		// which can happen if the user's function does anything
		// that calls yield.
		if (runningFromYield) {
    3f82:	4b14      	ldr	r3, [pc, #80]	; (3fd4 <yield+0xe8>)
    3f84:	781b      	ldrb	r3, [r3, #0]
    3f86:	b113      	cbz	r3, 3f8e <yield+0xa2>
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3f88:	b9b2      	cbnz	r2, 3fb8 <yield+0xcc>
    3f8a:	b662      	cpsie	i
    3f8c:	bd38      	pop	{r3, r4, r5, pc}
		if (runningFromYield) {
			enableInterrupts(irq);
			return;
		}
		// Ok, update the runningFromYield flag and process event
		runningFromYield = true;
    3f8e:	2101      	movs	r1, #1
    3f90:	4b10      	ldr	r3, [pc, #64]	; (3fd4 <yield+0xe8>)
    3f92:	7019      	strb	r1, [r3, #0]
		firstYield = first->_next;
    3f94:	6943      	ldr	r3, [r0, #20]
    3f96:	490e      	ldr	r1, [pc, #56]	; (3fd0 <yield+0xe4>)
    3f98:	600b      	str	r3, [r1, #0]
		if (firstYield) {
    3f9a:	b113      	cbz	r3, 3fa2 <yield+0xb6>
			firstYield->_prev = nullptr;
    3f9c:	2100      	movs	r1, #0
    3f9e:	6199      	str	r1, [r3, #24]
    3fa0:	e002      	b.n	3fa8 <yield+0xbc>
		} else {
			lastYield = nullptr;
    3fa2:	2100      	movs	r1, #0
    3fa4:	4b0c      	ldr	r3, [pc, #48]	; (3fd8 <yield+0xec>)
    3fa6:	6019      	str	r1, [r3, #0]
		__asm__ volatile("mrs %0, primask\n" : "=r" (primask)::);
		__disable_irq();
		return (primask == 0) ? true : false;
	}
	static void enableInterrupts(bool doit) {
		if (doit) __enable_irq();
    3fa8:	b902      	cbnz	r2, 3fac <yield+0xc0>
    3faa:	b662      	cpsie	i
			firstYield->_prev = nullptr;
		} else {
			lastYield = nullptr;
		}
		enableInterrupts(irq);
		first->_triggered = false;
    3fac:	2400      	movs	r4, #0
    3fae:	7744      	strb	r4, [r0, #29]
		(*(first->_function))(*first);
    3fb0:	6883      	ldr	r3, [r0, #8]
    3fb2:	4798      	blx	r3
		runningFromYield = false;
    3fb4:	4b07      	ldr	r3, [pc, #28]	; (3fd4 <yield+0xe8>)
    3fb6:	701c      	strb	r4, [r3, #0]
    3fb8:	bd38      	pop	{r3, r4, r5, pc}
    3fba:	bf00      	nop
    3fbc:	20000754 	.word	0x20000754
    3fc0:	20001691 	.word	0x20001691
    3fc4:	60001866 	.word	0x60001866
    3fc8:	200016b0 	.word	0x200016b0
    3fcc:	20001694 	.word	0x20001694
    3fd0:	2000168c 	.word	0x2000168c
    3fd4:	20001690 	.word	0x20001690
    3fd8:	20001688 	.word	0x20001688

00003fdc <ultoa>:
#include <stdlib.h>
#include <math.h>


char * ultoa(unsigned long val, char *buf, int radix)
{
    3fdc:	b470      	push	{r4, r5, r6}
	unsigned digit;
	int i=0, j;
    3fde:	2400      	movs	r4, #0
	char t;

	while (1) {
		digit = val % radix;
    3fe0:	fbb0 f3f2 	udiv	r3, r0, r2
    3fe4:	fb02 0313 	mls	r3, r2, r3, r0
		buf[i] = ((digit < 10) ? '0' + digit : 'A' + digit - 10);
    3fe8:	4626      	mov	r6, r4
    3fea:	190d      	adds	r5, r1, r4
    3fec:	2b09      	cmp	r3, #9
    3fee:	d802      	bhi.n	3ff6 <ultoa+0x1a>
    3ff0:	3330      	adds	r3, #48	; 0x30
    3ff2:	b2db      	uxtb	r3, r3
    3ff4:	e001      	b.n	3ffa <ultoa+0x1e>
    3ff6:	3337      	adds	r3, #55	; 0x37
    3ff8:	b2db      	uxtb	r3, r3
    3ffa:	702b      	strb	r3, [r5, #0]
		val /= radix;
    3ffc:	fbb0 f0f2 	udiv	r0, r0, r2
		if (val == 0) break;
    4000:	b108      	cbz	r0, 4006 <ultoa+0x2a>
		i++;
    4002:	3401      	adds	r4, #1
	}
    4004:	e7ec      	b.n	3fe0 <ultoa+0x4>
	buf[i + 1] = 0;
    4006:	3601      	adds	r6, #1
    4008:	2300      	movs	r3, #0
    400a:	558b      	strb	r3, [r1, r6]
	for (j=0; j < i; j++, i--) {
    400c:	e005      	b.n	401a <ultoa+0x3e>
		t = buf[j];
    400e:	5cca      	ldrb	r2, [r1, r3]
		buf[j] = buf[i];
    4010:	5d08      	ldrb	r0, [r1, r4]
    4012:	54c8      	strb	r0, [r1, r3]
		buf[i] = t;
    4014:	550a      	strb	r2, [r1, r4]
		val /= radix;
		if (val == 0) break;
		i++;
	}
	buf[i + 1] = 0;
	for (j=0; j < i; j++, i--) {
    4016:	3301      	adds	r3, #1
    4018:	3c01      	subs	r4, #1
    401a:	429c      	cmp	r4, r3
    401c:	dcf7      	bgt.n	400e <ultoa+0x32>
		t = buf[j];
		buf[j] = buf[i];
		buf[i] = t;
	}
	return buf;
}
    401e:	4608      	mov	r0, r1
    4020:	bc70      	pop	{r4, r5, r6}
    4022:	4770      	bx	lr

00004024 <serialEvent()>:

#include <Arduino.h>
void serialEvent() __attribute__((weak));
void serialEvent() {
    4024:	4770      	bx	lr
    4026:	bf00      	nop

00004028 <__aeabi_atexit>:
    4028:	460b      	mov	r3, r1
    402a:	4601      	mov	r1, r0
    402c:	4618      	mov	r0, r3
    402e:	f000 b801 	b.w	4034 <__cxa_atexit>
    4032:	bf00      	nop

00004034 <__cxa_atexit>:
    4034:	4613      	mov	r3, r2
    4036:	460a      	mov	r2, r1
    4038:	4601      	mov	r1, r0
    403a:	2002      	movs	r0, #2
    403c:	f000 bb52 	b.w	46e4 <__register_exitproc>

00004040 <__errno>:
    4040:	4b01      	ldr	r3, [pc, #4]	; (4048 <__errno+0x8>)
    4042:	6818      	ldr	r0, [r3, #0]
    4044:	4770      	bx	lr
    4046:	bf00      	nop
    4048:	20000b80 	.word	0x20000b80

0000404c <__libc_init_array>:
    404c:	b570      	push	{r4, r5, r6, lr}
    404e:	4e0f      	ldr	r6, [pc, #60]	; (408c <__libc_init_array+0x40>)
    4050:	4d0f      	ldr	r5, [pc, #60]	; (4090 <__libc_init_array+0x44>)
    4052:	1b76      	subs	r6, r6, r5
    4054:	10b6      	asrs	r6, r6, #2
    4056:	bf18      	it	ne
    4058:	2400      	movne	r4, #0
    405a:	d005      	beq.n	4068 <__libc_init_array+0x1c>
    405c:	3401      	adds	r4, #1
    405e:	f855 3b04 	ldr.w	r3, [r5], #4
    4062:	4798      	blx	r3
    4064:	42a6      	cmp	r6, r4
    4066:	d1f9      	bne.n	405c <__libc_init_array+0x10>
    4068:	4e0a      	ldr	r6, [pc, #40]	; (4094 <__libc_init_array+0x48>)
    406a:	4d0b      	ldr	r5, [pc, #44]	; (4098 <__libc_init_array+0x4c>)
    406c:	1b76      	subs	r6, r6, r5
    406e:	f000 fccb 	bl	4a08 <___init_veneer>
    4072:	10b6      	asrs	r6, r6, #2
    4074:	bf18      	it	ne
    4076:	2400      	movne	r4, #0
    4078:	d006      	beq.n	4088 <__libc_init_array+0x3c>
    407a:	3401      	adds	r4, #1
    407c:	f855 3b04 	ldr.w	r3, [r5], #4
    4080:	4798      	blx	r3
    4082:	42a6      	cmp	r6, r4
    4084:	d1f9      	bne.n	407a <__libc_init_array+0x2e>
    4086:	bd70      	pop	{r4, r5, r6, pc}
    4088:	bd70      	pop	{r4, r5, r6, pc}
    408a:	bf00      	nop
    408c:	600018c8 	.word	0x600018c8
    4090:	600018c8 	.word	0x600018c8
    4094:	6000193c 	.word	0x6000193c
    4098:	600018c8 	.word	0x600018c8

0000409c <malloc>:
    409c:	4b02      	ldr	r3, [pc, #8]	; (40a8 <malloc+0xc>)
    409e:	4601      	mov	r1, r0
    40a0:	6818      	ldr	r0, [r3, #0]
    40a2:	f000 b803 	b.w	40ac <_malloc_r>
    40a6:	bf00      	nop
    40a8:	20000b80 	.word	0x20000b80

000040ac <_malloc_r>:
    40ac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    40b0:	f101 050b 	add.w	r5, r1, #11
    40b4:	2d16      	cmp	r5, #22
    40b6:	b083      	sub	sp, #12
    40b8:	4606      	mov	r6, r0
    40ba:	f240 809f 	bls.w	41fc <_malloc_r+0x150>
    40be:	f035 0507 	bics.w	r5, r5, #7
    40c2:	f100 80bf 	bmi.w	4244 <_malloc_r+0x198>
    40c6:	42a9      	cmp	r1, r5
    40c8:	f200 80bc 	bhi.w	4244 <_malloc_r+0x198>
    40cc:	f000 faf4 	bl	46b8 <__malloc_lock>
    40d0:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
    40d4:	f0c0 829c 	bcc.w	4610 <_malloc_r+0x564>
    40d8:	0a6b      	lsrs	r3, r5, #9
    40da:	f000 80ba 	beq.w	4252 <_malloc_r+0x1a6>
    40de:	2b04      	cmp	r3, #4
    40e0:	f200 8183 	bhi.w	43ea <_malloc_r+0x33e>
    40e4:	09a8      	lsrs	r0, r5, #6
    40e6:	f100 0e39 	add.w	lr, r0, #57	; 0x39
    40ea:	ea4f 034e 	mov.w	r3, lr, lsl #1
    40ee:	3038      	adds	r0, #56	; 0x38
    40f0:	4fc4      	ldr	r7, [pc, #784]	; (4404 <_malloc_r+0x358>)
    40f2:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    40f6:	f1a3 0108 	sub.w	r1, r3, #8
    40fa:	685c      	ldr	r4, [r3, #4]
    40fc:	42a1      	cmp	r1, r4
    40fe:	d107      	bne.n	4110 <_malloc_r+0x64>
    4100:	e0ac      	b.n	425c <_malloc_r+0x1b0>
    4102:	2a00      	cmp	r2, #0
    4104:	f280 80ac 	bge.w	4260 <_malloc_r+0x1b4>
    4108:	68e4      	ldr	r4, [r4, #12]
    410a:	42a1      	cmp	r1, r4
    410c:	f000 80a6 	beq.w	425c <_malloc_r+0x1b0>
    4110:	6863      	ldr	r3, [r4, #4]
    4112:	f023 0303 	bic.w	r3, r3, #3
    4116:	1b5a      	subs	r2, r3, r5
    4118:	2a0f      	cmp	r2, #15
    411a:	ddf2      	ble.n	4102 <_malloc_r+0x56>
    411c:	49b9      	ldr	r1, [pc, #740]	; (4404 <_malloc_r+0x358>)
    411e:	693c      	ldr	r4, [r7, #16]
    4120:	f101 0e08 	add.w	lr, r1, #8
    4124:	4574      	cmp	r4, lr
    4126:	f000 81b3 	beq.w	4490 <_malloc_r+0x3e4>
    412a:	6863      	ldr	r3, [r4, #4]
    412c:	f023 0303 	bic.w	r3, r3, #3
    4130:	1b5a      	subs	r2, r3, r5
    4132:	2a0f      	cmp	r2, #15
    4134:	f300 8199 	bgt.w	446a <_malloc_r+0x3be>
    4138:	2a00      	cmp	r2, #0
    413a:	f8c1 e014 	str.w	lr, [r1, #20]
    413e:	f8c1 e010 	str.w	lr, [r1, #16]
    4142:	f280 809e 	bge.w	4282 <_malloc_r+0x1d6>
    4146:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    414a:	f080 8167 	bcs.w	441c <_malloc_r+0x370>
    414e:	08db      	lsrs	r3, r3, #3
    4150:	f103 0c01 	add.w	ip, r3, #1
    4154:	2201      	movs	r2, #1
    4156:	109b      	asrs	r3, r3, #2
    4158:	fa02 f303 	lsl.w	r3, r2, r3
    415c:	684a      	ldr	r2, [r1, #4]
    415e:	f851 803c 	ldr.w	r8, [r1, ip, lsl #3]
    4162:	f8c4 8008 	str.w	r8, [r4, #8]
    4166:	eb01 09cc 	add.w	r9, r1, ip, lsl #3
    416a:	431a      	orrs	r2, r3
    416c:	f1a9 0308 	sub.w	r3, r9, #8
    4170:	60e3      	str	r3, [r4, #12]
    4172:	604a      	str	r2, [r1, #4]
    4174:	f841 403c 	str.w	r4, [r1, ip, lsl #3]
    4178:	f8c8 400c 	str.w	r4, [r8, #12]
    417c:	1083      	asrs	r3, r0, #2
    417e:	2401      	movs	r4, #1
    4180:	409c      	lsls	r4, r3
    4182:	4294      	cmp	r4, r2
    4184:	f200 808a 	bhi.w	429c <_malloc_r+0x1f0>
    4188:	4214      	tst	r4, r2
    418a:	d106      	bne.n	419a <_malloc_r+0xee>
    418c:	f020 0003 	bic.w	r0, r0, #3
    4190:	0064      	lsls	r4, r4, #1
    4192:	4214      	tst	r4, r2
    4194:	f100 0004 	add.w	r0, r0, #4
    4198:	d0fa      	beq.n	4190 <_malloc_r+0xe4>
    419a:	eb07 09c0 	add.w	r9, r7, r0, lsl #3
    419e:	46cc      	mov	ip, r9
    41a0:	4680      	mov	r8, r0
    41a2:	f8dc 100c 	ldr.w	r1, [ip, #12]
    41a6:	458c      	cmp	ip, r1
    41a8:	d107      	bne.n	41ba <_malloc_r+0x10e>
    41aa:	e173      	b.n	4494 <_malloc_r+0x3e8>
    41ac:	2a00      	cmp	r2, #0
    41ae:	f280 8181 	bge.w	44b4 <_malloc_r+0x408>
    41b2:	68c9      	ldr	r1, [r1, #12]
    41b4:	458c      	cmp	ip, r1
    41b6:	f000 816d 	beq.w	4494 <_malloc_r+0x3e8>
    41ba:	684b      	ldr	r3, [r1, #4]
    41bc:	f023 0303 	bic.w	r3, r3, #3
    41c0:	1b5a      	subs	r2, r3, r5
    41c2:	2a0f      	cmp	r2, #15
    41c4:	ddf2      	ble.n	41ac <_malloc_r+0x100>
    41c6:	460c      	mov	r4, r1
    41c8:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    41cc:	f854 8f08 	ldr.w	r8, [r4, #8]!
    41d0:	194b      	adds	r3, r1, r5
    41d2:	f045 0501 	orr.w	r5, r5, #1
    41d6:	604d      	str	r5, [r1, #4]
    41d8:	f042 0101 	orr.w	r1, r2, #1
    41dc:	f8c8 c00c 	str.w	ip, [r8, #12]
    41e0:	4630      	mov	r0, r6
    41e2:	f8cc 8008 	str.w	r8, [ip, #8]
    41e6:	617b      	str	r3, [r7, #20]
    41e8:	613b      	str	r3, [r7, #16]
    41ea:	f8c3 e00c 	str.w	lr, [r3, #12]
    41ee:	f8c3 e008 	str.w	lr, [r3, #8]
    41f2:	6059      	str	r1, [r3, #4]
    41f4:	509a      	str	r2, [r3, r2]
    41f6:	f000 fa61 	bl	46bc <__malloc_unlock>
    41fa:	e01f      	b.n	423c <_malloc_r+0x190>
    41fc:	2910      	cmp	r1, #16
    41fe:	d821      	bhi.n	4244 <_malloc_r+0x198>
    4200:	f000 fa5a 	bl	46b8 <__malloc_lock>
    4204:	2510      	movs	r5, #16
    4206:	2306      	movs	r3, #6
    4208:	2002      	movs	r0, #2
    420a:	4f7e      	ldr	r7, [pc, #504]	; (4404 <_malloc_r+0x358>)
    420c:	eb07 0383 	add.w	r3, r7, r3, lsl #2
    4210:	f1a3 0208 	sub.w	r2, r3, #8
    4214:	685c      	ldr	r4, [r3, #4]
    4216:	4294      	cmp	r4, r2
    4218:	f000 8145 	beq.w	44a6 <_malloc_r+0x3fa>
    421c:	6863      	ldr	r3, [r4, #4]
    421e:	68e1      	ldr	r1, [r4, #12]
    4220:	68a5      	ldr	r5, [r4, #8]
    4222:	f023 0303 	bic.w	r3, r3, #3
    4226:	4423      	add	r3, r4
    4228:	4630      	mov	r0, r6
    422a:	685a      	ldr	r2, [r3, #4]
    422c:	60e9      	str	r1, [r5, #12]
    422e:	f042 0201 	orr.w	r2, r2, #1
    4232:	608d      	str	r5, [r1, #8]
    4234:	605a      	str	r2, [r3, #4]
    4236:	f000 fa41 	bl	46bc <__malloc_unlock>
    423a:	3408      	adds	r4, #8
    423c:	4620      	mov	r0, r4
    423e:	b003      	add	sp, #12
    4240:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4244:	2400      	movs	r4, #0
    4246:	230c      	movs	r3, #12
    4248:	4620      	mov	r0, r4
    424a:	6033      	str	r3, [r6, #0]
    424c:	b003      	add	sp, #12
    424e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4252:	2380      	movs	r3, #128	; 0x80
    4254:	f04f 0e40 	mov.w	lr, #64	; 0x40
    4258:	203f      	movs	r0, #63	; 0x3f
    425a:	e749      	b.n	40f0 <_malloc_r+0x44>
    425c:	4670      	mov	r0, lr
    425e:	e75d      	b.n	411c <_malloc_r+0x70>
    4260:	4423      	add	r3, r4
    4262:	68e1      	ldr	r1, [r4, #12]
    4264:	685a      	ldr	r2, [r3, #4]
    4266:	68a5      	ldr	r5, [r4, #8]
    4268:	f042 0201 	orr.w	r2, r2, #1
    426c:	60e9      	str	r1, [r5, #12]
    426e:	4630      	mov	r0, r6
    4270:	608d      	str	r5, [r1, #8]
    4272:	605a      	str	r2, [r3, #4]
    4274:	f000 fa22 	bl	46bc <__malloc_unlock>
    4278:	3408      	adds	r4, #8
    427a:	4620      	mov	r0, r4
    427c:	b003      	add	sp, #12
    427e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    4282:	4423      	add	r3, r4
    4284:	4630      	mov	r0, r6
    4286:	685a      	ldr	r2, [r3, #4]
    4288:	f042 0201 	orr.w	r2, r2, #1
    428c:	605a      	str	r2, [r3, #4]
    428e:	f000 fa15 	bl	46bc <__malloc_unlock>
    4292:	3408      	adds	r4, #8
    4294:	4620      	mov	r0, r4
    4296:	b003      	add	sp, #12
    4298:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    429c:	68bc      	ldr	r4, [r7, #8]
    429e:	6863      	ldr	r3, [r4, #4]
    42a0:	f023 0803 	bic.w	r8, r3, #3
    42a4:	45a8      	cmp	r8, r5
    42a6:	d304      	bcc.n	42b2 <_malloc_r+0x206>
    42a8:	ebc5 0308 	rsb	r3, r5, r8
    42ac:	2b0f      	cmp	r3, #15
    42ae:	f300 808c 	bgt.w	43ca <_malloc_r+0x31e>
    42b2:	4b55      	ldr	r3, [pc, #340]	; (4408 <_malloc_r+0x35c>)
    42b4:	f8df 9160 	ldr.w	r9, [pc, #352]	; 4418 <_malloc_r+0x36c>
    42b8:	681a      	ldr	r2, [r3, #0]
    42ba:	f8d9 3000 	ldr.w	r3, [r9]
    42be:	3301      	adds	r3, #1
    42c0:	442a      	add	r2, r5
    42c2:	eb04 0a08 	add.w	sl, r4, r8
    42c6:	f000 8160 	beq.w	458a <_malloc_r+0x4de>
    42ca:	f502 5280 	add.w	r2, r2, #4096	; 0x1000
    42ce:	320f      	adds	r2, #15
    42d0:	f422 627f 	bic.w	r2, r2, #4080	; 0xff0
    42d4:	f022 020f 	bic.w	r2, r2, #15
    42d8:	4611      	mov	r1, r2
    42da:	4630      	mov	r0, r6
    42dc:	9201      	str	r2, [sp, #4]
    42de:	f000 f9ef 	bl	46c0 <_sbrk_r>
    42e2:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
    42e6:	4683      	mov	fp, r0
    42e8:	9a01      	ldr	r2, [sp, #4]
    42ea:	f000 8158 	beq.w	459e <_malloc_r+0x4f2>
    42ee:	4582      	cmp	sl, r0
    42f0:	f200 80fc 	bhi.w	44ec <_malloc_r+0x440>
    42f4:	4b45      	ldr	r3, [pc, #276]	; (440c <_malloc_r+0x360>)
    42f6:	6819      	ldr	r1, [r3, #0]
    42f8:	45da      	cmp	sl, fp
    42fa:	4411      	add	r1, r2
    42fc:	6019      	str	r1, [r3, #0]
    42fe:	f000 8153 	beq.w	45a8 <_malloc_r+0x4fc>
    4302:	f8d9 0000 	ldr.w	r0, [r9]
    4306:	f8df e110 	ldr.w	lr, [pc, #272]	; 4418 <_malloc_r+0x36c>
    430a:	3001      	adds	r0, #1
    430c:	bf1b      	ittet	ne
    430e:	ebca 0a0b 	rsbne	sl, sl, fp
    4312:	4451      	addne	r1, sl
    4314:	f8ce b000 	streq.w	fp, [lr]
    4318:	6019      	strne	r1, [r3, #0]
    431a:	f01b 0107 	ands.w	r1, fp, #7
    431e:	f000 8117 	beq.w	4550 <_malloc_r+0x4a4>
    4322:	f1c1 0008 	rsb	r0, r1, #8
    4326:	f5c1 5180 	rsb	r1, r1, #4096	; 0x1000
    432a:	4483      	add	fp, r0
    432c:	3108      	adds	r1, #8
    432e:	445a      	add	r2, fp
    4330:	f3c2 020b 	ubfx	r2, r2, #0, #12
    4334:	ebc2 0901 	rsb	r9, r2, r1
    4338:	4649      	mov	r1, r9
    433a:	4630      	mov	r0, r6
    433c:	9301      	str	r3, [sp, #4]
    433e:	f000 f9bf 	bl	46c0 <_sbrk_r>
    4342:	1c43      	adds	r3, r0, #1
    4344:	9b01      	ldr	r3, [sp, #4]
    4346:	f000 813f 	beq.w	45c8 <_malloc_r+0x51c>
    434a:	ebcb 0200 	rsb	r2, fp, r0
    434e:	444a      	add	r2, r9
    4350:	f042 0201 	orr.w	r2, r2, #1
    4354:	6819      	ldr	r1, [r3, #0]
    4356:	f8c7 b008 	str.w	fp, [r7, #8]
    435a:	4449      	add	r1, r9
    435c:	42bc      	cmp	r4, r7
    435e:	f8cb 2004 	str.w	r2, [fp, #4]
    4362:	6019      	str	r1, [r3, #0]
    4364:	f8df 90a4 	ldr.w	r9, [pc, #164]	; 440c <_malloc_r+0x360>
    4368:	d016      	beq.n	4398 <_malloc_r+0x2ec>
    436a:	f1b8 0f0f 	cmp.w	r8, #15
    436e:	f240 80fd 	bls.w	456c <_malloc_r+0x4c0>
    4372:	6862      	ldr	r2, [r4, #4]
    4374:	f1a8 030c 	sub.w	r3, r8, #12
    4378:	f023 0307 	bic.w	r3, r3, #7
    437c:	18e0      	adds	r0, r4, r3
    437e:	f002 0201 	and.w	r2, r2, #1
    4382:	f04f 0e05 	mov.w	lr, #5
    4386:	431a      	orrs	r2, r3
    4388:	2b0f      	cmp	r3, #15
    438a:	6062      	str	r2, [r4, #4]
    438c:	f8c0 e004 	str.w	lr, [r0, #4]
    4390:	f8c0 e008 	str.w	lr, [r0, #8]
    4394:	f200 811c 	bhi.w	45d0 <_malloc_r+0x524>
    4398:	4b1d      	ldr	r3, [pc, #116]	; (4410 <_malloc_r+0x364>)
    439a:	68bc      	ldr	r4, [r7, #8]
    439c:	681a      	ldr	r2, [r3, #0]
    439e:	4291      	cmp	r1, r2
    43a0:	bf88      	it	hi
    43a2:	6019      	strhi	r1, [r3, #0]
    43a4:	4b1b      	ldr	r3, [pc, #108]	; (4414 <_malloc_r+0x368>)
    43a6:	681a      	ldr	r2, [r3, #0]
    43a8:	4291      	cmp	r1, r2
    43aa:	6862      	ldr	r2, [r4, #4]
    43ac:	bf88      	it	hi
    43ae:	6019      	strhi	r1, [r3, #0]
    43b0:	f022 0203 	bic.w	r2, r2, #3
    43b4:	4295      	cmp	r5, r2
    43b6:	eba2 0305 	sub.w	r3, r2, r5
    43ba:	d801      	bhi.n	43c0 <_malloc_r+0x314>
    43bc:	2b0f      	cmp	r3, #15
    43be:	dc04      	bgt.n	43ca <_malloc_r+0x31e>
    43c0:	4630      	mov	r0, r6
    43c2:	f000 f97b 	bl	46bc <__malloc_unlock>
    43c6:	2400      	movs	r4, #0
    43c8:	e738      	b.n	423c <_malloc_r+0x190>
    43ca:	1962      	adds	r2, r4, r5
    43cc:	f043 0301 	orr.w	r3, r3, #1
    43d0:	f045 0501 	orr.w	r5, r5, #1
    43d4:	6065      	str	r5, [r4, #4]
    43d6:	4630      	mov	r0, r6
    43d8:	60ba      	str	r2, [r7, #8]
    43da:	6053      	str	r3, [r2, #4]
    43dc:	f000 f96e 	bl	46bc <__malloc_unlock>
    43e0:	3408      	adds	r4, #8
    43e2:	4620      	mov	r0, r4
    43e4:	b003      	add	sp, #12
    43e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    43ea:	2b14      	cmp	r3, #20
    43ec:	d971      	bls.n	44d2 <_malloc_r+0x426>
    43ee:	2b54      	cmp	r3, #84	; 0x54
    43f0:	f200 80a4 	bhi.w	453c <_malloc_r+0x490>
    43f4:	0b28      	lsrs	r0, r5, #12
    43f6:	f100 0e6f 	add.w	lr, r0, #111	; 0x6f
    43fa:	ea4f 034e 	mov.w	r3, lr, lsl #1
    43fe:	306e      	adds	r0, #110	; 0x6e
    4400:	e676      	b.n	40f0 <_malloc_r+0x44>
    4402:	bf00      	nop
    4404:	20000b84 	.word	0x20000b84
    4408:	200016bc 	.word	0x200016bc
    440c:	200016c0 	.word	0x200016c0
    4410:	200016b8 	.word	0x200016b8
    4414:	200016b4 	.word	0x200016b4
    4418:	20000f90 	.word	0x20000f90
    441c:	0a5a      	lsrs	r2, r3, #9
    441e:	2a04      	cmp	r2, #4
    4420:	d95e      	bls.n	44e0 <_malloc_r+0x434>
    4422:	2a14      	cmp	r2, #20
    4424:	f200 80b3 	bhi.w	458e <_malloc_r+0x4e2>
    4428:	f102 015c 	add.w	r1, r2, #92	; 0x5c
    442c:	0049      	lsls	r1, r1, #1
    442e:	325b      	adds	r2, #91	; 0x5b
    4430:	eb07 0c81 	add.w	ip, r7, r1, lsl #2
    4434:	f857 1021 	ldr.w	r1, [r7, r1, lsl #2]
    4438:	f8df 81dc 	ldr.w	r8, [pc, #476]	; 4618 <_malloc_r+0x56c>
    443c:	f1ac 0c08 	sub.w	ip, ip, #8
    4440:	458c      	cmp	ip, r1
    4442:	f000 8088 	beq.w	4556 <_malloc_r+0x4aa>
    4446:	684a      	ldr	r2, [r1, #4]
    4448:	f022 0203 	bic.w	r2, r2, #3
    444c:	4293      	cmp	r3, r2
    444e:	d202      	bcs.n	4456 <_malloc_r+0x3aa>
    4450:	6889      	ldr	r1, [r1, #8]
    4452:	458c      	cmp	ip, r1
    4454:	d1f7      	bne.n	4446 <_malloc_r+0x39a>
    4456:	f8d1 c00c 	ldr.w	ip, [r1, #12]
    445a:	687a      	ldr	r2, [r7, #4]
    445c:	f8c4 c00c 	str.w	ip, [r4, #12]
    4460:	60a1      	str	r1, [r4, #8]
    4462:	f8cc 4008 	str.w	r4, [ip, #8]
    4466:	60cc      	str	r4, [r1, #12]
    4468:	e688      	b.n	417c <_malloc_r+0xd0>
    446a:	1963      	adds	r3, r4, r5
    446c:	f042 0701 	orr.w	r7, r2, #1
    4470:	f045 0501 	orr.w	r5, r5, #1
    4474:	6065      	str	r5, [r4, #4]
    4476:	4630      	mov	r0, r6
    4478:	614b      	str	r3, [r1, #20]
    447a:	610b      	str	r3, [r1, #16]
    447c:	f8c3 e00c 	str.w	lr, [r3, #12]
    4480:	f8c3 e008 	str.w	lr, [r3, #8]
    4484:	605f      	str	r7, [r3, #4]
    4486:	509a      	str	r2, [r3, r2]
    4488:	3408      	adds	r4, #8
    448a:	f000 f917 	bl	46bc <__malloc_unlock>
    448e:	e6d5      	b.n	423c <_malloc_r+0x190>
    4490:	684a      	ldr	r2, [r1, #4]
    4492:	e673      	b.n	417c <_malloc_r+0xd0>
    4494:	f108 0801 	add.w	r8, r8, #1
    4498:	f018 0f03 	tst.w	r8, #3
    449c:	f10c 0c08 	add.w	ip, ip, #8
    44a0:	f47f ae7f 	bne.w	41a2 <_malloc_r+0xf6>
    44a4:	e030      	b.n	4508 <_malloc_r+0x45c>
    44a6:	68dc      	ldr	r4, [r3, #12]
    44a8:	42a3      	cmp	r3, r4
    44aa:	bf08      	it	eq
    44ac:	3002      	addeq	r0, #2
    44ae:	f43f ae35 	beq.w	411c <_malloc_r+0x70>
    44b2:	e6b3      	b.n	421c <_malloc_r+0x170>
    44b4:	440b      	add	r3, r1
    44b6:	460c      	mov	r4, r1
    44b8:	685a      	ldr	r2, [r3, #4]
    44ba:	68c9      	ldr	r1, [r1, #12]
    44bc:	f854 5f08 	ldr.w	r5, [r4, #8]!
    44c0:	f042 0201 	orr.w	r2, r2, #1
    44c4:	605a      	str	r2, [r3, #4]
    44c6:	4630      	mov	r0, r6
    44c8:	60e9      	str	r1, [r5, #12]
    44ca:	608d      	str	r5, [r1, #8]
    44cc:	f000 f8f6 	bl	46bc <__malloc_unlock>
    44d0:	e6b4      	b.n	423c <_malloc_r+0x190>
    44d2:	f103 0e5c 	add.w	lr, r3, #92	; 0x5c
    44d6:	f103 005b 	add.w	r0, r3, #91	; 0x5b
    44da:	ea4f 034e 	mov.w	r3, lr, lsl #1
    44de:	e607      	b.n	40f0 <_malloc_r+0x44>
    44e0:	099a      	lsrs	r2, r3, #6
    44e2:	f102 0139 	add.w	r1, r2, #57	; 0x39
    44e6:	0049      	lsls	r1, r1, #1
    44e8:	3238      	adds	r2, #56	; 0x38
    44ea:	e7a1      	b.n	4430 <_malloc_r+0x384>
    44ec:	42bc      	cmp	r4, r7
    44ee:	4b4a      	ldr	r3, [pc, #296]	; (4618 <_malloc_r+0x56c>)
    44f0:	f43f af00 	beq.w	42f4 <_malloc_r+0x248>
    44f4:	689c      	ldr	r4, [r3, #8]
    44f6:	6862      	ldr	r2, [r4, #4]
    44f8:	f022 0203 	bic.w	r2, r2, #3
    44fc:	e75a      	b.n	43b4 <_malloc_r+0x308>
    44fe:	f859 3908 	ldr.w	r3, [r9], #-8
    4502:	4599      	cmp	r9, r3
    4504:	f040 8082 	bne.w	460c <_malloc_r+0x560>
    4508:	f010 0f03 	tst.w	r0, #3
    450c:	f100 30ff 	add.w	r0, r0, #4294967295	; 0xffffffff
    4510:	d1f5      	bne.n	44fe <_malloc_r+0x452>
    4512:	687b      	ldr	r3, [r7, #4]
    4514:	ea23 0304 	bic.w	r3, r3, r4
    4518:	607b      	str	r3, [r7, #4]
    451a:	0064      	lsls	r4, r4, #1
    451c:	429c      	cmp	r4, r3
    451e:	f63f aebd 	bhi.w	429c <_malloc_r+0x1f0>
    4522:	2c00      	cmp	r4, #0
    4524:	f43f aeba 	beq.w	429c <_malloc_r+0x1f0>
    4528:	421c      	tst	r4, r3
    452a:	4640      	mov	r0, r8
    452c:	f47f ae35 	bne.w	419a <_malloc_r+0xee>
    4530:	0064      	lsls	r4, r4, #1
    4532:	421c      	tst	r4, r3
    4534:	f100 0004 	add.w	r0, r0, #4
    4538:	d0fa      	beq.n	4530 <_malloc_r+0x484>
    453a:	e62e      	b.n	419a <_malloc_r+0xee>
    453c:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
    4540:	d818      	bhi.n	4574 <_malloc_r+0x4c8>
    4542:	0be8      	lsrs	r0, r5, #15
    4544:	f100 0e78 	add.w	lr, r0, #120	; 0x78
    4548:	ea4f 034e 	mov.w	r3, lr, lsl #1
    454c:	3077      	adds	r0, #119	; 0x77
    454e:	e5cf      	b.n	40f0 <_malloc_r+0x44>
    4550:	f44f 5180 	mov.w	r1, #4096	; 0x1000
    4554:	e6eb      	b.n	432e <_malloc_r+0x282>
    4556:	2101      	movs	r1, #1
    4558:	f8d8 3004 	ldr.w	r3, [r8, #4]
    455c:	1092      	asrs	r2, r2, #2
    455e:	fa01 f202 	lsl.w	r2, r1, r2
    4562:	431a      	orrs	r2, r3
    4564:	f8c8 2004 	str.w	r2, [r8, #4]
    4568:	4661      	mov	r1, ip
    456a:	e777      	b.n	445c <_malloc_r+0x3b0>
    456c:	2301      	movs	r3, #1
    456e:	f8cb 3004 	str.w	r3, [fp, #4]
    4572:	e725      	b.n	43c0 <_malloc_r+0x314>
    4574:	f240 5254 	movw	r2, #1364	; 0x554
    4578:	4293      	cmp	r3, r2
    457a:	d820      	bhi.n	45be <_malloc_r+0x512>
    457c:	0ca8      	lsrs	r0, r5, #18
    457e:	f100 0e7d 	add.w	lr, r0, #125	; 0x7d
    4582:	ea4f 034e 	mov.w	r3, lr, lsl #1
    4586:	307c      	adds	r0, #124	; 0x7c
    4588:	e5b2      	b.n	40f0 <_malloc_r+0x44>
    458a:	3210      	adds	r2, #16
    458c:	e6a4      	b.n	42d8 <_malloc_r+0x22c>
    458e:	2a54      	cmp	r2, #84	; 0x54
    4590:	d826      	bhi.n	45e0 <_malloc_r+0x534>
    4592:	0b1a      	lsrs	r2, r3, #12
    4594:	f102 016f 	add.w	r1, r2, #111	; 0x6f
    4598:	0049      	lsls	r1, r1, #1
    459a:	326e      	adds	r2, #110	; 0x6e
    459c:	e748      	b.n	4430 <_malloc_r+0x384>
    459e:	68bc      	ldr	r4, [r7, #8]
    45a0:	6862      	ldr	r2, [r4, #4]
    45a2:	f022 0203 	bic.w	r2, r2, #3
    45a6:	e705      	b.n	43b4 <_malloc_r+0x308>
    45a8:	f3ca 000b 	ubfx	r0, sl, #0, #12
    45ac:	2800      	cmp	r0, #0
    45ae:	f47f aea8 	bne.w	4302 <_malloc_r+0x256>
    45b2:	4442      	add	r2, r8
    45b4:	68bb      	ldr	r3, [r7, #8]
    45b6:	f042 0201 	orr.w	r2, r2, #1
    45ba:	605a      	str	r2, [r3, #4]
    45bc:	e6ec      	b.n	4398 <_malloc_r+0x2ec>
    45be:	23fe      	movs	r3, #254	; 0xfe
    45c0:	f04f 0e7f 	mov.w	lr, #127	; 0x7f
    45c4:	207e      	movs	r0, #126	; 0x7e
    45c6:	e593      	b.n	40f0 <_malloc_r+0x44>
    45c8:	2201      	movs	r2, #1
    45ca:	f04f 0900 	mov.w	r9, #0
    45ce:	e6c1      	b.n	4354 <_malloc_r+0x2a8>
    45d0:	f104 0108 	add.w	r1, r4, #8
    45d4:	4630      	mov	r0, r6
    45d6:	f000 f925 	bl	4824 <_free_r>
    45da:	f8d9 1000 	ldr.w	r1, [r9]
    45de:	e6db      	b.n	4398 <_malloc_r+0x2ec>
    45e0:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    45e4:	d805      	bhi.n	45f2 <_malloc_r+0x546>
    45e6:	0bda      	lsrs	r2, r3, #15
    45e8:	f102 0178 	add.w	r1, r2, #120	; 0x78
    45ec:	0049      	lsls	r1, r1, #1
    45ee:	3277      	adds	r2, #119	; 0x77
    45f0:	e71e      	b.n	4430 <_malloc_r+0x384>
    45f2:	f240 5154 	movw	r1, #1364	; 0x554
    45f6:	428a      	cmp	r2, r1
    45f8:	d805      	bhi.n	4606 <_malloc_r+0x55a>
    45fa:	0c9a      	lsrs	r2, r3, #18
    45fc:	f102 017d 	add.w	r1, r2, #125	; 0x7d
    4600:	0049      	lsls	r1, r1, #1
    4602:	327c      	adds	r2, #124	; 0x7c
    4604:	e714      	b.n	4430 <_malloc_r+0x384>
    4606:	21fe      	movs	r1, #254	; 0xfe
    4608:	227e      	movs	r2, #126	; 0x7e
    460a:	e711      	b.n	4430 <_malloc_r+0x384>
    460c:	687b      	ldr	r3, [r7, #4]
    460e:	e784      	b.n	451a <_malloc_r+0x46e>
    4610:	08e8      	lsrs	r0, r5, #3
    4612:	1c43      	adds	r3, r0, #1
    4614:	005b      	lsls	r3, r3, #1
    4616:	e5f8      	b.n	420a <_malloc_r+0x15e>
    4618:	20000b84 	.word	0x20000b84

0000461c <memset>:
    461c:	b470      	push	{r4, r5, r6}
    461e:	0784      	lsls	r4, r0, #30
    4620:	d046      	beq.n	46b0 <memset+0x94>
    4622:	1e54      	subs	r4, r2, #1
    4624:	2a00      	cmp	r2, #0
    4626:	d041      	beq.n	46ac <memset+0x90>
    4628:	b2cd      	uxtb	r5, r1
    462a:	4603      	mov	r3, r0
    462c:	e002      	b.n	4634 <memset+0x18>
    462e:	1e62      	subs	r2, r4, #1
    4630:	b3e4      	cbz	r4, 46ac <memset+0x90>
    4632:	4614      	mov	r4, r2
    4634:	f803 5b01 	strb.w	r5, [r3], #1
    4638:	079a      	lsls	r2, r3, #30
    463a:	d1f8      	bne.n	462e <memset+0x12>
    463c:	2c03      	cmp	r4, #3
    463e:	d92e      	bls.n	469e <memset+0x82>
    4640:	b2cd      	uxtb	r5, r1
    4642:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
    4646:	2c0f      	cmp	r4, #15
    4648:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
    464c:	d919      	bls.n	4682 <memset+0x66>
    464e:	f103 0210 	add.w	r2, r3, #16
    4652:	4626      	mov	r6, r4
    4654:	3e10      	subs	r6, #16
    4656:	2e0f      	cmp	r6, #15
    4658:	f842 5c10 	str.w	r5, [r2, #-16]
    465c:	f842 5c0c 	str.w	r5, [r2, #-12]
    4660:	f842 5c08 	str.w	r5, [r2, #-8]
    4664:	f842 5c04 	str.w	r5, [r2, #-4]
    4668:	f102 0210 	add.w	r2, r2, #16
    466c:	d8f2      	bhi.n	4654 <memset+0x38>
    466e:	f1a4 0210 	sub.w	r2, r4, #16
    4672:	f022 020f 	bic.w	r2, r2, #15
    4676:	f004 040f 	and.w	r4, r4, #15
    467a:	3210      	adds	r2, #16
    467c:	2c03      	cmp	r4, #3
    467e:	4413      	add	r3, r2
    4680:	d90d      	bls.n	469e <memset+0x82>
    4682:	461e      	mov	r6, r3
    4684:	4622      	mov	r2, r4
    4686:	3a04      	subs	r2, #4
    4688:	2a03      	cmp	r2, #3
    468a:	f846 5b04 	str.w	r5, [r6], #4
    468e:	d8fa      	bhi.n	4686 <memset+0x6a>
    4690:	1f22      	subs	r2, r4, #4
    4692:	f022 0203 	bic.w	r2, r2, #3
    4696:	3204      	adds	r2, #4
    4698:	4413      	add	r3, r2
    469a:	f004 0403 	and.w	r4, r4, #3
    469e:	b12c      	cbz	r4, 46ac <memset+0x90>
    46a0:	b2c9      	uxtb	r1, r1
    46a2:	441c      	add	r4, r3
    46a4:	f803 1b01 	strb.w	r1, [r3], #1
    46a8:	42a3      	cmp	r3, r4
    46aa:	d1fb      	bne.n	46a4 <memset+0x88>
    46ac:	bc70      	pop	{r4, r5, r6}
    46ae:	4770      	bx	lr
    46b0:	4614      	mov	r4, r2
    46b2:	4603      	mov	r3, r0
    46b4:	e7c2      	b.n	463c <memset+0x20>
    46b6:	bf00      	nop

000046b8 <__malloc_lock>:
    46b8:	4770      	bx	lr
    46ba:	bf00      	nop

000046bc <__malloc_unlock>:
    46bc:	4770      	bx	lr
    46be:	bf00      	nop

000046c0 <_sbrk_r>:
    46c0:	b538      	push	{r3, r4, r5, lr}
    46c2:	4c07      	ldr	r4, [pc, #28]	; (46e0 <_sbrk_r+0x20>)
    46c4:	2300      	movs	r3, #0
    46c6:	4605      	mov	r5, r0
    46c8:	4608      	mov	r0, r1
    46ca:	6023      	str	r3, [r4, #0]
    46cc:	f7fe fa60 	bl	2b90 <_sbrk>
    46d0:	1c43      	adds	r3, r0, #1
    46d2:	d000      	beq.n	46d6 <_sbrk_r+0x16>
    46d4:	bd38      	pop	{r3, r4, r5, pc}
    46d6:	6823      	ldr	r3, [r4, #0]
    46d8:	2b00      	cmp	r3, #0
    46da:	d0fb      	beq.n	46d4 <_sbrk_r+0x14>
    46dc:	602b      	str	r3, [r5, #0]
    46de:	bd38      	pop	{r3, r4, r5, pc}
    46e0:	2000328c 	.word	0x2000328c

000046e4 <__register_exitproc>:
    46e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    46e8:	4c25      	ldr	r4, [pc, #148]	; (4780 <__register_exitproc+0x9c>)
    46ea:	6825      	ldr	r5, [r4, #0]
    46ec:	f8d5 4148 	ldr.w	r4, [r5, #328]	; 0x148
    46f0:	4606      	mov	r6, r0
    46f2:	4688      	mov	r8, r1
    46f4:	4692      	mov	sl, r2
    46f6:	4699      	mov	r9, r3
    46f8:	b3c4      	cbz	r4, 476c <__register_exitproc+0x88>
    46fa:	6860      	ldr	r0, [r4, #4]
    46fc:	281f      	cmp	r0, #31
    46fe:	dc17      	bgt.n	4730 <__register_exitproc+0x4c>
    4700:	1c43      	adds	r3, r0, #1
    4702:	b176      	cbz	r6, 4722 <__register_exitproc+0x3e>
    4704:	eb04 0580 	add.w	r5, r4, r0, lsl #2
    4708:	2201      	movs	r2, #1
    470a:	f8c5 a088 	str.w	sl, [r5, #136]	; 0x88
    470e:	f8d4 1188 	ldr.w	r1, [r4, #392]	; 0x188
    4712:	4082      	lsls	r2, r0
    4714:	4311      	orrs	r1, r2
    4716:	2e02      	cmp	r6, #2
    4718:	f8c4 1188 	str.w	r1, [r4, #392]	; 0x188
    471c:	f8c5 9108 	str.w	r9, [r5, #264]	; 0x108
    4720:	d01e      	beq.n	4760 <__register_exitproc+0x7c>
    4722:	3002      	adds	r0, #2
    4724:	6063      	str	r3, [r4, #4]
    4726:	f844 8020 	str.w	r8, [r4, r0, lsl #2]
    472a:	2000      	movs	r0, #0
    472c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    4730:	4b14      	ldr	r3, [pc, #80]	; (4784 <__register_exitproc+0xa0>)
    4732:	b303      	cbz	r3, 4776 <__register_exitproc+0x92>
    4734:	f44f 70c8 	mov.w	r0, #400	; 0x190
    4738:	f7ff fcb0 	bl	409c <malloc>
    473c:	4604      	mov	r4, r0
    473e:	b1d0      	cbz	r0, 4776 <__register_exitproc+0x92>
    4740:	f8d5 3148 	ldr.w	r3, [r5, #328]	; 0x148
    4744:	2700      	movs	r7, #0
    4746:	e880 0088 	stmia.w	r0, {r3, r7}
    474a:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    474e:	4638      	mov	r0, r7
    4750:	2301      	movs	r3, #1
    4752:	f8c4 7188 	str.w	r7, [r4, #392]	; 0x188
    4756:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
    475a:	2e00      	cmp	r6, #0
    475c:	d0e1      	beq.n	4722 <__register_exitproc+0x3e>
    475e:	e7d1      	b.n	4704 <__register_exitproc+0x20>
    4760:	f8d4 118c 	ldr.w	r1, [r4, #396]	; 0x18c
    4764:	430a      	orrs	r2, r1
    4766:	f8c4 218c 	str.w	r2, [r4, #396]	; 0x18c
    476a:	e7da      	b.n	4722 <__register_exitproc+0x3e>
    476c:	f505 74a6 	add.w	r4, r5, #332	; 0x14c
    4770:	f8c5 4148 	str.w	r4, [r5, #328]	; 0x148
    4774:	e7c1      	b.n	46fa <__register_exitproc+0x16>
    4776:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
    477a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    477e:	bf00      	nop
    4780:	2000063c 	.word	0x2000063c
    4784:	0000409d 	.word	0x0000409d

00004788 <_malloc_trim_r>:
    4788:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    478a:	4f23      	ldr	r7, [pc, #140]	; (4818 <_malloc_trim_r+0x90>)
    478c:	460c      	mov	r4, r1
    478e:	4606      	mov	r6, r0
    4790:	f7ff ff92 	bl	46b8 <__malloc_lock>
    4794:	68bb      	ldr	r3, [r7, #8]
    4796:	685d      	ldr	r5, [r3, #4]
    4798:	f025 0503 	bic.w	r5, r5, #3
    479c:	1b29      	subs	r1, r5, r4
    479e:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
    47a2:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
    47a6:	f021 010f 	bic.w	r1, r1, #15
    47aa:	f5a1 5480 	sub.w	r4, r1, #4096	; 0x1000
    47ae:	f5b4 5f80 	cmp.w	r4, #4096	; 0x1000
    47b2:	db07      	blt.n	47c4 <_malloc_trim_r+0x3c>
    47b4:	2100      	movs	r1, #0
    47b6:	4630      	mov	r0, r6
    47b8:	f7ff ff82 	bl	46c0 <_sbrk_r>
    47bc:	68bb      	ldr	r3, [r7, #8]
    47be:	442b      	add	r3, r5
    47c0:	4298      	cmp	r0, r3
    47c2:	d004      	beq.n	47ce <_malloc_trim_r+0x46>
    47c4:	4630      	mov	r0, r6
    47c6:	f7ff ff79 	bl	46bc <__malloc_unlock>
    47ca:	2000      	movs	r0, #0
    47cc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    47ce:	4261      	negs	r1, r4
    47d0:	4630      	mov	r0, r6
    47d2:	f7ff ff75 	bl	46c0 <_sbrk_r>
    47d6:	3001      	adds	r0, #1
    47d8:	d00d      	beq.n	47f6 <_malloc_trim_r+0x6e>
    47da:	4b10      	ldr	r3, [pc, #64]	; (481c <_malloc_trim_r+0x94>)
    47dc:	68ba      	ldr	r2, [r7, #8]
    47de:	6819      	ldr	r1, [r3, #0]
    47e0:	1b2d      	subs	r5, r5, r4
    47e2:	f045 0501 	orr.w	r5, r5, #1
    47e6:	4630      	mov	r0, r6
    47e8:	1b09      	subs	r1, r1, r4
    47ea:	6055      	str	r5, [r2, #4]
    47ec:	6019      	str	r1, [r3, #0]
    47ee:	f7ff ff65 	bl	46bc <__malloc_unlock>
    47f2:	2001      	movs	r0, #1
    47f4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    47f6:	2100      	movs	r1, #0
    47f8:	4630      	mov	r0, r6
    47fa:	f7ff ff61 	bl	46c0 <_sbrk_r>
    47fe:	68ba      	ldr	r2, [r7, #8]
    4800:	1a83      	subs	r3, r0, r2
    4802:	2b0f      	cmp	r3, #15
    4804:	ddde      	ble.n	47c4 <_malloc_trim_r+0x3c>
    4806:	4c06      	ldr	r4, [pc, #24]	; (4820 <_malloc_trim_r+0x98>)
    4808:	4904      	ldr	r1, [pc, #16]	; (481c <_malloc_trim_r+0x94>)
    480a:	6824      	ldr	r4, [r4, #0]
    480c:	f043 0301 	orr.w	r3, r3, #1
    4810:	1b00      	subs	r0, r0, r4
    4812:	6053      	str	r3, [r2, #4]
    4814:	6008      	str	r0, [r1, #0]
    4816:	e7d5      	b.n	47c4 <_malloc_trim_r+0x3c>
    4818:	20000b84 	.word	0x20000b84
    481c:	200016c0 	.word	0x200016c0
    4820:	20000f90 	.word	0x20000f90

00004824 <_free_r>:
    4824:	2900      	cmp	r1, #0
    4826:	d045      	beq.n	48b4 <_free_r+0x90>
    4828:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    482c:	460d      	mov	r5, r1
    482e:	4680      	mov	r8, r0
    4830:	f7ff ff42 	bl	46b8 <__malloc_lock>
    4834:	f855 7c04 	ldr.w	r7, [r5, #-4]
    4838:	496a      	ldr	r1, [pc, #424]	; (49e4 <_free_r+0x1c0>)
    483a:	f027 0301 	bic.w	r3, r7, #1
    483e:	f1a5 0408 	sub.w	r4, r5, #8
    4842:	18e2      	adds	r2, r4, r3
    4844:	688e      	ldr	r6, [r1, #8]
    4846:	6850      	ldr	r0, [r2, #4]
    4848:	42b2      	cmp	r2, r6
    484a:	f020 0003 	bic.w	r0, r0, #3
    484e:	d062      	beq.n	4916 <_free_r+0xf2>
    4850:	07fe      	lsls	r6, r7, #31
    4852:	6050      	str	r0, [r2, #4]
    4854:	d40b      	bmi.n	486e <_free_r+0x4a>
    4856:	f855 7c08 	ldr.w	r7, [r5, #-8]
    485a:	1be4      	subs	r4, r4, r7
    485c:	f101 0e08 	add.w	lr, r1, #8
    4860:	68a5      	ldr	r5, [r4, #8]
    4862:	4575      	cmp	r5, lr
    4864:	443b      	add	r3, r7
    4866:	d06f      	beq.n	4948 <_free_r+0x124>
    4868:	68e7      	ldr	r7, [r4, #12]
    486a:	60ef      	str	r7, [r5, #12]
    486c:	60bd      	str	r5, [r7, #8]
    486e:	1815      	adds	r5, r2, r0
    4870:	686d      	ldr	r5, [r5, #4]
    4872:	07ed      	lsls	r5, r5, #31
    4874:	d542      	bpl.n	48fc <_free_r+0xd8>
    4876:	f043 0201 	orr.w	r2, r3, #1
    487a:	6062      	str	r2, [r4, #4]
    487c:	50e3      	str	r3, [r4, r3]
    487e:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
    4882:	d218      	bcs.n	48b6 <_free_r+0x92>
    4884:	08db      	lsrs	r3, r3, #3
    4886:	1c5a      	adds	r2, r3, #1
    4888:	684d      	ldr	r5, [r1, #4]
    488a:	f851 7032 	ldr.w	r7, [r1, r2, lsl #3]
    488e:	60a7      	str	r7, [r4, #8]
    4890:	2001      	movs	r0, #1
    4892:	109b      	asrs	r3, r3, #2
    4894:	fa00 f303 	lsl.w	r3, r0, r3
    4898:	eb01 00c2 	add.w	r0, r1, r2, lsl #3
    489c:	431d      	orrs	r5, r3
    489e:	3808      	subs	r0, #8
    48a0:	60e0      	str	r0, [r4, #12]
    48a2:	604d      	str	r5, [r1, #4]
    48a4:	f841 4032 	str.w	r4, [r1, r2, lsl #3]
    48a8:	60fc      	str	r4, [r7, #12]
    48aa:	4640      	mov	r0, r8
    48ac:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    48b0:	f7ff bf04 	b.w	46bc <__malloc_unlock>
    48b4:	4770      	bx	lr
    48b6:	0a5a      	lsrs	r2, r3, #9
    48b8:	2a04      	cmp	r2, #4
    48ba:	d853      	bhi.n	4964 <_free_r+0x140>
    48bc:	099a      	lsrs	r2, r3, #6
    48be:	f102 0739 	add.w	r7, r2, #57	; 0x39
    48c2:	007f      	lsls	r7, r7, #1
    48c4:	f102 0538 	add.w	r5, r2, #56	; 0x38
    48c8:	eb01 0087 	add.w	r0, r1, r7, lsl #2
    48cc:	f851 2027 	ldr.w	r2, [r1, r7, lsl #2]
    48d0:	4944      	ldr	r1, [pc, #272]	; (49e4 <_free_r+0x1c0>)
    48d2:	3808      	subs	r0, #8
    48d4:	4290      	cmp	r0, r2
    48d6:	d04d      	beq.n	4974 <_free_r+0x150>
    48d8:	6851      	ldr	r1, [r2, #4]
    48da:	f021 0103 	bic.w	r1, r1, #3
    48de:	428b      	cmp	r3, r1
    48e0:	d202      	bcs.n	48e8 <_free_r+0xc4>
    48e2:	6892      	ldr	r2, [r2, #8]
    48e4:	4290      	cmp	r0, r2
    48e6:	d1f7      	bne.n	48d8 <_free_r+0xb4>
    48e8:	68d0      	ldr	r0, [r2, #12]
    48ea:	60e0      	str	r0, [r4, #12]
    48ec:	60a2      	str	r2, [r4, #8]
    48ee:	6084      	str	r4, [r0, #8]
    48f0:	60d4      	str	r4, [r2, #12]
    48f2:	4640      	mov	r0, r8
    48f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    48f8:	f7ff bee0 	b.w	46bc <__malloc_unlock>
    48fc:	6895      	ldr	r5, [r2, #8]
    48fe:	4f3a      	ldr	r7, [pc, #232]	; (49e8 <_free_r+0x1c4>)
    4900:	42bd      	cmp	r5, r7
    4902:	4403      	add	r3, r0
    4904:	d03f      	beq.n	4986 <_free_r+0x162>
    4906:	68d0      	ldr	r0, [r2, #12]
    4908:	60e8      	str	r0, [r5, #12]
    490a:	f043 0201 	orr.w	r2, r3, #1
    490e:	6085      	str	r5, [r0, #8]
    4910:	6062      	str	r2, [r4, #4]
    4912:	50e3      	str	r3, [r4, r3]
    4914:	e7b3      	b.n	487e <_free_r+0x5a>
    4916:	07ff      	lsls	r7, r7, #31
    4918:	4403      	add	r3, r0
    491a:	d407      	bmi.n	492c <_free_r+0x108>
    491c:	f855 2c08 	ldr.w	r2, [r5, #-8]
    4920:	1aa4      	subs	r4, r4, r2
    4922:	4413      	add	r3, r2
    4924:	68a0      	ldr	r0, [r4, #8]
    4926:	68e2      	ldr	r2, [r4, #12]
    4928:	60c2      	str	r2, [r0, #12]
    492a:	6090      	str	r0, [r2, #8]
    492c:	4a2f      	ldr	r2, [pc, #188]	; (49ec <_free_r+0x1c8>)
    492e:	6812      	ldr	r2, [r2, #0]
    4930:	f043 0001 	orr.w	r0, r3, #1
    4934:	4293      	cmp	r3, r2
    4936:	6060      	str	r0, [r4, #4]
    4938:	608c      	str	r4, [r1, #8]
    493a:	d3b6      	bcc.n	48aa <_free_r+0x86>
    493c:	4b2c      	ldr	r3, [pc, #176]	; (49f0 <_free_r+0x1cc>)
    493e:	4640      	mov	r0, r8
    4940:	6819      	ldr	r1, [r3, #0]
    4942:	f7ff ff21 	bl	4788 <_malloc_trim_r>
    4946:	e7b0      	b.n	48aa <_free_r+0x86>
    4948:	1811      	adds	r1, r2, r0
    494a:	6849      	ldr	r1, [r1, #4]
    494c:	07c9      	lsls	r1, r1, #31
    494e:	d444      	bmi.n	49da <_free_r+0x1b6>
    4950:	6891      	ldr	r1, [r2, #8]
    4952:	68d2      	ldr	r2, [r2, #12]
    4954:	60ca      	str	r2, [r1, #12]
    4956:	4403      	add	r3, r0
    4958:	f043 0001 	orr.w	r0, r3, #1
    495c:	6091      	str	r1, [r2, #8]
    495e:	6060      	str	r0, [r4, #4]
    4960:	50e3      	str	r3, [r4, r3]
    4962:	e7a2      	b.n	48aa <_free_r+0x86>
    4964:	2a14      	cmp	r2, #20
    4966:	d817      	bhi.n	4998 <_free_r+0x174>
    4968:	f102 075c 	add.w	r7, r2, #92	; 0x5c
    496c:	007f      	lsls	r7, r7, #1
    496e:	f102 055b 	add.w	r5, r2, #91	; 0x5b
    4972:	e7a9      	b.n	48c8 <_free_r+0xa4>
    4974:	10aa      	asrs	r2, r5, #2
    4976:	684b      	ldr	r3, [r1, #4]
    4978:	2501      	movs	r5, #1
    497a:	fa05 f202 	lsl.w	r2, r5, r2
    497e:	4313      	orrs	r3, r2
    4980:	604b      	str	r3, [r1, #4]
    4982:	4602      	mov	r2, r0
    4984:	e7b1      	b.n	48ea <_free_r+0xc6>
    4986:	f043 0201 	orr.w	r2, r3, #1
    498a:	614c      	str	r4, [r1, #20]
    498c:	610c      	str	r4, [r1, #16]
    498e:	60e5      	str	r5, [r4, #12]
    4990:	60a5      	str	r5, [r4, #8]
    4992:	6062      	str	r2, [r4, #4]
    4994:	50e3      	str	r3, [r4, r3]
    4996:	e788      	b.n	48aa <_free_r+0x86>
    4998:	2a54      	cmp	r2, #84	; 0x54
    499a:	d806      	bhi.n	49aa <_free_r+0x186>
    499c:	0b1a      	lsrs	r2, r3, #12
    499e:	f102 076f 	add.w	r7, r2, #111	; 0x6f
    49a2:	007f      	lsls	r7, r7, #1
    49a4:	f102 056e 	add.w	r5, r2, #110	; 0x6e
    49a8:	e78e      	b.n	48c8 <_free_r+0xa4>
    49aa:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
    49ae:	d806      	bhi.n	49be <_free_r+0x19a>
    49b0:	0bda      	lsrs	r2, r3, #15
    49b2:	f102 0778 	add.w	r7, r2, #120	; 0x78
    49b6:	007f      	lsls	r7, r7, #1
    49b8:	f102 0577 	add.w	r5, r2, #119	; 0x77
    49bc:	e784      	b.n	48c8 <_free_r+0xa4>
    49be:	f240 5054 	movw	r0, #1364	; 0x554
    49c2:	4282      	cmp	r2, r0
    49c4:	d806      	bhi.n	49d4 <_free_r+0x1b0>
    49c6:	0c9a      	lsrs	r2, r3, #18
    49c8:	f102 077d 	add.w	r7, r2, #125	; 0x7d
    49cc:	007f      	lsls	r7, r7, #1
    49ce:	f102 057c 	add.w	r5, r2, #124	; 0x7c
    49d2:	e779      	b.n	48c8 <_free_r+0xa4>
    49d4:	27fe      	movs	r7, #254	; 0xfe
    49d6:	257e      	movs	r5, #126	; 0x7e
    49d8:	e776      	b.n	48c8 <_free_r+0xa4>
    49da:	f043 0201 	orr.w	r2, r3, #1
    49de:	6062      	str	r2, [r4, #4]
    49e0:	50e3      	str	r3, [r4, r3]
    49e2:	e762      	b.n	48aa <_free_r+0x86>
    49e4:	20000b84 	.word	0x20000b84
    49e8:	20000b8c 	.word	0x20000b8c
    49ec:	20000f8c 	.word	0x20000f8c
    49f0:	200016bc 	.word	0x200016bc
    49f4:	00000000 	.word	0x00000000

000049f8 <___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer>:
    49f8:	f85f f000 	ldr.w	pc, [pc]	; 49fc <___ZN11AudioStream17initialize_memoryEP18audio_block_structj_veneer+0x4>
    49fc:	600015e9 	.word	0x600015e9

00004a00 <___Z14set_audioClockilmb_veneer>:
    4a00:	f85f f000 	ldr.w	pc, [pc]	; 4a04 <___Z14set_audioClockilmb_veneer+0x4>
    4a04:	600011e9 	.word	0x600011e9

00004a08 <___init_veneer>:
    4a08:	f85f f000 	ldr.w	pc, [pc]	; 4a0c <___init_veneer+0x4>
    4a0c:	60001869 	.word	0x60001869

Disassembly of section .fini:

00004a10 <_fini>:
    4a10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    4a12:	bf00      	nop
